# Reversing in action: Golang malware used in the SolarWinds attack (Kaspersky)
This course is a must if your going to reverse go malware, it takes a very deep approach in the analysis of a malware named **SunShuttle**, it was notably used as a fully featured backdoored in the **SolarWinds Breach Indicent**, which was one of the biggest breach in the history of hacking.
## Introduction
**What you will learn** :

    - How to reverse-engineer Go Malware
    - Fundamentals of the Go Language

**Why it is important ? :**
    
    - Go is increasingly being used among malware authors
    - Go binaries cannot be tackled with the usual approach

**In Context :** [Sunburst Backdoor Kazuar](https://securelist.com/sunburst-backdoor-kazuar)

If you haven't did already, go see my notes on [Anatomy of a Gopher](https://exploitation.reversing-ninja.com/anatomy-of-a-gopher.html) they might greatly help for this course and also don't forget to go watch the SANS talk by hex0punk about Go Reverse Engineer (link in Anatomy of a Gopher notes).

**Things to notes about Go before starting to reverse :**
    
    - Generates statically-built executables, this makes the program weigh a LOT more than usual dynamically programs, a simple **Hello World** program can weigh up to **2 Megabytes** that is huge !
    - Go does not enable PIC or PIE (Position Independent Code or Executable).
    - Go does not stripped binaries by default.
    - Go does not enable any stack protections (stack canaries).
    - Searching for strings in a Go binary can't be quite a pain in the ass.
    - Searching for functions is easier than searching for strings, since functions name aren't stripped.
    - Go stacks are really small by default (2 kibibytes or 1024 bytes of stack), therefore many goroutines will call **morestack** (sym.runtime.morestack\_noctxt), to grow the stack size (in powers of 2) as needed using **stack copying**.
a    - Go uses 8 bytes alignment on the stack.
    - Each functions compare it's stack pointer agains't **g->stackguard** to check for overflow.
    - Go binaries can return multiple values, therefore it places all the return values on the stack, because 3 return values would not fit inside rax.
    - Decompiling go binaries won't be very useful as it doesn't make the code more readable in a C representation.
## Practice Reverse Engineering Small Go Programs
Let's take an example, we will write a small Go program, compile it without optimizations and look at the assembly of it, we will write this small program :
```go
package main
import (
    "fmt"
)

// Compiled with disabled optimizations (-gcflags '-N -l')

func main(){
    res := sum(1, 10, 100)
    fmt.Println("Result = ", res)
}

func sum(a, b, c int) (int){
    return a + b + c
}
```

**Compile this and open it in IDA or your preferred disassembler and let's start doing some reversing :**

First thing to note is that we don't have the usual function prologue
```x86asm
    push rbp; 
    mov rbp, rsp
```

Instead functions start by checking if the stack is big enough as you can see in the following code
```x86asm
    mov rcx, gs:28h; 
    mov rcx, [rcx+0]; 
    lea rax, [rsp+var_8]; 
    cmp rax, [rcx+10h]; 
    jbe address
```

In this code we check if the argument at [rsp+var\_8] is below the address of **rcx**, which should be something like the stack size or address or offset, i am not sure on this one.

If we were below **rcx** or equal to it, we jump to **sym.runtime.morestack_noctxt**, which as said previously will double the stack size using **stack copying**.

Since this code is usually present at the beginning of every function, you can just ignore it (you can change it's color to black in IDA or what i like to do is right click on the block of code i want to hide and click group node, input a text that represent the block code and confirm).

You should end up with something that look like this if you did my way :

![Nodes Grouped](https://i.imgur.com/XMz2wFR.png)

You can see that i highlighted some stuff, first i highlighted the arguments of the **main_sum** function call, these arguments are **1, 10, 100** respectivily which are the exact same values we passed to main.sum the main function in our source (**sum(1, 10, 100)**).

Secundo i highlighted the function **main_sum** in green, and for those who haven't noticed i have explicitely written where the main code block is, although i assume you would have been able to find it yourself.

Okay now have you already forgotten that Go return values on the stack instead of rax ? hopefully not, let's prove this :
```x86asm
mov     [esp+0x40+var_40], 1   
mov     [esp+0x40+var_3C], 0xA
mov     [esp+0x40+var_38], 0x64
call    main_sum
mov     eax, [esp+0x40+var_34]
mov     [esp+0x40+var_28], eax
```

We first prepare for the **main_sum** function and put every argument on the stack, each of those arguments takes **4 bytes in size** (we know we are dealing with integers), also note that the arguments are put backward on the stack. We then call our functions main, and return. Our return value has been placed **4 bytes below our first argument (0x64 located at [esp+0x40+var_38])**, our return value is only 4 bytes in size since we have implicitly declared it to be a int in our source code.

One nice thing Ivan teached me is that arguments will be interpreted as variables in the disassembly, you can press **q** on them and it will change them and make them look more like **stack offsets**, renaming variables can be quite useless in any case since variables are used to do very different things throughout the lifetime of the function.
![Removing Variables](https://thumbs.gfycat.com/SmoothAmusingGrouper-mobile.mp4)

One last thing is the fmt\_Printf printf function which we haven't seen yet, it a little bit further in the assembly
![fmt\_Println](https://i.imgur.com/IWygaIL.png)

**Let's write a little more complex go program and let's reverse it :**
This time we will use multiple return values with a mini error handling mechanism, the code is going to be once again really easy to read and understand
```go
package main
import(
    "fmt"
    "errors"
)

func main(){
    res, s, err := sum(1, 10, 100)
    if err == nil {
        fmt.Println("Result = ", res, s)
    }
}

func sum(a, b, c int) (int, string, error){
    return a + b + c, "REMA2", errors.New("Fake Error")
}
```

Compile the code with the same flags we used earlier (**go build -gcflags "all=-N -l" program.go -o program.exe**), and let's reverse it !

